---
title: ""
author: "Dr. ir. L.N. van der Laan, N.E. van der Waal, MSc, J.M.S. de Wit, PDEng"
date: ""
output: 
  bookdown::word_document2:
    toc: true
    toc_depth: 3
    reference_docx: markdown_template.docx
toc-title: "Inhoudsopgave"    
---
```{r setup, include=FALSE}
rm(list = ls()) #Clear workspace
knitr::opts_chunk$set(echo = TRUE)

# Disable output of warnings to the generated doc file
# Set to FALSE for final doc, TRUE for debugging
knitr::opts_chunk$set(warning = FALSE)

##### Load packages
# For importing SPSS files
library(foreign)

# For filtering
library(plyr)
library(dplyr)

# For tables
library(flextable)
library(arsenal)

# Various plotting 
library(ggplot2)
library(tidyr)
library(forcats)
library(scales)
library(RColorBrewer)
library(cowplot) # for aligning ggplots vertically

# For analysis and data preprocessing
library(psy) # psy for the cronbach function
library(reshape2) # For converting from wide to long format (function: melt)
library(rcompanion) # For the posthoc chi square tests

# Other
library(labelled)

################ Settings and variables for plotting, images, etc. #######################
### Set up color palettes for graphs
my_palette5 <- brewer.pal(11,"RdYlGn")[c(4, 5, 6, 7, 8, 9, 10)]
my_palette7 <- brewer.pal(11,"RdYlGn")[c(9,8,7,6,5,4,3)]
my_palette_nonuse = c(brewer.pal(11, "RdGy")[c(11)], brewer.pal(11, "RdYlGn")[c(9,8,7,6,5,4,3)])
my_palette5true <- c(brewer.pal(11, "RdGy")[c(11)], brewer.pal(11, "RdYlGn")[c(6,7,8,9)])
my_palette5blue <- c(brewer.pal(11, "RdGy")[c(11)], brewer.pal(11, "Blues")[c(6,5,4,3)])
my_palette7blue <- brewer.pal(11, "Blues")[c(7,6,5,4,3,2,1)]

################ Set up data preprocessing and analysis #############################
##### Load dataset (not included on Github)
data_in <- read.spss('L_CoronaMelder_wave1_3p.sav', to.data.frame=TRUE, use.missings=FALSE)

# Filter out the respondents that did not complete the entire survey (N = 10)
data <- data_in[!is.na(data_in$duur),]

##### Preprocessing and cleaning up variables
### Drop unused levels from some particular factors. The reason to do this is that there are levels in the dataset that were not included in the current sample (for instance participants of child age are present in the LISS panel but not in the representative sample of Dutch inhabitants that was included for this study)
data$lftdcat = droplevels(data$lftdcat)
data$belbezig = droplevels(data$belbezig)

### Combine some variable levels in order to have sufficient counts in cells for demographics
# For demographic variable stedelijkheid. 
data$sted_simplified = data$sted
levels(data$sted_simplified) <- c(levels(data$sted_simplified),"Onbekend") # Add the new level that will contain the merged levels
data$sted_simplified[is.na(data$sted)] <- "Onbekend"
data$sted_simplified = factor(data$sted_simplified)

# For demographic variable oplmet. 
data$oplmet_simplified = data$oplmet
data$oplmet_simplified[data$oplmet == "anders" | data$oplmet == "(Nog) geen onderwijs afgerond" | data$oplmet == "Volgt nog geen onderwijs"] <- "anders"
data$oplmet_simplified = factor(data$oplmet_simplified)

# For demographic variable belbezig. 
data$belbezig_simplified = data$belbezig
levels(data$belbezig_simplified) <- c(levels(data$belbezig_simplified),"Anders") # Add the new level that will contain the merged levels
data$belbezig_simplified[data$belbezig == "Werkt of is meewerkend in gezins- of familiebedrijf" | data$belbezig == "Zoekt voor het eerst werk" | data$belbezig == "Zoekt werk na verlies werkkring" | data$belbezig == "Verricht onbetaald werk met behoud van uitkering" | data$belbezig == "Verricht vrijwilligerswerk" | data$belbezig == "Vrijgesteld van werkzoeken na verlies van werkkring" |data$belbezig == "Doet iets anders"] <- "Anders"
data$belbezig_simplified = factor(data$belbezig_simplified)
#View(data[,c("belbezig","belbezig_simplified")])

# For demographic variable burgstat. Add the people that are "Gescheiden van tafel en bed" to the "Gescheiden categorie"
data$burgstat_simplified = data$burgstat
data$burgstat_simplified[data$burgstat == "Gescheiden van tafel en bed"] <- "Gescheiden"
data$burgstat_simplified = factor(data$burgstat_simplified)

# For demographic variable nettocat. Make category with 3501 euro or higher and unknown ("weet ik niet" en "wil niet zeggen" en NMISS) 
data$nettocat_simplified = data$nettocat
levels(data$nettocat_simplified) <- c(levels(data$nettocat_simplified),"Meer dan EUR 3501", "Onbekend") # Add the new level that will contain the merged levels
data$nettocat_simplified[data$nettocat == "Dat weet ik echt niet" | data$nettocat == "Dat wil ik niet zeggen" | is.na(data$nettocat)] <- "Onbekend"
data$nettocat_simplified[data$nettocat == "EUR 3501 t/m EUR 4000" | data$nettocat == "EUR 4001 t/m EUR 4500" | data$nettocat == "EUR 4501 t/m EUR 5000" | data$nettocat == "EUR 5001 t/m EUR 7500" | data$nettocat == "Meer dan EUR 7500"] <- "Meer dan EUR 3501"
data$nettocat_simplified = factor(data$nettocat_simplified)

### Add labels to variables of main dataset
attr(data$geslacht,'label')  <- 'Geslacht'
attr(data$lftdcat,'label')  <- 'Leeftijdscategorie'
attr(data$sted_simplified,'label')  <- 'Stedelijkheid woonplaats'
attr(data$belbezig_simplified,'label')  <- 'Belangrijkste bezigheid'
attr(data$nettocat_simplified,'label')  <- 'Netto maandinkomen'
attr(data$oplmet_simplified,'label')  <- 'Hoogste opleiding met diploma'
attr(data$burgstat_simplified,'label')  <- 'Burgerlijke staat'
attr(data$woonvorm,'label')  <- 'Woonvorm huishouden'
attr(data$Riskgroup_contact,'label')  <- 'Frequentie op minder dan 1.5m van ouderen en mensen met een kwetsbare gezondheid zijn vanwege werk en/of (privé) zorgtaken'

##### Creating new variables
### User status. 
# Of interest is the comparison of current users and current non users.  
data$user_status[data$Behavior_UTAUT == "Ik gebruik de CoronaMelder app op dit moment"] <- "Gebruiker"
data$user_status[data$Behavior_UTAUT == "Ik heb de CoronaMelder app nooit gebruikt"] <- "Niet gebruiker"
data$user_status[data$Behavior_UTAUT == "Ik heb de CoronaMelder app in het verleden wel gebruikt maar op dit moment niet meer"] <- "Voormalig gebruiker"

# Add factor
data$user_status <- factor(data$user_status,levels = c("Gebruiker", "Niet gebruiker", "Voormalig gebruiker"))

### User status and intention. 
# Of interest is the comparison of current users and the non users that are neutral when it comes to intention.  
data$user_status_intention[data$Behavior_UTAUT == "Ik gebruik de CoronaMelder app op dit moment"] <- "Gebruiker"
data$user_status_intention[(data$Behavior_UTAUT == "Ik heb de CoronaMelder app nooit gebruikt") & (data$BI1a_UTAUT == 'Helemaal mee oneens'| data$BI1a_UTAUT == 'Oneens'| data$BI1a_UTAUT == 'Een beetje oneens')] <- "Nooit gebruikt en niet van plan"
data$user_status_intention[(data$Behavior_UTAUT == "Ik heb de CoronaMelder app nooit gebruikt") & (data$BI1a_UTAUT == 'Neutraal')] <- "Nooit gebruikt en neutraal"
data$user_status_intention[(data$Behavior_UTAUT == "Ik heb de CoronaMelder app nooit gebruikt") & (data$BI1a_UTAUT == 'Helemaal mee eens'| data$BI1a_UTAUT == 'Mee eens'| data$BI1a_UTAUT == 'Een beetje mee eens')] <- "Nooit gebruikt en wel van plan"
data$user_status_intention[data$Behavior_UTAUT == "Ik heb de CoronaMelder app in het verleden wel gebruikt maar op dit moment niet meer"] <- "Voormalig gebruiker"
#View(data[,c("Behavior_UTAUT","BI1a_UTAUT","user_status_intention")])

# Add factor
data$user_status_intention <- factor(data$user_status_intention,levels = c("Gebruiker", "Nooit gebruikt en niet van plan", "Nooit gebruikt en neutraal", "Nooit gebruikt en wel van plan", "Voormalig gebruiker"))

### Health literacy
# To enable a median split, labels are first recoded to numbers 
data$HealthLiteracy1n = recode(data$HealthLiteracy1, Nooit=1, 'Af en toe'=2, Soms=3, Vaak=4,  Altijd=5)
data$HealthLiteracy2n = recode(data$HealthLiteracy2, 'Helemaal niet'=1, 'Een klein beetje'=2, 'Een beetje'=3, 'Nogal'=4,  'Heel erg'=5)
data$HealthLiteracy3n = recode(data$HealthLiteracy3, Nooit=1, 'Af en toe'=2, Soms=3, Vaak=4,  Altijd=5)

# Since items HealtLiteracy1 and 3 are negatively phrased they will be reverse coded such that higher numbers refer to higher health literacy
data$HealthLiteracy1nr = recode(data$HealthLiteracy1n, "1"=5, "2"=4, "3"=3, "4"=2, "5"=1) 
data$HealthLiteracy3nr = recode(data$HealthLiteracy3n, "1"=5, "2"=4, "3"=3, "4"=2, "5"=1) 

# Calculate construct and cronbach alpha (0.58 - poor). The reliability of the scale is low and based on the histogram the distribution is highly skewed; no further analysis of this variable will be done. 
data$HealthLiteracy <- rowMeans(data[, c("HealthLiteracy1nr", "HealthLiteracy2n", "HealthLiteracy3nr")], na.rm = TRUE)
cronbach(data[, c("HealthLiteracy1nr", "HealthLiteracy2n", "HealthLiteracy3nr")])
#hl_avg <- mean(data$HealthLiteracy)
#hist(data$HealthLiteracy)
# Data splitsen hoge vs. midden. vs lage health literacy
#data$CatHL <- cut(data$HealthLiteracy, breaks = c(0,1.333333,3.66666,5), labels = c("Laag", "Midden", "Hoog"))

##### Create new datasets
### Create a dataset with only the current users and never users for all analyses in which these groups are compared. 
data_currentvsneveruser = data[ which(data$user_status=='Gebruiker' | data$user_status=='Niet gebruiker'), ]
# Drop unused levels
data_currentvsneveruser$user_status = droplevels(data_currentvsneveruser$user_status)
# Add labels to variables
attr(data_currentvsneveruser$geslacht,'label')  <- 'Geslacht'
attr(data_currentvsneveruser$lftdcat,'label')  <- 'Leeftijdscategorie'
attr(data_currentvsneveruser$sted_simplified,'label')  <- 'Stedelijkheid woonplaats'
attr(data_currentvsneveruser$belbezig_simplified,'label')  <- 'Belangrijkste bezigheid'
attr(data_currentvsneveruser$nettocat_simplified,'label')  <- 'Netto maandinkomen'
attr(data_currentvsneveruser$oplmet_simplified,'label')  <- 'Hoogste opleiding met diploma'
attr(data_currentvsneveruser$burgstat_simplified,'label')  <- 'Burgerlijke staat'
attr(data_currentvsneveruser$woonvorm,'label')  <- 'Woonvorm huishouden'
attr(data_currentvsneveruser$Riskgroup_contact,'label')  <- 'Frequentie op minder dan 1.5m van ouderen en mensen met een kwetsbare gezondheid zijn vanwege werk en/of (privé) zorgtaken'

### Create a dataset with only the curent users and never users that are neutral on intention for all analyses in which these groups are compared. 
data_currentvsneveruserneutral = data[ which(data$user_status_intention=='Gebruiker' | data$user_status_intention=='Nooit gebruikt en neutraal'), ]
# Drop unused levels
data_currentvsneveruserneutral$user_status_intention = droplevels(data_currentvsneveruserneutral$user_status_intention)
# Add labels to variables
attr(data_currentvsneveruserneutral$geslacht,'label')  <- 'Geslacht'
attr(data_currentvsneveruserneutral$lftdcat,'label')  <- 'Leeftijdscategorie'
attr(data_currentvsneveruserneutral$sted,'label')  <- 'Stedelijkheid woonplaats'
attr(data_currentvsneveruserneutral$belbezig_simplified,'label')  <- 'Belangrijkste bezigheid'
attr(data_currentvsneveruserneutral$nettocat_simplified,'label')  <- 'Netto maandinkomen'
attr(data_currentvsneveruserneutral$oplmet_simplified,'label')  <- 'Hoogste opleiding met diploma'
attr(data_currentvsneveruserneutral$burgstat_simplified,'label')  <- 'Burgerlijke staat'
attr(data_currentvsneveruserneutral$woonvorm,'label')  <- 'Woonvorm huishouden'
attr(data_currentvsneveruserneutral$Riskgroup_contact,'label')  <- 'Frequentie op minder dan 1.5m van ouderen en mensen met een kwetsbare gezondheid zijn vanwege werk en/of (privé) zorgtaken'

##### Calculate size of user subgroups
# Lookup table for totals of different user groups
usergroup_names = c("users", "nonusers", "nonusers_no_intention", "nonusers_neutral", "nonusers_intention")

usergroup_labels = c("Gebruikers", "Niet gebruikers", "Niet gebruikers - niet van plan om te gaan gebruiken", "Niet gebruikers - neutraal", "Niet gebruikers - wel van plan om te gaan gebruiken")

# Create dataframe for totals of each user group
user_totals <- data.frame(matrix(ncol = length(usergroup_names), nrow = 1))
colnames(user_totals) <- usergroup_names

# Current user
user_totals[1] <- sum(data$user_status == "Gebruiker")

# Non user
user_totals[2] <- sum(data$user_status == "Niet gebruiker")

# Non user -- not planning to use
user_totals[3] <- sum(data$user_status_intention == "Nooit gebruikt en niet van plan")

# Non user -- neutral
user_totals[4] <- sum(data$user_status_intention == "Nooit gebruikt en neutraal")

# Non user -- planning to use
user_totals[5] <- sum(data$user_status_intention == "Nooit gebruikt en wel van plan")

```
```{=openxml}
<w:p><w:r><w:br w:type="page"/></w:r></w:p>
```
# Samenvatting {.unlisted .unnumbered}
## Inleiding {.unlisted .unnumbered}
De CoronaMelder app is ontwikkeld door het ministerie van Volksgezondheid, Welzijn en Sport en wordt nu landelijk gebruikt in de strijd tegen het coronavirus. Het doel van dit onderzoek is om de adoptie van de app en de (intentie tot) opvolging van de in de app gegeven adviezen te onderzoeken en te verklaren.  

## Methode {.unlisted .unnumbered}
In het kader van de evaluatie van de CoronaMelder wordt er een longitudinaal vragenlijstonderzoek uitgevoerd via het LISS panel. De datacollectie (wave 1) van deze rapportage vond plaats tussen 19 oktober en 1 november 2020, 1.5 week na de landelijke lancering op 10 oktober 2020. Aan dit onderzoek hebben `r nrow(data)` (gemiddelde leeftijd in jaren: `r round(mean(data$leeftijd), digits = 1)`, standaarddeviatie: `r round(sd(data$leeftijd), digits = 1)`; `r round((nrow(filter(data, geslacht == 'Vrouw'))/nrow(data))*100, digits = 2)`% vrouw) respondenten deelgenomen.   

## Resultaten en aanbevelingen{.unlisted .unnumbered}  

**Adoptie** Iets meer dan een kwart van de deelnemers gebruikt de CoronaMelder, dat is iets hoger dan wat op basis van de downloadcijfers zou worden verwacht. Van de huidige gebruikers heeft het overgrote merendeel de intentie om de CoronaMelder de komende 2 maanden te blijven gebruiken. Van degenen die de CoronaMelder nog niet gebruiken, heeft bijna 1 op de 5 wel de intentie om de CoronaMelder te gaan gebruiken en een kwart staat hier nog neutraal in. Er waren verschillen in gebruikersstatus op basis van demografie: zo gebruiken jongvolwassenen (tot 24 jaar) en lager opgeleiden de CoronaMelder minder vaak. Dit zijn mogelijk belangrijke doelgroepen om op te richten om de adoptie van de CoronaMelder te verhogen.  

**Verklarende factoren voor adoptie**
Verschillende persoonlijke, sociale en omgevingsfactoren die samenhangen met het gebruik van de CoronaMelder zijn geïdentificeerd. De *risicoperceptie* lijkt een rol te spelen: mensen die de CoronaMelder niet gebruiken schatten de ernst en de vatbaarheid voor het coronavirus lager in dan degenen die hem al wel gebruiken. De *gebruiksvriendelijkheid* is over het algemeen goed: van de gebruikers geeft het overgrote deel aan dat de CoronaMelder makkelijk te gebruiken is en dat gebruik weinig tijd en energie kost. Bij niet gebruikers is deze verwachting echter iets minder positief; dit is een belangrijk aandachtspunt. Over het algemeen is het vertrouwen in de *adequaatheid van de techniek* (bluetooth) om aan te duiden wie er in de buurt is geweest hoog in de hele sample. De niet gebruikers hebben echter een lagere verwachting van de *effectiviteit* van de CoronaMelder in de bijdrage aan het bestrijden van het coronavirus. Met betrekking tot *privacy* is een opvallende bevinding dat een substantieel deel van de gebruikers en (in ernstiger mate) de niet gebruikers (onterecht) denkt dat de CoronaMelder de locatie en persoonsgegevens bijhoudt. Wel denkt een grote meerderheid dat de informatie uit de app vertrouwelijk wordt behandeld, hoewel dit percentage wel weer lager is bij de niet gebruikers. Gezien de substantiële rol van zorgen over privacy in technologie adoptie is het corrigeren van deze mispercepties een belangrijk aandachtspunt. Ook is duidelijk dat niet gebruikers vaker *algemene mispercepties* hebben met betrekking tot het coronavirus (bv. dat het een biologisch wapen is of samenhangt met 5G). Nog een opvallende bevinding is dat bijna een kwart van de niet gebruikers *angstig* staat tegenover de CoronaMelder, terwijl dit bij de gebruikers een zeer klein percentage is. Niet gebruikers hebben over het algemeen een lager *vertrouwen in de overheidsaanpak* tegen het coronavirus. De *sociale invloeden* omtrent het gebruik van de CoronaMelder zijn niet erg gunstig. Hoewel men een redelijk correct beeld heeft van het percentage gebruikers in de Nederlandse bevolking, denkt slechts een relatief laag percentage dat mensen in hun directe omgeving de CoronaMelder gebruiken of gebruik op prijs zouden stellen. Een substantieel deel staat hier neutraal in. Het gebruik van de CoronaMelder is redelijk onzichtbaar vergeleken met andere preventieve gedragingen en de bevindingen zouden ook kunnen suggereren dat de CoronaMelder in de sociale interacties simpelweg niet besproken wordt. *Verplichting tot gebruik* Bijna twee derde van de mensen die de CoronaMelder op dit moment gebruiken geven aan het in meer of mindere mate eens te zijn met de stelling dat men zich verplicht voelt hem te gebruiken. Van de mensen die de CoronaMelder niet gebruiken voelt slechts 12.2% zich verplicht om hem te gebruiken. Een mogelijke verklaring is dat men het gebruiken van de CoronaMelder voelt als een maatschappelijke verplichting. Dit zou verder uitgezocht moeten worden.     

**Intentie tot adherentie aan gedragsadviezen in de melding** Vanwege het lage aantal ontvangen meldingen in de meetperiode is er niets te zeggen over de daadwerkelijke opvolging van de gedragsadviezen. Over het algemeen zijn de intenties voor het opvolgen van de in de melding voorgestelde adviezen echter redelijk goed, met name indien de deelnemer daarnaast ook symptomen heeft die bij het coronavirus passen. Wel is het opvallend dat een relatief laag percentage persoonlijke voordelen ziet aan het opvolgen van de adviezen; dat is een aandachtpunt. Ook gaf een substantieel deel aan dat hij/zij de huisarts zou bellen, ook indien er geen klachten zijn; dat is ongewenst.   

**Doorgeven GGD sleutel bij positieve test** Een overgroot deel van de gebruikers van de CoronaMelder gaf aan de GGD sleutel door te gaan geven indien men positief getest wordt op het coronavirus. Voor de effectiviteit van de CoronaMelder is het wel van belang dat deze intentie omgezet wordt in daadwerkelijk gedrag. 

**Onbeoogde effecten: schijnveiligheid** De overgrote meerderheid gelooft niet dat de andere maatregelen niet meer in acht hoeven worden genomen wanneer men CoronaMelder geïnstalleerd heeft dus het lijkt niet waarschijnlijk dat schijnveiligheid optreedt. 

```{=openxml}
<w:p><w:r><w:br w:type="page"/></w:r></w:p>
```


# Achtergrond
De CoronaMelder app is ontwikkeld door het ministerie van Volksgezondheid, Welzijn en Sport en wordt nu landelijk gebruikt in de strijd tegen het coronavirus. Het doel van dit onderzoek is om, over de tijd, de adoptie van de app en de (intentie tot) opvolging van de in de app gegeven adviezen te onderzoeken en te verklaren.

# Methoden  

## Onderzoeksopzet  

In het kader van de evaluatie van de CoronaMelder wordt er een longitudinaal vragenlijstonderzoek uitgevoerd via het LISS panel (LISSdata.nl) waarbij er over een periode van 5 maanden 4 metingen zullen plaatsvinden. Het doel van dit onderzoek is om, over de tijd, de adoptie van de app en de (intentie tot) opvolging van de in de app gegeven adviezen te onderzoeken en te verklaren. Meer specifiek gaan we in dit longitudinale onderzoek in op de volgende onderzoeksvragen:
  
Onderzoeksvraag 1: Wat is de temporele dynamiek van de adoptie van digitale contracttracering in de Nederlandse bevolking en welke factoren (persoonlijk, sociaal, omgevingsfactoren) hebben hierop betrekking? 
  
Onderzoeksvraag 2: Wat is de temporele dynamiek van de intentie om zich te houden aan de adviezen die worden gecommuniceerd in de digitale contacttracing app CoronaMelder en welke factoren (persoonlijk, sociaal, omgeving, app-gerelateerd) zijn hierop van invloed? 

De huidige rapportage beslaat de data van de eerste meting. Hierdoor zijn effecten alleen voor de eerste wave getoond. Effecten over de tijd zullen in volgende rapportages getoond worden. De datacollectie (wave 1) van deze rapportage vond plaats tussen 19 oktober en 1 november 2020, 1.5 week na de landelijke lancering op 10 oktober 2020. Vervolgmetingen vinden plaats 1.5 maand na lancering (wave 2: 07-12 t/m 20-12), 3 maanden na lancering (18-01 t/m 31-01) en 5 maanden na lancering (15-03 t/m 29-03). 

De (9 minuten durende) vragenlijst bevat op elk meetmoment de volgende onderwerpen:   
- Gebruiksgedrag van CoronaMelder  
- Technologische factoren die zijn afgeleid van de Unified Theory of Acceptance and Use of Techology (UTAUT): prestatieverwachting, inspanningsverwachting, sociale invloed en gedragsintentie. 
- COVID-19 en CoronaMelder-gerelateerde percepties en overtuigingen  
- Overtuigingen over de voordelen en de persoonlijke/maatschappelijke waarde van de CoronaMelder  
- Misvattingen over het coronavirus en CoronaMelder  
- Persoonlijke, sociale en omgevingsfactoren   
- Preventief gedrag / naleving van adviezen en factoren die zijn afgeleid van het Health Belief Model (HBM): Preventief gedrag (afgelopen week en intentie), waargenomen ernst en vatbaarheid, persoonlijke voordelen en barrières, zelfredzaamheid  

Sommige items zijn aan verandering onderhevig (bijvoorbeeld items over misvattingen over de app of het coronavirus zullen gebaseerd zijn op de meest recente ontwikkelingen en actuele gebeurtenissen in de media). In de bijlage kan de vragenlijst van wave 1 gevonden worden. 

## Beschrijving panel
Het LISS panel is bij uitstek geschikt voor onderzoek waarbij een goede vertegenwoordiging van de Nederlandse bevolking van groot belang is. Het LISS panel is een probability-based (geen zelfselectie) panel dat iedere maand vragenlijsten invullen via internet. De adressensteekproeven voor de werving en de bijwervingen zijn getrokken uit het populatieregister in samenwerking met het CBS. Indien een huishouden niet beschikt over een breedbandverbinding en/of computer, dan stelt CentERdata de benodigde apparatuur in bruikleen beschikbaar om alsnog mee te kunnen doen aan het panel. Hiermee onderscheidt het LISS panel zich van andere online panels, waar niet-internetters ontbreken en waar panelleden de gelegenheid hebben om zichzelf aan te melden.  

Panelleden ontvangen € 7,50 voor een vragenlijst met een invultijd van dertig minuten. Omdat het veldwerk standaard bijna een maand duurt en men twee herinneringen krijgt, is iedereen (van oud tot jong, werkend of niet werkend en/of tijdelijk afwezig) in de gelegenheid de vragenlijsten in te vullen.

## Huidige rapportage: Meting 1 

Datum van dataverzameling: 19 oktober 2020 – 1 november 2020.

Steekproef meting 1: Een aselecte steekproef van LISS-panelleden van 16 jaar en ouder die ook de LISS-kernvragenlijst ‘Health’ (afgenomen in november en december 2019) en de vragenlijst over het coronavirus (afgenomen in het LISS panel maart 2020) hebben ingevuld.  

Responsoverzicht | 
------------- | -------------
Selectie aantal leden huishouden: | 2.093 (100,0%)  
Nonrespons | 183 (8,7%)  
Respons | 1.910 (91,3%)  
  Compleet | 1.900 (90,8%)  
  Incompleet | 10 (0,5%)  

In de resultaten sectie worden de uitkomsten getoond van de 1900 respondenten waarvan de data compleet was. Ook wordt er een overzicht van de karakteristieken van de steekproef getoond. In de bijlage kan een vergelijking van de demografische samenstelling van de steekproef in vergelijking met die van de Nederlandse bevolking (op basis van gegevens van het CBS) gevonden worden. 

```{=openxml}
<w:p><w:r><w:br w:type="page"/></w:r></w:p>
```

# Resultaten
## Karakteristieken van de steekproef
### Demografische factoren
Aan dit onderzoek hebben `r nrow(data)` (gemiddelde leeftijd in jaren: `r round(mean(data$leeftijd), digits = 1)`, standaarddeviatie: `r round(sd(data$leeftijd), digits = 1)`, range: `r min(data$leeftijd)`-`r max(data$leeftijd)`; `r round((nrow(filter(data, geslacht == 'Vrouw'))/nrow(data))*100, digits = 2)`% vrouw) respondenten deelgenomen. De demografische kenmerken zijn te vinden in de onderstaande tabel. 

```{r, echo=FALSE, results="asis"} 
tab.noby <- tableby(~ geslacht + lftdcat + sted_simplified + belbezig_simplified + oplmet_simplified + burgstat_simplified + nettocat_simplified + woonvorm + Riskgroup_contact, data=data)
summary(tab.noby, title="(\\#tab:mytableby) Demografische statieken van de steekproef")
```

### Gezondheidsmotivatie en risicoperceptie corona besmetting

#### Besmetting met het coronavirus bij zichzelf en mensen in de directe omgeving
In de vragenlijst werd gevraagd of de respondenten zelf of mensen in hun directe omgeving besmet zijn (geweest) met het coronavirus. In totaal gaven `r round(nrow(filter(data, CoronaInfectionSelf == 'Ja'))/nrow(data)*100, digits = 1)`% van de respondenten het antwoord *Ja* op de vraag of zij zelf dachten besmet te zijn (geweest) en `r round(nrow(filter(data, CoronaInfectionSelf == 'Nee'))/nrow(data)*100, digits = 1)`% antwoorde hierop *Nee*. Een substantieel percentage (`r round(nrow(filter(data, CoronaInfectionSelf == 'Ik weet het niet'))/nrow(data)*100, digits = 1)`%) gaf aan dit niet te weten.

Ook werd gevraagd of er wel eens een coronatest bij de respondent was afgenomen. Hierop antwoorde `r round(nrow(filter(data, CoronaInfectionSelfTest == 'Ja, een keer'))/nrow(data)*100, digits = 1)`% dat er 1 keer een test was afgenomen en `r round(nrow(filter(data, CoronaInfectionSelfTest == 'Ja, meerdere keren'))/nrow(data)*100, digits = 1)`% dat er al meerdere keren een test was afgenomen. De rest (`r round(nrow(filter(data, CoronaInfectionSelfTest == 'Nee'))/nrow(data)*100, digits = 1)`)% gaf aan dat er nog nooit een test was afgenomen. 

Van de mensen bij wie al minstens een keer een test was afgenomen (`r  nrow(filter(data, (CoronaInfectionSelfTest == 'Ja, een keer' | CoronaInfectionSelfTest == 'Ja, meerdere keren')))`), gaf  `r  round((nrow(filter(data, (CoronaInfectionSelfTest_1 == 'Ja' | CoronaInfectionSelfTest_2 == 'Ja'))) / nrow(filter(data, (CoronaInfectionSelfTest == 'Ja, een keer' | CoronaInfectionSelfTest == 'Ja, meerdere keren'))))*100, digits = 1)`% aan dat een van deze testen positief was, `r  round((nrow(filter(data, (CoronaInfectionSelfTest_1 == 'Nee' | CoronaInfectionSelfTest_2 == 'Nee'))) / nrow(filter(data, (CoronaInfectionSelfTest == 'Ja, een keer' | CoronaInfectionSelfTest == 'Ja, meerdere keren'))))*100, digits = 1)`% gaf aan dat de test negatief was en de rest (`r  round((nrow(filter(data, (CoronaInfectionSelfTest_1 == 'Weet ik (nog) niet' | CoronaInfectionSelfTest_2 == 'Weet ik (nog) niet'))) / nrow(filter(data, (CoronaInfectionSelfTest == 'Ja, een keer' | CoronaInfectionSelfTest == 'Ja, meerdere keren'))))*100, digits = 1)`%) gaf aan dit (nog) niet te weten. 

In totaal `r round(nrow(filter(data, (CoronaInfectionOther_1 == 'Ja' | CoronaInfectionOther_2 == 'Ja' | CoronaInfectionOther_3 == 'Ja' | CoronaInfectionOther_4 == 'Ja' | CoronaInfectionOther_5 == 'Ja' | CoronaInfectionOther_6 == 'Ja')))/nrow(data)*100, digits = 1)`% gaf aan dat iemand in hun directe omgeving besmet is (geweest)  met het coronavirus. In onderstaande grafiek (figuur \@ref(fig:coronainfectionother) is te zien welke relatie deze personen tot de respondent hadden. In totaal `r round(nrow(filter(data, (CoronaInfectionOther_7 == 'Ja')))/nrow(data)*100, digits = 1)`% gaf aan dat niemand in hun directe omgeving besmet is (geweest)  met het coronavirus en `r round(nrow(filter(data, (CoronaInfectionOther_8 == 'Ja')))/nrow(data)*100, digits = 1)`% wist dit niet of wilde dit niet zeggen. 

```{r coronainfectionother, echo=FALSE, fig.width=7, fig.height=2.5, fig.cap="Relatie geïnfecteerde personen tot de respondent"}
# Prepare dataset datachart for plot
chartdata <- data.frame(var=c("Ja, mijn partner", 
                         "Ja, een of meerdere familieleden", 
                         "Ja, een of meerdere vrienden", 
                         "Ja, een of meerdere collega\'s of studiegenoten", 
                         "Ja, een of meerdere kennissen", 
                         "Ja, iemand anders"),
                value=c(round((nrow(filter(data, (CoronaInfectionOther_1 == 'Ja')))/nrow(data))*100, digits = 1),
                      round((nrow(filter(data, (CoronaInfectionOther_2 == 'Ja')))/nrow(data))*100, digits = 1),
                      round((nrow(filter(data, (CoronaInfectionOther_3 == 'Ja')))/nrow(data))*100, digits = 1), 
                      round((nrow(filter(data, (CoronaInfectionOther_4 == 'Ja')))/nrow(data))*100, digits = 1),
                      round((nrow(filter(data, (CoronaInfectionOther_5 == 'Ja')))/nrow(data))*100, digits = 1),
                      round((nrow(filter(data, (CoronaInfectionOther_6 == 'Ja')))/nrow(data))*100, digits = 1))
                )
# Create the plot
plot = ggplot(data=chartdata, aes(x=var, y=value)) +
  geom_bar(stat="identity", fill = "#bdd7e7", color = "#6baed6") +
  geom_text(aes(x=var, y=value, ymax=value, label=value, 
                hjust=ifelse(sign(value)>0, 1, 0)), 
            position = position_dodge(width=1)) +
  coord_flip() +
  ylab("Percentage deelnemers (meerdere antwoorden mogelijk)") +
  xlab("") +
  theme(plot.margin = margin(0, 0.1, 0, 0)) +
  theme_bw()
plot

```

#### Corona risicoperceptie en ernst
Uit gedragswetenschappelijke literatuur is bekend dat gepercipieerde ernst en vatbaarheid voor een ziekte een rol kan spelen in de acceptatie van gezondheidsadviezen om de ontwikkeling van deze ziekte te voorkomen. Ongeveer de helft van de steekproef acht zichzelf vatbaar voor het coronavirus: `r round((nrow(filter(data, (HBM_PSus_self1 == 'Helemaal mee eens'| HBM_PSus_self1 == 'Mee eens'| HBM_PSus_self1 == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`% gaf aan het eens te zijn met de stelling dat men risico loopt op een besmetting in de komende twee maanden (zie figuur \@ref(fig:riskperception)). Daarnaast was een vergelijkbaar percentage (`r round((nrow(filter(data, (HBM_PSus_other2 == 'Helemaal mee eens'| HBM_PSus_other2 == 'Mee eens'| HBM_PSus_other2 == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`%) het in meer of mindere mate eens met de stelling dat de kans groot is om een ander te besmetten indien men zelf besmet raakt.

Voor het meten van de gepercipieerde ernst is gevraagd hoe erg respondenten het zouden vinden om zelg besmet te raken of om andere te besmetten. Een groot deel van de respondenten vind het erg om zelf besmet te raken (`r round((nrow(filter(data, (HBM_PSev_self1 == 'Helemaal mee eens'| HBM_PSev_self1 == 'Mee eens'| HBM_PSev_self1 == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`%). Daarnaast vindt men het erg om anderen te besmetten (`r round((nrow(filter(data, (HBM_PSev_other2 == 'Helemaal mee eens'| HBM_PSev_other2 == 'Mee eens'| HBM_PSev_other2 == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`%). 

```{r riskperception, echo=FALSE, fig.width=7, fig.height=2.2, fig.cap="Waargenomen ernst en vatbaarheid - hele populatie", tab.cap="Waargenomen ernst en vatbaarheid - hele populatie"}

# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("HBM_PSus_self1", 
                        "HBM_PSus_other2", 
                        "HBM_PSev_self1", 
                        "HBM_PSev_other2")
graph_questionlabels = c("Ik loop in de komende twee maanden risico op een besmetting met het coronavirus", 
                         "Als ik besmet raak is de kans  groot dat ik anderen zal besmetten", 
                         "Ik vind het erg om besmet te raken", 
                         "Ik vind het erg als ik andere mensen besmet"); 

# These questions have 7 answer categories: Helemaal mee eens - Helemaal mee oneens. The following color palette should be used:
color_palette = my_palette7
# Order of the question categories: first = most green, last = most red # Check if the answer categories match with the codebook (e.g, sometimes also 'weet ik niet is one of the answeroptions')
graph_answercategories = c("Helemaal mee eens", "Mee eens", "Een beetje mee eens", "Neutraal", "Een beetje oneens", "Oneens", "Helemaal mee oneens"); 

# Create a dataframe for the plot
#First only keep the variables you wish to keep. Note: nomem_enc is the participant id
data_graph_wideformat = select(data, nomem_encr, all_of(graph_variablenames))

#Convert it to long format
data_graph_longformat = melt(data_graph_wideformat, id.vars = c('nomem_encr'), measure.vars = graph_variablenames)

# Set the correct ordering of the questions (by default the first variable is placed on the bottom)
data_graph_longformat$variable <- factor(data_graph_longformat$variable,levels = rev(graph_variablenames))

# Also invert the order of the question labels (as default is that the first element of the vector is placed on the bottom)
graph_questionlabels = rev(graph_questionlabels)

# Set the correct ordering of the answer categories (by default on alphabetic order)
data_graph_longformat$value <- factor(data_graph_longformat$value,levels = graph_answercategories)

# Create the plot
baseplot <- ggplot(data=data_graph_longformat, aes(fill=value, x=variable)) + theme_bw() + geom_bar(aes(y = (..count..)/sum(..count..)*length(graph_variablenames))) + scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1)) + coord_flip() + labs(x = "", y = "", fill = "") + scale_fill_manual(values=color_palette, drop=FALSE, labels=stringr::str_wrap(graph_answercategories, width = 10)) + scale_x_discrete(labels=stringr::str_wrap(graph_questionlabels, width = 30)) + theme(plot.margin = margin(0, 0, 0, 0), legend.text=element_text(size=8))

ggdraw(baseplot)

# To check: also create the plot with variable labels
#ggplot(data=data_graph_longformat, aes(fill=value, x=variable)) + theme_bw() + geom_bar(aes(y = (..count..)/sum(..count..)*length(graph_variablenames))) + scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1)) + coord_flip() + labs(x = "", y = "", fill = "") + scale_fill_manual(values=color_palette, drop=FALSE, labels=stringr::str_wrap(graph_answercategories, width = 10)) + theme(plot.margin = margin(0, 0, 0, 0), legend.text=element_text(size=8))


# Create the table. Step 1: new data frame containing counts
data_table = data.frame(matrix(0, ncol = 0, nrow = length(levels(data[[graph_variablenames[1]]]))))

# We need one extra (empty) column label for the row with the possible values
table_questionlabels = list()
table_questionlabels["table_answercategories"] <- ""

# We also need the 'unreversed' question labels ;)
graph_questionlabels_unrev <- rev(graph_questionlabels)

# Inefficient loop, but it does a lot for us: add the counts as columns to the dataframe,
# and add the correct labels for column headings
for(idx in 1:length(graph_variablenames)) {
  
  if (idx == 1) {
    data_table["table_answercategories"] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[1]
  }
  
  # Add to new dataframe
  data_table[graph_variablenames[idx]] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[2]
  
  # Add correct mapping to column headings
  table_questionlabels[graph_variablenames[idx]] <- graph_questionlabels_unrev[idx]
}




# Build the basic table
ft <- flextable(
  head(data_table, n = nrow(data_table))
)

# Header labels
ft <- set_header_labels(ft, values = table_questionlabels)

# Set up the footer of totals
totals = c("Totaal")

# Percentages and totals
for(colname in colnames(data_table)) {
  if(colname != "table_answercategories") {
    # Add percentage to cell
    ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (", sprintf("%.1f", eval(parse(text=colname))/sum(eval(parse(text=colname)))*100), "%)"))
    
    # Add total to footer
    tablecolumn = paste("data_table$", colname)
    totals <- c(totals, paste(sum(eval(parse(text=tablecolumn))), " (100%)"))
  }
}

# Actually add the footer with totals
ft <- add_footer_row(ft, values = totals, colwidths = rep(1, length(totals)))

# Change layout of table, and footer specifically
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "right", part = "footer")
ft <- padding(ft, padding = 5, part = "footer")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.

# Note: 7 inch is the page width in Word
# We now divide this into 1.5 inch for the first column (the values),
# and divide the other columns equally among the remaining 5.5 inch.
# If you only have one or few columns, you might want to reduce the total width below:
table_width <- 7

# Set width
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 1.5)
ft_out <- width(ft_out, j = -1, width = (table_width-1.5)/(length(colnames(data_table))-1))

ft_out
```

#### Naleven algemene gedragsregels
In kaart is gebracht in hoeverre de respondenten zich in de afgelopen twee maanden aan een aantal van de algemene gedragsregels hebben gehouden (zie figuur \@ref(fig:behavioradhgenmeasures)). `r round((nrow(filter(data, (Behavior_AdherenceGeneralMeasures_handwashing == 'Altijd'| Behavior_AdherenceGeneralMeasures_handwashing == 'Meestal'| Behavior_AdherenceGeneralMeasures_handwashing == 'Vaak'))) /nrow(data))*100, digits = 1)`% gaf aan, regelmatig, vaak of altijd handen te wassen. Ongeveer de helft van de respondenten (`r round((nrow(filter(data, (Behavior_AdherenceGeneralMeasures_distance == 'Nooit'| Behavior_AdherenceGeneralMeasures_distance == 'Zelden'| Behavior_AdherenceGeneralMeasures_distance == 'Soms'))) /nrow(data))*100, digits = 1)`%) gaf aan nooit, zelden of soms op minder dan 1,5 afstand van mensen buiten het huishouden te zijn geweest. Tot slot gaf `r round((nrow(filter(data, (Behavior_AdherenceGeneralMeasures_avoidbusyplaces == 'Nooit'| Behavior_AdherenceGeneralMeasures_avoidbusyplaces == 'Zelden'| Behavior_AdherenceGeneralMeasures_avoidbusyplaces == 'Soms'))) /nrow(data))*100, digits = 1)`% aan nooit, zelden of soms op een plek te zijn geweest waar anderhalve meter afstand houden eigenlijk niet mogelijk was. 

```{r behavioradhgenmeasures, echo=FALSE, fig.width=7, fig.height=2, fig.cap="Naleving algemene gedragsregels", tab.cap="Naleving algemene gedragsregels. In de afgelopen twee maanden, hoe vaak... "}

# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("Behavior_AdherenceGeneralMeasures_handwashing", 
                        "Behavior_AdherenceGeneralMeasures_distance", 
                        "Behavior_AdherenceGeneralMeasures_avoidbusyplaces")
graph_questionlabels = c("... hebt u uw handen gewassen?", 
                         "... bent u minder dan op 1,5m afstand geweest van mensen buiten uw huishouden?", 
                         "... bent u op een plek geweest waar het eigenlijk te druk was om 1,5m afstand te houden?"); 
plot_title = "In de afgelopen twee maanden, hoe vaak..."

# These questions have 7 answer categories: Helemaal mee eens - Helemaal mee oneens. The following color palette should be used:
color_palette = my_palette7blue
# Order of the question categories: first = most green, last = most red # Check if the answer categories match with the codebook (e.g, sometimes also 'weet ik niet is one of the answeroptions')
graph_answercategories = c("Altijd", "Meestal", "Vaak", "Regelmatig", "Soms", "Zelden", "Nooit"); 

# Create a dataframe for the plot
#First only keep the variables you wish to keep. Note: nomem_enc is the participant id
data_graph_wideformat = select(data, nomem_encr, all_of(graph_variablenames))

#Convert it to long format
data_graph_longformat = melt(data_graph_wideformat, id.vars = c('nomem_encr'), measure.vars = graph_variablenames)

# Set the correct ordering of the questions (by default the first variable is placed on the bottom)
data_graph_longformat$variable <- factor(data_graph_longformat$variable,levels = rev(graph_variablenames))

# Also invert the order of the question labels (as default is that the first element of the vector is placed on the bottom)
graph_questionlabels = rev(graph_questionlabels)

# Set the correct ordering of the answer categories (by default on alphabetic order)
data_graph_longformat$value <- factor(data_graph_longformat$value,levels = graph_answercategories)

# Create the plot
theplot <- ggplot(data=data_graph_longformat, aes(fill=value, x=variable)) + theme_bw() + geom_bar(aes(y = (..count..)/sum(..count..)*length(graph_variablenames))) + scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1)) + coord_flip() + labs(x = "", y = "", fill = "") + scale_fill_manual(values=color_palette, drop=FALSE, labels=stringr::str_wrap(graph_answercategories, width = 10)) + scale_x_discrete(labels=stringr::str_wrap(graph_questionlabels, width = 30)) + theme(plot.margin = margin(0, 0, 0, 0), legend.text=element_text(size=8)) + ggtitle(plot_title) + theme(plot.title = element_text(size=11))

aligned <- align_plots(baseplot, theplot, align="v")
ggdraw(aligned[[2]])

# Create the table. Step 1: new data frame containing counts
data_table = data.frame(matrix(0, ncol = 0, nrow = length(levels(data[[graph_variablenames[1]]]))))

# We need one extra (empty) column label for the row with the possible values
table_questionlabels = list()
table_questionlabels["table_answercategories"] <- ""

# We also need the 'unreversed' question labels ;)
graph_questionlabels_unrev <- rev(graph_questionlabels)

# Inefficient loop, but it does a lot for us: add the counts as columns to the dataframe,
# and add the correct labels for column headings
for(idx in 1:length(graph_variablenames)) {
  
  if (idx == 1) {
    data_table["table_answercategories"] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[1]
  }
  
  # Add to new dataframe
  data_table[graph_variablenames[idx]] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[2]
  
  # Add correct mapping to column headings
  table_questionlabels[graph_variablenames[idx]] <- graph_questionlabels_unrev[idx]
}




# Build the basic table
ft <- flextable(
  head(data_table, n = nrow(data_table))
)

# Header labels
ft <- set_header_labels(ft, values = table_questionlabels)

# Set up the footer of totals
totals = c("Totaal")

# Percentages and totals
for(colname in colnames(data_table)) {
  if(colname != "table_answercategories") {
    # Add percentage to cell
    ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (", sprintf("%.1f", eval(parse(text=colname))/sum(eval(parse(text=colname)))*100), "%)"))
    
    # Add total to footer
    tablecolumn = paste("data_table$", colname)
    totals <- c(totals, paste(sum(eval(parse(text=tablecolumn))), " (100%)"))
  }
}

# Actually add the footer with totals
ft <- add_footer_row(ft, values = totals, colwidths = rep(1, length(totals)))

# Change layout of table, and footer specifically
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "right", part = "footer")
ft <- padding(ft, padding = 5, part = "footer")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.

# Note: 7 inch is the page width in Word
# We now divide this into 1.5 inch for the first column (the values),
# and divide the other columns equally among the remaining 5.5 inch.
# If you only have one or few columns, you might want to reduce the total width below:
table_width <- 7

# Set width
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 1.5)
ft_out <- width(ft_out, j = -1, width = (table_width-1.5)/(length(colnames(data_table))-1))

ft_out
```

Van alle respondenten gaf `r round(nrow(filter(data, Corona_complaints == "Ja"))/nrow(data)*100, digits =1)`% aan klachten te hebben gehad die passen bij het coronavirus in de afgelopen twee maanden. Onderstaande grafiek (figuur \@ref(fig:coronacomplaintsquarantaine)) laat zien in hoeverre deze respondenten in quarantaine bleven: in totaal gaf `r round((nrow(filter(data, Corona_complaints == "Ja" & (Behavior_AdherenceGeneralMeasures_quarantaine == 'Nooit'| Behavior_AdherenceGeneralMeasures_quarantaine == 'Zelden'))) /nrow(filter(data, Corona_complaints == "Ja")))*100, digits = 1)`% nooit of zelden naar buiten te zijn geweest met klachten.

```{r coronacomplaintsquarantaine, echo=FALSE, fig.width=7, fig.height=2, fig.cap="Naleving algemene gedragsregels bij klachten"}


# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("Behavior_AdherenceGeneralMeasures_quarantaine")
graph_questionlabels = c("Bent u, toen u deze klachten had, naar buiten geweest?"); 

# These questions have 7 answer categories: Helemaal mee eens - Helemaal mee oneens. The following color palette should be used:
color_palette = my_palette7blue
# Order of the question categories: first = most green, last = most red # Check if the answer categories match with the codebook (e.g, sometimes also 'weet ik niet is one of the answeroptions')
graph_answercategories = c("Nooit", "Zelden", "Soms", "Regelmatig", "Vaak", "Meestal", "Altijd"); 

# Create a dataframe for the plot
# Select only the current users
data_selected = data[ which(data$Corona_complaints=='Ja'
), ]
#First only keep the variables you wish to keep. Note: nomem_enc is the participant id. 
data_graph_wideformat = select(data_selected, nomem_encr, all_of(graph_variablenames))

#Convert it to long format
data_graph_longformat = melt(data_graph_wideformat, id.vars = c('nomem_encr'), measure.vars = graph_variablenames)

# Set the correct ordering of the questions (by default the first variable is placed on the bottom)
# It is not needed to reverse the order of the questionlabels. 
data_graph_longformat$variable <- factor(data_graph_longformat$variable,levels = rev(graph_variablenames))

# Also invert the order of the question labels (as default is that the first element of the vector is placed on the bottom)
graph_questionlabels = rev(graph_questionlabels)

# Set the correct ordering of the answer categories (by default on alphabetic order)
data_graph_longformat$value <- factor(data_graph_longformat$value,levels = graph_answercategories)

# Create the plot
theplot <- ggplot(data=data_graph_longformat, aes(fill=value, x=variable)) + theme_bw() + geom_bar(aes(y = (..count..)/sum(..count..)*length(graph_variablenames))) + scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1)) + coord_flip() + labs(x = "", y = "", fill = "") + scale_fill_manual(values=color_palette, drop=FALSE, labels=stringr::str_wrap(graph_answercategories, width = 10)) + scale_x_discrete(labels=stringr::str_wrap(graph_questionlabels, width = 30)) + theme(plot.margin = margin(0, 0, 0, 0), legend.text=element_text(size=8))

aligned <- align_plots(baseplot, theplot, align="v")
ggdraw(aligned[[2]])

# Create the table. Step 1: new data frame containing counts
data_table = data.frame(matrix(0, ncol = 0, nrow = length(levels(data[[graph_variablenames[1]]]))))

# We need one extra (empty) column label for the row with the possible values
table_questionlabels = list()
table_questionlabels["table_answercategories"] <- ""

# We also need the 'unreversed' question labels ;)
graph_questionlabels_unrev <- rev(graph_questionlabels)

# Inefficient loop, but it does a lot for us: add the counts as columns to the dataframe,
# and add the correct labels for column headings
for(idx in 1:length(graph_variablenames)) {
  
  if (idx == 1) {
    data_table["table_answercategories"] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[1]
  }
  
  # Add to new dataframe
  data_table[graph_variablenames[idx]] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[2]
  
  # Add correct mapping to column headings
  table_questionlabels[graph_variablenames[idx]] <- graph_questionlabels_unrev[idx]
}




# Build the basic table
ft <- flextable(
  head(data_table, n = nrow(data_table))
)

# Header labels
ft <- set_header_labels(ft, values = table_questionlabels)

# Set up the footer of totals
totals = c("Totaal")

# Percentages and totals
for(colname in colnames(data_table)) {
  if(colname != "table_answercategories") {
    # Add percentage to cell
    ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (", sprintf("%.1f", eval(parse(text=colname))/sum(eval(parse(text=colname)))*100), "%)"))
    
    # Add total to footer
    tablecolumn = paste("data_table$", colname)
    totals <- c(totals, paste(sum(eval(parse(text=tablecolumn))), " (100%)"))
  }
}

# Actually add the footer with totals
ft <- add_footer_row(ft, values = totals, colwidths = rep(1, length(totals)))

# Change layout of table, and footer specifically
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "right", part = "footer")
ft <- padding(ft, padding = 5, part = "footer")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.

# Note: 7 inch is the page width in Word
# We now divide this into 1.5 inch for the first column (the values),
# and divide the other columns equally among the remaining 5.5 inch.
# If you only have one or few columns, you might want to reduce the total width below:
table_width <- 7

# Set width
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 1.5)
ft_out <- width(ft_out, j = -1, width = (table_width-1.5)/(length(colnames(data_table))-1))

ft_out
```

#### Intentie tot naleving algemene gedragsregels
Er is gevraagd naar in welke mate men van plan is om zich de komende twee maanden te houden aan een aantal van de algemene gedragsregels. Het percentage respondenten dat aangeeft de intentie te hebben om zich aan de voorgestelde gedragsregels te houden ligt hoog (handen regelmatig wassen: `r round((nrow(filter(data, (Intention_AdherenceGeneralMeasures_handwashing == 'Helemaal mee eens'| Intention_AdherenceGeneralMeasures_handwashing == 'Mee eens'| Intention_AdherenceGeneralMeasures_handwashing == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`%; afstand houden: `r round((nrow(filter(data, (Intention_AdherenceGeneralMeasures_distance == 'Helemaal mee eens'| Intention_AdherenceGeneralMeasures_distance == 'Mee eens'| Intention_AdherenceGeneralMeasures_distance == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`%; drukke plekken vermijden: `r round((nrow(filter(data, (Intention_AdherenceGeneralMeasures_avoidbusyplaces == 'Helemaal mee eens'| Intention_AdherenceGeneralMeasures_avoidbusyplaces == 'Mee eens'| Intention_AdherenceGeneralMeasures_avoidbusyplaces == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`%; thuisblijven bij klachten: `r round((nrow(filter(data, (Intention_AdherenceGeneralMeasures_quarantaine == 'Helemaal mee eens'| Intention_AdherenceGeneralMeasures_quarantaine == 'Mee eens'| Intention_AdherenceGeneralMeasures_quarantaine == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`%). Onderstaande figuur geeft de intenties weer (figuur \@ref(fig:intentionadhgenmeasures)).

```{r intentionadhgenmeasures, echo=FALSE, fig.width=7, fig.height=2, fig.cap="Intentie tot naleving algemene gedragsregels", tab.cap="Intentie tot naleving algemene gedragsregels"}

# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("Intention_AdherenceGeneralMeasures_handwashing", 
                        "Intention_AdherenceGeneralMeasures_distance", 
                        "Intention_AdherenceGeneralMeasures_avoidbusyplaces", 
                        "Intention_AdherenceGeneralMeasures_quarantaine")
graph_questionlabels = c("... mijn handen regelmatig te wassen", 
                         "... 1,5 meter afstand te houden van mensen buiten mijn huishouden", 
                         "... drukke plekken te vermijden", 
                         "... thuis te blijven als ik last heb van klachten die passen bij het coronavirus"); 
plot_title = "Ik ben van plan om de komende 2 maanden..."
# These questions have 7 answer categories: Helemaal mee eens - Helemaal mee oneens. The following color palette should be used:
color_palette = my_palette7
# Order of the question categories: first = most green, last = most red # Check if the answer categories match with the codebook (e.g, sometimes also 'weet ik niet is one of the answeroptions')
graph_answercategories = c("Helemaal mee eens", "Mee eens", "Een beetje mee eens", "Neutraal", "Een beetje oneens", "Oneens", "Helemaal mee oneens"); 

# Create a dataframe for the plot
#First only keep the variables you wish to keep. Note: nomem_enc is the participant id
data_graph_wideformat = select(data, nomem_encr, all_of(graph_variablenames))

#Convert it to long format
data_graph_longformat = melt(data_graph_wideformat, id.vars = c('nomem_encr'), measure.vars = graph_variablenames)

# Set the correct ordering of the questions (by default the first variable is placed on the bottom)
data_graph_longformat$variable <- factor(data_graph_longformat$variable,levels = rev(graph_variablenames))

# Also invert the order of the question labels (as default is that the first element of the vector is placed on the bottom)
graph_questionlabels = rev(graph_questionlabels)

# Set the correct ordering of the answer categories (by default on alphabetic order)
data_graph_longformat$value <- factor(data_graph_longformat$value,levels = graph_answercategories)

# Create the plot
theplot <- ggplot(data=data_graph_longformat, aes(fill=value, x=variable)) + theme_bw() + geom_bar(aes(y = (..count..)/sum(..count..)*length(graph_variablenames))) + scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1)) + coord_flip() + labs(x = "", y = "", fill = "") + scale_fill_manual(values=color_palette, drop=FALSE, labels=stringr::str_wrap(graph_answercategories, width = 10)) + scale_x_discrete(labels=stringr::str_wrap(graph_questionlabels, width = 30)) + theme(plot.margin = margin(0, 0, 0, 0), legend.text=element_text(size=8)) + ggtitle(plot_title) + theme(plot.title = element_text(size=11))

aligned <- align_plots(baseplot, theplot, align="v")
ggdraw(aligned[[2]])

# Create the table. Step 1: new data frame containing counts
data_table = data.frame(matrix(0, ncol = 0, nrow = length(levels(data[[graph_variablenames[1]]]))))

# We need one extra (empty) column label for the row with the possible values
table_questionlabels = list()
table_questionlabels["table_answercategories"] <- ""

# We also need the 'unreversed' question labels ;)
graph_questionlabels_unrev <- rev(graph_questionlabels)

# Inefficient loop, but it does a lot for us: add the counts as columns to the dataframe,
# and add the correct labels for column headings
for(idx in 1:length(graph_variablenames)) {
  
  if (idx == 1) {
    data_table["table_answercategories"] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[1]
  }
  
  # Add to new dataframe
  data_table[graph_variablenames[idx]] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[2]
  
  # Add correct mapping to column headings
  table_questionlabels[graph_variablenames[idx]] <- graph_questionlabels_unrev[idx]
}




# Build the basic table
ft <- flextable(
  head(data_table, n = nrow(data_table))
)

# Header labels
ft <- set_header_labels(ft, values = table_questionlabels)

# Set up the footer of totals
totals = c("Totaal")

# Percentages and totals
for(colname in colnames(data_table)) {
  if(colname != "table_answercategories") {
    # Add percentage to cell
    ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (", sprintf("%.1f", eval(parse(text=colname))/sum(eval(parse(text=colname)))*100), "%)"))
    
    # Add total to footer
    tablecolumn = paste("data_table$", colname)
    totals <- c(totals, paste(sum(eval(parse(text=tablecolumn))), " (100%)"))
  }
}

# Actually add the footer with totals
ft <- add_footer_row(ft, values = totals, colwidths = rep(1, length(totals)))

# Change layout of table, and footer specifically
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "right", part = "footer")
ft <- padding(ft, padding = 5, part = "footer")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.

# Note: 7 inch is the page width in Word
# We now divide this into 1.5 inch for the first column (the values),
# and divide the other columns equally among the remaining 5.5 inch.
# If you only have one or few columns, you might want to reduce the total width below:
table_width <- 7

# Set width
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 1.5)
ft_out <- width(ft_out, j = -1, width = (table_width-1.5)/(length(colnames(data_table))-1))

ft_out
```

### Algemene opvattingen over het coronavirus

#### Complottheorieën
Om in kaart te brengen in hoeverre complottheorieën een rol spelen is gevraagd of men dacht dat onderstaande stellingen waar of onwaar zijn (zie figuur \@ref(fig:complot)). Van de respondenten beoordeelt `r round((nrow(filter(data, (Beliefs_Conspiracy1 == 'Zeker waar'| Beliefs_Conspiracy1 == 'Misschien waar'))) /nrow(data))*100, digits = 1)`% de stelling 'Het coronavirus is een biologisch wapen dat in een laboratorium is gemaakt' met misschien waar of zeker waar. Een kleiner percentage beoordeelt de stelling 'De uitbraak van het coronavirus heeft te maken met het 5G netwerk' als misschien waar of zeker waar (`r round((nrow(filter(data, (Beliefs_Conspiracy2 == 'Zeker waar'| Beliefs_Conspiracy2 == 'Misschien waar'))) /nrow(data))*100, digits = 1)`%).

```{r complot, echo=FALSE, fig.width=7, fig.height=2, fig.cap="Geloof in complottheorien", tab.cap="Geloof in complottheorien"}
# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("Beliefs_Conspiracy1", 
                        "Beliefs_Conspiracy2")
graph_questionlabels = c("Het coronavirus is een biologisch wapen dat in een laboratorium is gemaakt", 
                         "De uitbraak van het coronavirus heeft te maken met (de aanleg van) het 5G netwerk"); 

# These questions have 5 answer categories: Zeker niet waar - Zeker waar en Weet ik niet. The following color palette should be used:
color_palette = my_palette5blue
# Order of the question categories: first = most green, last = most red # Check if the answer categories match with the codebook (e.g, sometimes also 'weet ik niet is one of the answeroptions')
graph_answercategories = c("Weet ik niet", "Zeker waar", "Misschien waar", "Misschien niet waar", "Zeker niet waar"); 

### Nothing needs to be changed in the script below. 
# Create a dataframe for the plot
#First only keep the variables you wish to keep. Note: nomem_enc is the participant id
data_graph_wideformat = select(data, nomem_encr, all_of(graph_variablenames))

#Convert it to long format
data_graph_longformat = melt(data_graph_wideformat, id.vars = c('nomem_encr'), measure.vars = graph_variablenames)

# Set the correct ordering of the questions (by default the first variable is placed on the bottom)
# It is not needed to reverse the order of the questionlabels. 
data_graph_longformat$variable <- factor(data_graph_longformat$variable,levels = rev(graph_variablenames))

# Also invert the order of the question labels (as default is that the first element of the vector is placed on the bottom)
graph_questionlabels = rev(graph_questionlabels)

# Set the correct ordering of the answer categories (by default on alphabetic order)
data_graph_longformat$value <- factor(data_graph_longformat$value,levels = graph_answercategories)

# Create the plot
theplot <- ggplot(data=data_graph_longformat, aes(fill=value, x=variable)) + theme_bw() + geom_bar(aes(y = (..count..)/sum(..count..)*length(graph_variablenames))) + scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1)) + coord_flip() + labs(x = "", y = "", fill = "") + scale_fill_manual(values=color_palette, drop=FALSE, labels=stringr::str_wrap(graph_answercategories, width = 10)) + scale_x_discrete(labels=stringr::str_wrap(graph_questionlabels, width = 30)) + theme(plot.margin = margin(0, 0, 0, 0), legend.text=element_text(size=8))

aligned <- align_plots(baseplot, theplot, align="v")
ggdraw(aligned[[2]])

# To check: also create the plot with variable labels
#ggplot(data=data_graph_longformat, aes(fill=value, x=variable)) + theme_bw() + geom_bar(aes(y = (..count..)/sum(..count..)*length(graph_variablenames))) + scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1)) + coord_flip() + labs(x = "", y = "", fill = "") + scale_fill_manual(values=color_palette, drop=FALSE, labels=stringr::str_wrap(graph_answercategories, width = 10)) + theme(plot.margin = margin(0, 0, 0, 0), legend.text=element_text(size=8))

#table(data$Beliefs_Conspiracy1)

# Create the table. Step 1: new data frame containing counts
data_table = data.frame(matrix(0, ncol = 0, nrow = length(levels(data[[graph_variablenames[1]]]))))

# We need one extra (empty) column label for the row with the possible values
table_questionlabels = list()
table_questionlabels["table_answercategories"] <- ""

# We also need the 'unreversed' question labels ;)
graph_questionlabels_unrev <- rev(graph_questionlabels)

# Inefficient loop, but it does a lot for us: add the counts as columns to the dataframe,
# and add the correct labels for column headings
for(idx in 1:length(graph_variablenames)) {
  
  if (idx == 1) {
    data_table["table_answercategories"] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[1]
  }
  
  # Add to new dataframe
  data_table[graph_variablenames[idx]] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[2]
  
  # Add correct mapping to column headings
  table_questionlabels[graph_variablenames[idx]] <- graph_questionlabels_unrev[idx]
}




# Build the basic table
ft <- flextable(
  head(data_table, n = nrow(data_table))
)

# Header labels
ft <- set_header_labels(ft, values = table_questionlabels)

# Set up the footer of totals
totals = c("Totaal")

# Percentages and totals
for(colname in colnames(data_table)) {
  if(colname != "table_answercategories") {
    # Add percentage to cell
    ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (", sprintf("%.1f", eval(parse(text=colname))/sum(eval(parse(text=colname)))*100), "%)"))
    
    # Add total to footer
    tablecolumn = paste("data_table$", colname)
    totals <- c(totals, paste(sum(eval(parse(text=tablecolumn))), " (100%)"))
  }
}

# Actually add the footer with totals
ft <- add_footer_row(ft, values = totals, colwidths = rep(1, length(totals)))

# Change layout of table, and footer specifically
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "right", part = "footer")
ft <- padding(ft, padding = 5, part = "footer")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.

# Note: 7 inch is the page width in Word
# We now divide this into 1.5 inch for the first column (the values),
# and divide the other columns equally among the remaining 5.5 inch.
# If you only have one or few columns, you might want to reduce the total width below:
table_width <- 7

# Set width
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 1.5)
ft_out <- width(ft_out, j = -1, width = (table_width-1.5)/(length(colnames(data_table))-1))

ft_out
```

#### Vertrouwen in aanpak van de overheid
Respondenten zijn verdeeld wat betreft vertrouwen in de overheid met betrekking tot de aanpak van de coronacrisis (zie figuur \@ref(fig:trustgovernment)). Ongeveeer de helft is het eens met de stelling stelling 'Ik heb vertrouwen in de manier waarop de Nederlandse ovreheid probeert het coronavirus onder controle te houden' (`r round((nrow(filter(data, (Beliefs_TrustGovernment == 'Helemaal mee eens'| Beliefs_TrustGovernment == 'Mee eens'| Beliefs_TrustGovernment == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`%).

```{r trustgovernment, echo=FALSE, fig.width=7, fig.height=2, fig.cap="Geloof dat de CoronaMelder de Nederlandse economie helpt", tab.cap="Vertrouwen in de Nederlandse overheid"}

# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("Beliefs_TrustGovernment")
graph_questionlabels = c("Ik heb vertrouwen in de manier waarop de Nederlandse overheid probeert het coronavirus onder controle te houden"); 

# These questions have 7 answer categories: Helemaal mee eens - Helemaal mee oneens. The following color palette should be used:
color_palette = my_palette7
# Order of the question categories: first = most green, last = most red # Check if the answer categories match with the codebook (e.g, sometimes also 'weet ik niet is one of the answeroptions')
graph_answercategories = c("Helemaal mee eens", "Mee eens", "Een beetje mee eens", "Neutraal", "Een beetje oneens", "Oneens", "Helemaal mee oneens"); 

# Create a dataframe for the plot
#First only keep the variables you wish to keep. Note: nomem_enc is the participant id
data_graph_wideformat = select(data, nomem_encr, all_of(graph_variablenames))

#Convert it to long format
data_graph_longformat = melt(data_graph_wideformat, id.vars = c('nomem_encr'), measure.vars = graph_variablenames)

# Set the correct ordering of the questions (by default the first variable is placed on the bottom)
data_graph_longformat$variable <- factor(data_graph_longformat$variable,levels = rev(graph_variablenames))

# Also invert the order of the question labels (as default is that the first element of the vector is placed on the bottom)
graph_questionlabels = rev(graph_questionlabels)

# Set the correct ordering of the answer categories (by default on alphabetic order)
data_graph_longformat$value <- factor(data_graph_longformat$value,levels = graph_answercategories)

# Create the plot
theplot <- ggplot(data=data_graph_longformat, aes(fill=value, x=variable)) + theme_bw() + geom_bar(aes(y = (..count..)/sum(..count..)*length(graph_variablenames))) + scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1)) + coord_flip() + labs(x = "", y = "", fill = "") + scale_fill_manual(values=color_palette, drop=FALSE, labels=stringr::str_wrap(graph_answercategories, width = 10)) + scale_x_discrete(labels=stringr::str_wrap(graph_questionlabels, width = 30)) + theme(plot.margin = margin(0, 0, 0, 0), legend.text=element_text(size=8)) 

aligned <- align_plots(baseplot, theplot, align="v")
ggdraw(aligned[[2]])


# Create the table. Step 1: new data frame containing counts
data_table = data.frame(matrix(0, ncol = 0, nrow = length(levels(data[[graph_variablenames[1]]]))))

# We need one extra (empty) column label for the row with the possible values
table_questionlabels = list()
table_questionlabels["table_answercategories"] <- ""

# We also need the 'unreversed' question labels ;)
graph_questionlabels_unrev <- rev(graph_questionlabels)

# Inefficient loop, but it does a lot for us: add the counts as columns to the dataframe,
# and add the correct labels for column headings
for(idx in 1:length(graph_variablenames)) {
  
  if (idx == 1) {
    data_table["table_answercategories"] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[1]
  }
  
  # Add to new dataframe
  data_table[graph_variablenames[idx]] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[2]
  
  # Add correct mapping to column headings
  table_questionlabels[graph_variablenames[idx]] <- graph_questionlabels_unrev[idx]
}




# Build the basic table
ft <- flextable(
  head(data_table, n = nrow(data_table))
)

# Header labels
ft <- set_header_labels(ft, values = table_questionlabels)

# Set up the footer of totals
totals = c("Totaal")

# Percentages and totals
for(colname in colnames(data_table)) {
  if(colname != "table_answercategories") {
    # Add percentage to cell
    ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (", sprintf("%.1f", eval(parse(text=colname))/sum(eval(parse(text=colname)))*100), "%)"))
    
    # Add total to footer
    tablecolumn = paste("data_table$", colname)
    totals <- c(totals, paste(sum(eval(parse(text=tablecolumn))), " (100%)"))
  }
}

# Actually add the footer with totals
ft <- add_footer_row(ft, values = totals, colwidths = rep(1, length(totals)))

# Change layout of table, and footer specifically
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "right", part = "footer")
ft <- padding(ft, padding = 5, part = "footer")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.

# Note: 7 inch is the page width in Word
# We now divide this into 1.5 inch for the first column (the values),
# and divide the other columns equally among the remaining 5.5 inch.
# If you only have one or few columns, you might want to reduce the total width below:
table_width <- 7

# Set width
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 1.5)
ft_out <- width(ft_out, j = -1, width = (table_width-1.5)/(length(colnames(data_table))-1))

ft_out
```

## Bekendheid met CoronaMelder
In de vragenlijst werd gevraagd hoe bekend men (voor het openen van de vragenlijst) was met de CoronaMelder app. In totaal gaf `r round(((nrow(filter(data, Awareness == 'Heel erg bekend')) + nrow(filter(data, Awareness == 'Bekend')) + nrow(filter(data, Awareness == 'Redelijk bekend'))+ nrow(filter(data, Awareness == 'Een beetje bekend')))/nrow(data)*100), digits = 1)`% aan in meer of mindere mate bekend te zijn met de CoronaMelder (zie figuur \@ref(fig:awarenessCoronaMelder)). Ruim 1 op de 10 (`r round(nrow(filter(data, Awareness == 'Niet bekend'))/nrow(data)*100, digits = 1)`%) gaf aan niet bekend te zijn met de CoronaMelder.   

```{r awarenessCoronaMelder, echo=FALSE, fig.width=7, fig.height=2, fig.cap="Bekendheid met de CoronaMelder", tab.cap="Bekendheid met de CoronaMelder"}

# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("Awareness")
graph_questionlabels = c("Hoe bekend was u met de CoronaMelder?"); 

# These questions have 5 answer categories: Helemaal mee eens - Helemaal mee oneens. The following color palette should be used:
color_palette = my_palette5blue
# Order of the question categories: first = most green, last = most red # Check if the answer categories match with the codebook (e.g, sometimes also 'weet ik niet is one of the answeroptions')
graph_answercategories = c("Niet bekend", "Een beetje bekend", "Redelijk bekend", "Bekend", "Heel erg bekend"); 

# Create a dataframe for the plot
#First only keep the variables you wish to keep. Note: nomem_enc is the participant id
data_graph_wideformat = select(data, nomem_encr, all_of(graph_variablenames))

#Convert it to long format
data_graph_longformat = melt(data_graph_wideformat, id.vars = c('nomem_encr'), measure.vars = graph_variablenames)

# Set the correct ordering of the questions (by default the first variable is placed on the bottom)
data_graph_longformat$variable <- factor(data_graph_longformat$variable,levels = rev(graph_variablenames))

# Also invert the order of the question labels (as default is that the first element of the vector is placed on the bottom)
graph_questionlabels = rev(graph_questionlabels)

# Set the correct ordering of the answer categories (by default on alphabetic order)
data_graph_longformat$value <- factor(data_graph_longformat$value,levels = graph_answercategories)

# Create the plot
theplot <- ggplot(data=data_graph_longformat, aes(fill=value, x=variable)) + theme_bw() + geom_bar(aes(y = (..count..)/sum(..count..)*length(graph_variablenames))) + scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1)) + coord_flip() + labs(x = "", y = "", fill = "") + scale_fill_manual(values=color_palette, drop=FALSE, labels=stringr::str_wrap(graph_answercategories, width = 10)) + scale_x_discrete(labels=stringr::str_wrap(graph_questionlabels, width = 30)) + theme(plot.margin = margin(0, 0, 0, 0), legend.text=element_text(size=8)) 

aligned <- align_plots(baseplot, theplot, align="v")
ggdraw(aligned[[2]])


# Create the table. Step 1: new data frame containing counts
data_table = data.frame(matrix(0, ncol = 0, nrow = length(levels(data[[graph_variablenames[1]]]))))

# We need one extra (empty) column label for the row with the possible values
table_questionlabels = list()
table_questionlabels["table_answercategories"] <- ""

# We also need the 'unreversed' question labels ;)
graph_questionlabels_unrev <- rev(graph_questionlabels)

# Inefficient loop, but it does a lot for us: add the counts as columns to the dataframe,
# and add the correct labels for column headings
for(idx in 1:length(graph_variablenames)) {
  if (idx == 1) {
    data_table["table_answercategories"] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[1]
  }
  
  # Add to new dataframe
  data_table[graph_variablenames[idx]] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[2]
  
  # Add correct mapping to column headings
  table_questionlabels[graph_variablenames[idx]] <- graph_questionlabels_unrev[idx]
}

# Build the basic table
ft <- flextable(
  head(data_table, n = nrow(data_table))
)

# Header labels
ft <- set_header_labels(ft, values = table_questionlabels)

# Set up the footer of totals
totals = c("Totaal")

# Percentages and totals
for(colname in colnames(data_table)) {
  if(colname != "table_answercategories") {
    # Add percentage to cell
    ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (", sprintf("%.1f", eval(parse(text=colname))/sum(eval(parse(text=colname)))*100), "%)"))
    
    # Add total to footer
    tablecolumn = paste("data_table$", colname)
    totals <- c(totals, paste(sum(eval(parse(text=tablecolumn))), " (100%)"))
  }
}

# Actually add the footer with totals
ft <- add_footer_row(ft, values = totals, colwidths = rep(1, length(totals)))

# Change layout of table, and footer specifically
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "right", part = "footer")
ft <- padding(ft, padding = 5, part = "footer")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.

# Note: 7 inch is the page width in Word
# We now divide this into 1.5 inch for the first column (the values),
# and divide the other columns equally among the remaining 5.5 inch.
# If you only have one or few columns, you might want to reduce the total width below:
table_width <- 7

# Set width
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 1.5)
ft_out <- width(ft_out, j = -1, width = (table_width-1.5)/(length(colnames(data_table))-1))

ft_out
```

```{r awarenesslftd, echo=FALSE, fig.width=7, fig.height=2, fig.cap="Bekendheid met de CoronaMelder per leeftijdscategorie"}
# Awareness op leeftijdscategorie, met ook 'reversed' labels en waarden in de bar chart:
#ggplot(data=data, aes(fill=Awareness, x=lftdcat)) + geom_bar(position=position_fill(reverse = TRUE), aes(y = (..count..)/sum(..count..))) + scale_y_continuous(labels=percent) + scale_x_discrete(labels=c("15-24", "25-34", "35-44", "45-54", "55-64", "65+")) + coord_flip() + labs(x = "Leeftijdscategorie", y = "", fill = "") + ggtitle("Bekendheid Coronamelder per leeftijdscategorie") + scale_fill_manual(values=my_palette5) + guides(fill = guide_legend(reverse = TRUE))
```

```{r awarenessgender, echo=FALSE, fig.width=7, fig.height=2, fig.cap="Bekendheid met de CoronaMelder per geslacht"}
# Awareness op gender
#ggplot(data=data, aes(fill=Awareness, x=geslacht)) + geom_bar(position=position_fill(reverse = TRUE), aes(y = (..count..)/sum(..count..))) + scale_y_continuous(labels=percent) + scale_x_discrete(labels=c("man", "vrouw")) + coord_flip() + labs(x = " ", y = "", fill = "") + ggtitle("Bekendheid Coronamelder per geslacht") + scale_fill_manual(values=my_palette5) + guides(fill = guide_legend(reverse = TRUE))
```

## Gebruik CoronaMelder
Van alle respondenten gaf `r round(nrow(filter(data, Behavior_UTAUT == 'Ik gebruik de CoronaMelder app op dit moment'))/nrow(data)*100, digits = 1)`% (n = `r nrow(filter(data, Behavior_UTAUT == 'Ik gebruik de CoronaMelder app op dit moment'))`) aan dat hij/zij de CoronaMelder op dit moment gebruikt en `r round(nrow(filter(data, Behavior_UTAUT == 'Ik heb de CoronaMelder app nooit gebruikt'))/nrow(data)*100, digits = 1)`% (n = `r nrow(filter(data, Behavior_UTAUT == 'Ik heb de CoronaMelder app nooit gebruikt'))`) geeft aan de CoronaMelder niet te gebruiken. Slechts `r round(nrow(filter(data, Behavior_UTAUT == 'Ik heb de CoronaMelder app in het verleden wel gebruikt maar op dit moment niet meer'))/nrow(data)*100, digits = 1)`% (n = `r nrow(filter(data, Behavior_UTAUT == 'Ik heb de CoronaMelder app in het verleden wel gebruikt maar op dit moment niet meer'))`)gaf aan de CoronaMelder in het verleden gebruikt te hebben maar op dit moment niet meer. 

## Intentie tot (blijvend) gebruik CoronaMelder
Er werd gevraagd of de respondenten de intentie hadden om de CoronaMelder de komende twee maanden te (blijven) gebruiken. Van de respondenten die de CoronaMelder app nooit hebben gebruikt, gaf `r round((nrow(filter(data, (BI1a_UTAUT == 'Helemaal mee eens'| BI1a_UTAUT == 'Mee eens'| BI1a_UTAUT == 'Een beetje mee eens') & Behavior_UTAUT == 'Ik heb de CoronaMelder app nooit gebruikt')) /nrow(filter(data, Behavior_UTAUT == 'Ik heb de CoronaMelder app nooit gebruikt')))*100, digits = 1)`% aan van plan te zijn om de CoronaMelder te gebruiken in de komende twee maanden (zie figuur \@ref(fig:intentiontousenonusers)). Ongeveer een kwart geeft aan hier neutraal in te staan (`r round((nrow(filter(data, (BI1a_UTAUT == 'Neutraal') & Behavior_UTAUT == 'Ik heb de CoronaMelder app nooit gebruikt')) /nrow(filter(data, Behavior_UTAUT == 'Ik heb de CoronaMelder app nooit gebruikt')))*100, digits = 1)`%). Bijna 6 op de 10 respondenten (`r round((nrow(filter(data, (BI1a_UTAUT == 'Helemaal mee oneens'| BI1a_UTAUT == 'Oneens'| BI1a_UTAUT == 'Een beetje oneens') & Behavior_UTAUT == 'Ik heb de CoronaMelder app nooit gebruikt')) /nrow(filter(data, Behavior_UTAUT == 'Ik heb de CoronaMelder app nooit gebruikt')))*100, digits = 1)`%) geeft aan niet van plan te zijn de CoronaMelder te gaan gebruiken.  

```{r intentiontousenonusers, echo=FALSE, fig.width=7, fig.height=2, fig.cap="Intentie tot gebruik bij respondenten die de CoronaMelder op dit moment niet gebruiken", tab.cap="Intentie tot gebruik bij respondenten die de CoronaMelder op dit moment niet gebruiken"}

# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("BI1a_UTAUT", 
                        "BI2a_UTAUT")
graph_questionlabels = c("Ik ben van plan de CoronaMelder in de komende 2 maanden te gebruiken", 
                         "Het is waarschijnlijk dat ik de CoronaMelder in de komende 2 maanden zal gebruiken"); 

# These questions have 7 answer categories: Helemaal mee eens - Helemaal mee oneens. The following color palette should be used:
color_palette = my_palette7
# Order of the question categories: first = most green, last = most red # Check if the answer categories match with the codebook (e.g, sometimes also 'weet ik niet is one of the answeroptions')
graph_answercategories = c("Helemaal mee eens", "Mee eens", "Een beetje mee eens", "Neutraal", "Een beetje oneens", "Oneens", "Helemaal mee oneens"); 

# Create a dataframe for the plot
# Select only the current users
data_selected = data[ which(data$Behavior_UTAUT=='Ik heb de CoronaMelder app nooit gebruikt'
), ]
#First only keep the variables you wish to keep. Note: nomem_enc is the participant id. 
data_graph_wideformat = select(data_selected, nomem_encr, all_of(graph_variablenames))

#Convert it to long format
data_graph_longformat = melt(data_graph_wideformat, id.vars = c('nomem_encr'), measure.vars = graph_variablenames)

# Set the correct ordering of the questions (by default the first variable is placed on the bottom)
# It is not needed to reverse the order of the questionlabels. 
data_graph_longformat$variable <- factor(data_graph_longformat$variable,levels = rev(graph_variablenames))

# Also invert the order of the question labels (as default is that the first element of the vector is placed on the bottom)
graph_questionlabels = rev(graph_questionlabels)

# Set the correct ordering of the answer categories (by default on alphabetic order)
data_graph_longformat$value <- factor(data_graph_longformat$value,levels = graph_answercategories)

# Create the plot
theplot <- ggplot(data=data_graph_longformat, aes(fill=value, x=variable)) + theme_bw() + geom_bar(aes(y = (..count..)/sum(..count..)*length(graph_variablenames))) + scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1)) + coord_flip() + labs(x = "", y = "", fill = "") + scale_fill_manual(values=color_palette, drop=FALSE, labels=stringr::str_wrap(graph_answercategories, width = 10)) + scale_x_discrete(labels=stringr::str_wrap(graph_questionlabels, width = 30)) + theme(plot.margin = margin(0, 0, 0, 0), legend.text=element_text(size=8))

aligned <- align_plots(baseplot, theplot, align="v")
ggdraw(aligned[[2]])


# Create the table. Step 1: new data frame containing counts
data_table = data.frame(matrix(0, ncol = 0, nrow = length(levels(data[[graph_variablenames[1]]]))))

# We need one extra (empty) column label for the row with the possible values
table_questionlabels = list()
table_questionlabels["table_answercategories"] <- ""

# We also need the 'unreversed' question labels ;)
graph_questionlabels_unrev <- rev(graph_questionlabels)

# Inefficient loop, but it does a lot for us: add the counts as columns to the dataframe,
# and add the correct labels for column headings
for(idx in 1:length(graph_variablenames)) {
  
  if (idx == 1) {
    data_table["table_answercategories"] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[1]
  }
  
  # Add to new dataframe
  data_table[graph_variablenames[idx]] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[2]
  
  # Add correct mapping to column headings
  table_questionlabels[graph_variablenames[idx]] <- graph_questionlabels_unrev[idx]
}




# Build the basic table
ft <- flextable(
  head(data_table, n = nrow(data_table))
)

# Header labels
ft <- set_header_labels(ft, values = table_questionlabels)

# Set up the footer of totals
totals = c("Totaal")

# Percentages and totals
for(colname in colnames(data_table)) {
  if(colname != "table_answercategories") {
    # Add percentage to cell
    ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (", sprintf("%.1f", eval(parse(text=colname))/sum(eval(parse(text=colname)))*100), "%)"))
    
    # Add total to footer
    tablecolumn = paste("data_table$", colname)
    totals <- c(totals, paste(sum(eval(parse(text=tablecolumn))), " (100%)"))
  }
}

# Actually add the footer with totals
ft <- add_footer_row(ft, values = totals, colwidths = rep(1, length(totals)))

# Change layout of table, and footer specifically
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "right", part = "footer")
ft <- padding(ft, padding = 5, part = "footer")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.

# Note: 7 inch is the page width in Word
# We now divide this into 1.5 inch for the first column (the values),
# and divide the other columns equally among the remaining 5.5 inch.
# If you only have one or few columns, you might want to reduce the total width below:
table_width <- 7

# Set width
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 1.5)
ft_out <- width(ft_out, j = -1, width = (table_width-1.5)/(length(colnames(data_table))-1))

ft_out
```

Van de respondenten die de CoronaMelder op dit moment al gebruiken, gaf een overgrote meerderheid (`r round((nrow(filter(data, (BI1b_UTAUT == 'Helemaal mee eens'| BI1b_UTAUT == 'Mee eens'| BI1b_UTAUT == 'Een beetje mee eens') & Behavior_UTAUT == 'Ik gebruik de CoronaMelder app op dit moment')) /nrow(filter(data, Behavior_UTAUT == 'Ik gebruik de CoronaMelder app op dit moment')))*100, digits = 1)`%) aan van plan te zijn de CoronaMelder te blijven gebruiken in de komende 2 maanden (zie figuur \@ref(fig:intentiontousecurrentusers)). Een kleine hoeveelheid respondenten gaf aan hier neutraal in te staan (`r round((nrow(filter(data, (BI1b_UTAUT == 'Neutraal') & Behavior_UTAUT == 'Ik gebruik de CoronaMelder app op dit moment')) /nrow(filter(data, Behavior_UTAUT == 'Ik gebruik de CoronaMelder app op dit moment')))*100, digits = 1)`%) Slechts `r round((nrow(filter(data, (BI1b_UTAUT == 'Helemaal mee oneens'| BI1b_UTAUT == 'Oneens'| BI1b_UTAUT == 'Een beetje oneens') & Behavior_UTAUT == 'Ik gebruik de CoronaMelder app op dit moment')) /nrow(filter(data, Behavior_UTAUT == 'Ik gebruik de CoronaMelder app op dit moment')))*100, digits = 1)`% gaf aan niet van plan te zijn de CoronaMelder te blijven gebruiken. 

```{r intentiontousecurrentusers, eval=TRUE, echo=FALSE, fig.width=7, fig.height=2, fig.cap="Intentie tot gebruik bij respondenten die de CoronaMelder op dit moment al gebruiken", tab.cap="Intentie tot gebruik bij respondenten die de CoronaMelder op dit moment al gebruiken"}

# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("BI1b_UTAUT", 
                        "BI2b_UTAUT")
graph_questionlabels = c("Ik ben van plan de CoronaMelder in de komende 2 maanden te blijven gebruiken", 
                         "Het is waarschijnlijk dat ik de CoronaMelder de komende 2 maanden zal blijven gebruiken"); 

# These questions have 7 answer categories: Helemaal mee eens - Helemaal mee oneens. The following color palette should be used:
color_palette = my_palette7
# Order of the question categories: first = most green, last = most red # Check if the answer categories match with the codebook (e.g, sometimes also 'weet ik niet is one of the answeroptions')
graph_answercategories = c("Helemaal mee eens", "Mee eens", "Een beetje mee eens", "Neutraal", "Een beetje oneens", "Oneens", "Helemaal mee oneens"); 

# Create a dataframe for the plot
# Select only the current users
data_selected = data[ which(data$Behavior_UTAUT=='Ik gebruik de CoronaMelder app op dit moment'
), ]
#First only keep the variables you wish to keep. Note: nomem_enc is the participant id. 
data_graph_wideformat = select(data_selected, nomem_encr, all_of(graph_variablenames))

#Convert it to long format
data_graph_longformat = melt(data_graph_wideformat, id.vars = c('nomem_encr'), measure.vars = graph_variablenames)

# Set the correct ordering of the questions (by default the first variable is placed on the bottom)
# It is not needed to reverse the order of the questionlabels. 
data_graph_longformat$variable <- factor(data_graph_longformat$variable,levels = rev(graph_variablenames))

# Also invert the order of the question labels (as default is that the first element of the vector is placed on the bottom)
graph_questionlabels = rev(graph_questionlabels)

# Set the correct ordering of the answer categories (by default on alphabetic order)
data_graph_longformat$value <- factor(data_graph_longformat$value,levels = graph_answercategories)

# Create the plot
theplot <- ggplot(data=data_graph_longformat, aes(fill=value, x=variable)) + theme_bw() + geom_bar(aes(y = (..count..)/sum(..count..)*length(graph_variablenames))) + scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1)) + coord_flip() + labs(x = "", y = "", fill = "") + scale_fill_manual(values=color_palette, drop=FALSE, labels=stringr::str_wrap(graph_answercategories, width = 10)) + scale_x_discrete(labels=stringr::str_wrap(graph_questionlabels, width = 30)) + theme(plot.margin = margin(0, 0, 0, 0), legend.text=element_text(size=8))

aligned <- align_plots(baseplot, theplot, align="v")
ggdraw(aligned[[2]])

# Create the table. Step 1: new data frame containing counts
data_table = data.frame(matrix(0, ncol = 0, nrow = length(levels(data[[graph_variablenames[1]]]))))

# We need one extra (empty) column label for the row with the possible values
table_questionlabels = list()
table_questionlabels["table_answercategories"] <- ""

# We also need the 'unreversed' question labels ;)
graph_questionlabels_unrev <- rev(graph_questionlabels)

# Inefficient loop, but it does a lot for us: add the counts as columns to the dataframe,
# and add the correct labels for column headings
for(idx in 1:length(graph_variablenames)) {
  
  if (idx == 1) {
    data_table["table_answercategories"] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[1]
  }
  
  # Add to new dataframe
  data_table[graph_variablenames[idx]] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[2]
  
  # Add correct mapping to column headings
  table_questionlabels[graph_variablenames[idx]] <- graph_questionlabels_unrev[idx]
}




# Build the basic table
ft <- flextable(
  head(data_table, n = nrow(data_table))
)

# Header labels
ft <- set_header_labels(ft, values = table_questionlabels)

# Set up the footer of totals
totals = c("Totaal")

# Percentages and totals
for(colname in colnames(data_table)) {
  if(colname != "table_answercategories") {
    # Add percentage to cell
    ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (", sprintf("%.1f", eval(parse(text=colname))/sum(eval(parse(text=colname)))*100), "%)"))
    
    # Add total to footer
    tablecolumn = paste("data_table$", colname)
    totals <- c(totals, paste(sum(eval(parse(text=tablecolumn))), " (100%)"))
  }
}

# Actually add the footer with totals
ft <- add_footer_row(ft, values = totals, colwidths = rep(1, length(totals)))

# Change layout of table, and footer specifically
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "right", part = "footer")
ft <- padding(ft, padding = 5, part = "footer")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.

# Note: 7 inch is the page width in Word
# We now divide this into 1.5 inch for the first column (the values),
# and divide the other columns equally among the remaining 5.5 inch.
# If you only have one or few columns, you might want to reduce the total width below:
table_width <- 7

# Set width
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 1.5)
ft_out <- width(ft_out, j = -1, width = (table_width-1.5)/(length(colnames(data_table))-1))

ft_out
```


## Vergelijking gebruikers en niet gebruikers
### Demografische gegevens naar gebruikersstatus {#demouserstatus}
Om inzicht te krijgen in welke factoren (demografisch, persoonlijk, sociaal, omgevingsfactoren) samenhangen met het gebruiken van de CoronaMelder worden respondenten die momenteel de CoronaMelder gebruiken vergeleken met de respondenten die de CoronaMelder nooit hebben gebruikt. 

Om dit te onderzoeken wordt voor elke demografische variabele een chi kwadraat toets uitgevoerd. In het geval dat deze toets aangeeft dat de demografische variabele en de gebruikersstatus afhankelijk zijn - oftewel dat een of meerdere van de subgroepen afwijken van het gemiddelde percentage gebruikers - worden er posthoc paarsgewijze chi kwadraattests met FDR-correctie uitgevoerd om te bepalen welke groepen significant van elkaar verschillen in percentage gebruikers. In de onderstaande tabel kunnen de resultaten gevonden worden. In de appendix kunnen alle paarsgewijze vergelijkingen gevonden worden voor variabelen die samen hingen met de gebruikersstatus. 

Demografische variabelen die niet samenhingen met gebruik waren geslacht, de stedelijkheid van de woonplaats, de dagelijkse bezigheid (bv. loondienst, pensioen), de woonvorm van het huishouden (bv. alleen wonend of met kinderen) en de frequentie waarmee iemand op minder dan 1.5 meter van ouderen en mensen met een kwetsbare gezondheid komt vanwege werk of (privé) zorgtaken. 

Voor de volgende demografische kenmerken was er wel een afhankelijkheid: Het percentages gebruikers was niet gelijk verdeeld over alle leeftijdscategorieën. Het percentage gebruikers was significant lager bij de 15 - 24 jarigen vergeleken met de 55 - 64 jarigen. 

Nog een demografische variabele die samenhing met gebruik was opleidingsniveau. Bij de hoger opgeleiden (hbo en wo) was het percentage gebruikers het hoogst. Bij mensen die aleen basisonderwijs of vmbo hebben gevolgd was dit percentage het laagst. Ook netto maandkomen hing samen met gebruik mensen die maandelijks meer dan 3501 eur netto verdienen gebruiken de CoronaMelder het vaakst terwijl dit percentage bij mensen met een lager inkomen een stuk lager is. 

Ook burgerlijke staat hing samen met gebruik van de CoronaMelder. Zo wordt de CoronaMelder minder vaak gebruikt door weduwen en weduwnaars en het vaakst door gehuwden. 


```{r demobyuserstatus, echo=FALSE, results="asis", tab.cap = "Demografische kenmerken naar gebruikersstatus"} 
tab.noby <- tableby(user_status ~ geslacht + lftdcat + sted_simplified + belbezig_simplified  + oplmet_simplified + burgstat_simplified + nettocat_simplified + woonvorm + Riskgroup_contact, cat.stats = "countrowpct", data=data_currentvsneveruser) # cat.stats = "countrowpct") for row percentages in stead of column percentages
summary(tab.noby, title="(\\#tab:mytableby2) Demografische kenmerken naar gebruikersstatus")
```

### Gezondheidsmotivatie en risicoperceptie naar gebruikersstatus
Chi kwadraat toetsen zijn uitgevoerd om te bepalen of het totaal aandeel respondenten dat het eens  (een beetje, eens, helemaal mee eens) is met de stellingen die betrekking hebben op gezondheidsmotivatie en risicoperceptie verschilt tussen de huidige gebruikers en degenen die de CoronaMelder nooit gebruikt hebben. Daarnaast is gekeken of de subgroep die de CoronaMelder nooit gebruikt heeft en aangaf neutraal te zijn met betrekking tot toekomstig gebruik verschilt van de huidig gebruikers. 
```{r chiHBMsuscself1usernonuser, echo=FALSE}
# First calculate a proportion for the variable. 
data$HBM_PSus_self1_agree[(data$HBM_PSus_self1 == 'Helemaal mee eens'| data$HBM_PSus_self1 == 'Mee eens'| data$HBM_PSus_self1 == 'Een beetje mee eens')] <- "Totaal eens"
data$HBM_PSus_self1_agree[(data$HBM_PSus_self1 == 'Neutraal'| data$HBM_PSus_self1 == 'Een beetje oneens'| data$HBM_PSus_self1 == 'Oneens'| data$HBM_PSus_self1 == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens" 
# Select the data: Only compare the current users and never users
data_selected = data[data$nomem_encr %in% data_currentvsneveruser$nomem_encr, ]
data_selected$user_status = droplevels(data_selected$user_status)

# Convert into a table that can be used for the chi square test
chisq.table = table(data_selected$HBM_PSus_self1_agree, data_selected$user_status)
chisqtest = chisq.test(chisq.table) 
```
De chi kwadraat toets (X²(`r chisqtest$parameter`) = `r round(chisqtest$statistic, digits = 2)`, p `r ifelse(chisqtest$p.value < 0.001, "<0.001", paste("=", round(chisqtest$p.value, digits = 3)))`) liet zien dat er `r if(chisqtest$p.value > 0.05){"g"}`een significant verschil was in het percentage gebruikers (`r round((nrow(filter(data_selected, (user_status == 'Gebruiker'& HBM_PSus_self1_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status == 'Gebruiker'))))*100, digits = 1)`%) dat aangaf het eens te zijn met de stelling dat men in komende twee maanden een risico op een besmetting met het coronavirus liep vergeleken met degenen die de app nooit hebben gebruikt (`r round((nrow(filter(data_selected, (user_status == 'Niet gebruiker' & HBM_PSus_self1_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status == 'Niet gebruiker'))))*100, digits = 1)`%).  

```{r chiHBMsuscself1usernonuserneutral, echo=FALSE}
# First calculate a proportion for the variable. 
data$HBM_PSus_self1_agree[(data$HBM_PSus_self1 == 'Helemaal mee eens'| data$HBM_PSus_self1 == 'Mee eens'| data$HBM_PSus_self1 == 'Een beetje mee eens')] <- "Totaal eens"
data$HBM_PSus_self1_agree[(data$HBM_PSus_self1 == 'Neutraal'| data$HBM_PSus_self1 == 'Een beetje oneens'| data$HBM_PSus_self1 == 'Oneens'| data$HBM_PSus_self1 == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens" 
# Select the data: Only compare the current users and never users
data_selected = data[data$nomem_encr %in% data_currentvsneveruserneutral$nomem_encr, ]
data_selected$user_status_intention = droplevels(data_selected$user_status_intention)

# Convert into a table that can be used for the chi square test
chisq.table = table(data_selected$HBM_PSus_self1_agree, data_selected$user_status_intention)
chisqtest = chisq.test(chisq.table) 
```
De chi kwadraat toets (X²(`r chisqtest$parameter`) = `r round(chisqtest$statistic, digits = 2)`, p `r ifelse(chisqtest$p.value < 0.001, "<0.001", paste("=", round(chisqtest$p.value, digits = 3)))`) liet zien dat er `r if(chisqtest$p.value > 0.05){"g"}`een significant verschil was in het percentage gebruikers (`r round((nrow(filter(data_selected, (user_status_intention == 'Gebruiker'& HBM_PSus_self1_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status_intention == 'Gebruiker'))))*100, digits = 1)`%) dat aangaf het eens te zijn met de stelling dat men in komende twee maanden een risico op een besmetting met het coronavirus liep vergeleken met degenen die de app nooit hebben gebruikt en daarnaast aangaven neutraal te zijn in hun intentie om de CoronaMelder te gaan gebruiken (`r round((nrow(filter(data_selected, (user_status_intention == 'Nooit gebruikt en neutraal' & HBM_PSus_self1_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status_intention == 'Nooit gebruikt en neutraal'))))*100, digits = 1)`%). 

```{r chiPHBMPsusother2utautusernonuser, echo=FALSE}
# First calculate a proportion for the variable. 
data$HBM_PSus_other2_agree[(data$HBM_PSus_other2 == 'Helemaal mee eens'| data$HBM_PSus_other2 == 'Mee eens'| data$HBM_PSus_other2 == 'Een beetje mee eens')] <- "Totaal eens"
data$HBM_PSus_other2_agree[(data$HBM_PSus_other2 == 'Neutraal'| data$HBM_PSus_other2 == 'Een beetje oneens'| data$HBM_PSus_other2 == 'Oneens'| data$HBM_PSus_other2 == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens" 
# Select the data: Only compare the current users and never users
data_selected = data[data$nomem_encr %in% data_currentvsneveruser$nomem_encr, ]
data_selected$user_status = droplevels(data_selected$user_status)

# Convert into a table that can be used for the chi square test
chisq.table = table(data_selected$HBM_PSus_other2_agree, data_selected$user_status)
chisqtest = chisq.test(chisq.table) 
```
De chi kwadraat toets (X²(`r chisqtest$parameter`) = `r round(chisqtest$statistic, digits = 2)`, p `r ifelse(chisqtest$p.value < 0.001, "<0.001", paste("=", round(chisqtest$p.value, digits = 3)))`) liet zien dat er `r if(chisqtest$p.value > 0.05){"g"}`een significant verschil was in het percentage gebruikers (`r round((nrow(filter(data_selected, (user_status == 'Gebruiker'& HBM_PSus_other2_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status == 'Gebruiker'))))*100, digits = 1)`%) dat aangaf het eens te zijn met de stelling dat de kans groot zou zijn dat diegene anderen zal besmetten indien hij/zij zelf besmet zou zijn, vergeleken met degenen die de app nooit hebben gebruikt (`r round((nrow(filter(data_selected, (user_status == 'Niet gebruiker' & HBM_PSus_other2_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status == 'Niet gebruiker'))))*100, digits = 1)`%).  

```{r chiPHBMPsusother2usernonuserneutral, echo=FALSE}
# First calculate a proportion for the variable. 
data$HBM_PSus_other2_agree[(data$HBM_PSus_other2 == 'Helemaal mee eens'| data$HBM_PSus_other2 == 'Mee eens'| data$HBM_PSus_other2 == 'Een beetje mee eens')] <- "Totaal eens"
data$HBM_PSus_other2_agree[(data$HBM_PSus_other2 == 'Neutraal'| data$HBM_PSus_other2 == 'Een beetje oneens'| data$HBM_PSus_other2 == 'Oneens'| data$HBM_PSus_other2 == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens" 
# Select the data: Only compare the current users and never users
data_selected = data[data$nomem_encr %in% data_currentvsneveruserneutral$nomem_encr, ]
data_selected$user_status_intention = droplevels(data_selected$user_status_intention)

# Convert into a table that can be used for the chi square test
chisq.table = table(data_selected$HBM_PSus_other2_agree, data_selected$user_status_intention)
chisqtest = chisq.test(chisq.table) 
```

De chi kwadraat toets (X²(`r chisqtest$parameter`) = `r round(chisqtest$statistic, digits = 2)`, p `r ifelse(chisqtest$p.value < 0.001, "<0.001", paste("=", round(chisqtest$p.value, digits = 3)))`) liet zien dat er `r if(chisqtest$p.value > 0.05){"g"}`een significant verschil was in het percentage gebruikers (`r round((nrow(filter(data_selected, (user_status_intention == 'Gebruiker'& HBM_PSus_other2_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status_intention == 'Gebruiker'))))*100, digits = 1)`%) dat aangaf het eens te zijn met de stelling dat de kans groot zou zijn dat diegene anderen zal besmetten indien hij/zij zelf besmet zou zijn, vergeleken met degenen die de app nooit hebben gebruikt en daarnaast aangaven neutraal te zijn in hun intentie om de CoronaMelder te gaan gebruiken (`r round((nrow(filter(data_selected, (user_status_intention == 'Nooit gebruikt en neutraal' & HBM_PSus_other2_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status_intention == 'Nooit gebruikt en neutraal'))))*100, digits = 1)`%). 

```{r chiHBMsevcself1usernonuser, echo=FALSE}
# First calculate a proportion for the variable.
data$HBM_PSev_self1_agree[(data$HBM_PSev_self1 == 'Helemaal mee eens'| data$HBM_PSev_self1 == 'Mee eens'| data$HBM_PSev_self1 == 'Een beetje mee eens')] <- "Totaal eens"
data$HBM_PSus_PSev_agree[(data$HBM_PSev_self1 == 'Neutraal'| data$HBM_PSev_self1 == 'Een beetje oneens'| data$HBM_PSev_self1 == 'Oneens'| data$HBM_PSev_self1 == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens" 
# Select the data: Only compare the current users and never users
data_selected = data[data$nomem_encr %in% data_currentvsneveruser$nomem_encr, ]
data_selected$user_status = droplevels(data_selected$user_status)

# Convert into a table that can be used for the chi square test
chisq.table = table(data_selected$HBM_PSev_self1_agree, data_selected$user_status)
chisqtest = chisq.test(chisq.table) 
```
De chi kwadraat toets (X²(`r chisqtest$parameter`) = `r round(chisqtest$statistic, digits = 2)`, p `r ifelse(chisqtest$p.value < 0.001, "<0.001", paste("=", round(chisqtest$p.value, digits = 3)))`) liet zien dat er `r if(chisqtest$p.value > 0.05){"g"}`een significant verschil was in het percentage gebruikers (`r round((nrow(filter(data_selected, (user_status == 'Gebruiker'& HBM_PSev_self1_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status == 'Gebruiker'))))*100, digits = 1)`%) dat aangaf het eens te zijn met de stelling dat hij/zij het erg zou vinden om besmet te raken met he coronavirus vergeleken met degenen die de app nooit hebben gebruikt (`r round((nrow(filter(data_selected, (user_status == 'Niet gebruiker' & HBM_PSev_self1_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status == 'Niet gebruiker'))))*100, digits = 1)`%).  

```{r chiHBMsevsself1usernonuserneutral, echo=FALSE}
# First calculate a proportion for the variable. 
data$HBM_PSev_self1_agree[(data$HBM_PSev_self1 == 'Helemaal mee eens'| data$HBM_PSev_self1 == 'Mee eens'| data$HBM_PSev_self1 == 'Een beetje mee eens')] <- "Totaal eens"
data$HBM_PSev_self1_agree[(data$HBM_PSev_self1 == 'Neutraal'| data$HBM_PSev_self1 == 'Een beetje oneens'| data$HBM_PSev_self1 == 'Oneens'| data$HBM_PSev_self1 == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens" 
# Select the data: Only compare the current users and never users
data_selected = data[data$nomem_encr %in% data_currentvsneveruserneutral$nomem_encr, ]
data_selected$user_status_intention = droplevels(data_selected$user_status_intention)

# Convert into a table that can be used for the chi square test
chisq.table = table(data_selected$HBM_PSev_self1_agree, data_selected$user_status_intention)
chisqtest = chisq.test(chisq.table) 
```
De chi kwadraat toets (X²(`r chisqtest$parameter`) = `r round(chisqtest$statistic, digits = 2)`, p `r ifelse(chisqtest$p.value < 0.001, "<0.001", paste("=", round(chisqtest$p.value, digits = 3)))`) liet zien dat er `r if(chisqtest$p.value > 0.05){"g"}`een significant verschil was in het percentage gebruikers (`r round((nrow(filter(data_selected, (user_status_intention == 'Gebruiker'& HBM_PSev_self1_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status_intention == 'Gebruiker'))))*100, digits = 1)`%) dat aangaf het eens te zijn met de stelling dat hij/zij het erg zou vinden om besmet te raken met het coronavirus vergeleken met degenen die de app nooit hebben gebruikt en daarnaast aangaven neutraal te zijn in hun intentie om de CoronaMelder te gaan gebruiken (`r round((nrow(filter(data_selected, (user_status_intention == 'Nooit gebruikt en neutraal' & HBM_PSev_self1_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status_intention == 'Nooit gebruikt en neutraal'))))*100, digits = 1)`%). 

```{r chiPHBMPsevother2utautusernonuser, echo=FALSE}
# First calculate a proportion for the variable. 
data$HBM_PSev_other2_agree[(data$HBM_PSev_other2 == 'Helemaal mee eens'| data$HBM_PSev_other2 == 'Mee eens'| data$HBM_PSev_other2 == 'Een beetje mee eens')] <- "Totaal eens"
data$HBM_PSev_other2_agree[(data$HBM_PSev_other2 == 'Neutraal'| data$HBM_PSev_other2 == 'Een beetje oneens'| data$HBM_PSev_other2 == 'Oneens'| data$HBM_PSev_other2 == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens" 
# Select the data: Only compare the current users and never users
data_selected = data[data$nomem_encr %in% data_currentvsneveruser$nomem_encr, ]
data_selected$user_status = droplevels(data_selected$user_status)

# Convert into a table that can be used for the chi square test
chisq.table = table(data_selected$HBM_PSev_other2_agree, data_selected$user_status)
chisqtest = chisq.test(chisq.table) 
```
De chi kwadraat toets (X²(`r chisqtest$parameter`) = `r round(chisqtest$statistic, digits = 2)`, p `r ifelse(chisqtest$p.value < 0.001, "<0.001", paste("=", round(chisqtest$p.value, digits = 3)))`) liet zien dat er `r if(chisqtest$p.value > 0.05){"g"}`een significant verschil was in het percentage gebruikers (`r round((nrow(filter(data_selected, (user_status == 'Gebruiker'& HBM_PSev_other2_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status == 'Gebruiker'))))*100, digits = 1)`%) dat aangaf het eens te zijn met de stelling dat hij/zij het erg zou vinden om andere mensen te besmetten met het coronavirus vergeleken met degenen die de app nooit hebben gebruikt (`r round((nrow(filter(data_selected, (user_status == 'Niet gebruiker' & HBM_PSev_other2_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status == 'Niet gebruiker'))))*100, digits = 1)`%).  

```{r chiPHBMPsevother2usernonuserneutral, echo=FALSE}
# First calculate a proportion for the variable. 
data$HBM_PSev_other2_agree[(data$HBM_PSev_other2 == 'Helemaal mee eens'| data$HBM_PSev_other2 == 'Mee eens'| data$HBM_PSev_other2 == 'Een beetje mee eens')] <- "Totaal eens"
data$HBM_PSev_other2_agree[(data$HBM_PSev_other2 == 'Neutraal'| data$HBM_PSev_other2 == 'Een beetje oneens'| data$HBM_PSev_other2 == 'Oneens'| data$HBM_PSev_other2 == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens" 
# Select the data: Only compare the current users and never users
data_selected = data[data$nomem_encr %in% data_currentvsneveruserneutral$nomem_encr, ]
data_selected$user_status_intention = droplevels(data_selected$user_status_intention)

# Convert into a table that can be used for the chi square test
chisq.table = table(data_selected$HBM_PSev_other2_agree, data_selected$user_status_intention)
chisqtest = chisq.test(chisq.table) 
```

De chi kwadraat toets (X²(`r chisqtest$parameter`) = `r round(chisqtest$statistic, digits = 2)`, p `r ifelse(chisqtest$p.value < 0.001, "<0.001", paste("=", round(chisqtest$p.value, digits = 3)))`) liet zien dat er `r if(chisqtest$p.value > 0.05){"g"}`een significant verschil was in het percentage gebruikers (`r round((nrow(filter(data_selected, (user_status_intention == 'Gebruiker'& HBM_PSev_other2_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status_intention == 'Gebruiker'))))*100, digits = 1)`%) dat aangaf het eens te zijn met de stelling hij/zij het erg zou vinden om andere mensen te besmetten met het coronavirus vergeleken met degenen die de app nooit hebben gebruikt en daarnaast aangaven neutraal te zijn in hun intentie om de CoronaMelder te gaan gebruiken (`r round((nrow(filter(data_selected, (user_status_intention == 'Nooit gebruikt en neutraal' & HBM_PSev_other2_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status_intention == 'Nooit gebruikt en neutraal'))))*100, digits = 1)`%). 

```{r, echo=FALSE, tab.cap ="Ernst en vatbaarheid coronavirus naar gebruikersstatus. Aantal en totaal percentage eens (beetje mee eens, eens, helemaal mee eens)."}

# === EDIT THESE TO CUSTOMIZE TABLE ===

# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("HBM_PSus_self1", 
                        "HBM_PSus_other2", 
                        "HBM_PSev_self1", 
                        "HBM_PSev_other2")                     
graph_questionlabels = c("Ik loop in de komende twee maanden risico op een besmetting met het coronavirus", 
                         "Als ik besmet raak met het coronavirus is de kans groot dat ik anderen zal besmetten", 
                         "Ik vind het erg om besmet te raken met het coronavirus", 
                         "Ik vind het erg als ik andere mensen besmet met het coronavirus") 

# Which values do we want to include in the table cells?
include_vars = c("Helemaal mee eens", "Mee eens", "Een beetje mee eens")

# === NO MORE EDITS SHOULD BE NEEDED BELOW THIS POINT ===

# Split by user groups
data_grouptable = data.frame(matrix(ncol = length(colnames(user_totals))+1, nrow = length(graph_variablenames)))

colnames(data_grouptable) <- c("variable", usergroup_names)

# Set the values for each variable. Note: this still contains too much logic right now, the values that are counted 
# as correct (in this case "Helemaal mee eens", "Mee eens", and "Een beetje mee eens") are manually added
# and will not apply to all variables (sometimes it is "Waar", or a different likert-scale)
for(idx in 1:length(graph_variablenames)) {
  data_grouptable[idx,"variable"] = graph_questionlabels[idx]
  
  data_grouptable[idx,2] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status == "Gebruiker"))
  
  data_grouptable[idx,3] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status == "Niet gebruiker"))

  data_grouptable[idx,4] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status_intention == "Nooit gebruikt en niet van plan"))

  data_grouptable[idx,5] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status_intention == "Nooit gebruikt en neutraal"))

  data_grouptable[idx,6] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status_intention == "Nooit gebruikt en wel van plan"))
}

# Build the basic table
ft <- flextable(
  head(data_grouptable, n = nrow(data_grouptable))
)

# Header labels
tmp_labels = as.data.frame(t(c("", usergroup_labels)))
colnames(tmp_labels) <- c("variable", usergroup_names)
ft <- set_header_labels(ft, values = tmp_labels)

# Set up the footer of totals
totals = c("Totaal", user_totals)
totals[-1] <- paste(totals[-1], " (100.0%)")

# Percentages and totals
for(colname in colnames(data_grouptable)) {
  if(colname != "variable") {
    # Add percentage to cell
    if (user_totals[1,colname]==0) {
      ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (0.0%)"))
    }
    else {
      ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (", sprintf("%.1f", eval(parse(text=colname))/user_totals[1,colname]*100), "%)"))
    }
    
  }
}

# Actually add the footer with totals
ft <- add_footer_row(ft, values = totals, colwidths = rep(1, length(totals)))

# Change layout of table, and footer specifically
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "right", part = "footer")
ft <- padding(ft, padding = 5, part = "footer")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.

# Note: 7 inch is the page width in Word
# We now divide this into 1.5 inch for the first column (the values),
# and divide the other columns equally among the remaining 5.5 inch.
# If you only have one or few columns, you might want to reduce the total width below:
table_width <- 7

# Set width
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 1.5)
ft_out <- width(ft_out, j = -1, width = (table_width-1.5)/(length(colnames(data_grouptable))-1))

ft_out

```
In onderstaande tabellen is te zijn hoe deze percentages opgebouwd zijn voor deze vier vragen, voor huidig gebruikers en niet gebruikers. 

```{r, echo=FALSE, fig.width=7, fig.height=2, fig.cap="Waargenomen ernst en vatbaarheid - Gebruikers", tab.cap="Waargenomen ernst en vatbaarheid - Gebruikers"}

# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("HBM_PSus_self1", 
                        "HBM_PSus_other2", 
                        "HBM_PSev_self1", 
                        "HBM_PSev_other2")
graph_questionlabels = c("Ik loop in de komende twee maanden risico op een besmetting met het coronavirus", 
                         "Als ik besmet raak is de kans  groot dat ik anderen zal besmetten", 
                         "Ik vind het erg om besmet te raken", 
                         "Ik vind het erg als ik andere mensen besmet"); 

# These questions have 7 answer categories: Helemaal mee eens - Helemaal mee oneens. The following color palette should be used:
color_palette = my_palette7
# Order of the question categories: first = most green, last = most red # Check if the answer categories match with the codebook (e.g, sometimes also 'weet ik niet is one of the answeroptions')
graph_answercategories = c("Helemaal mee eens", "Mee eens", "Een beetje mee eens", "Neutraal", "Een beetje oneens", "Oneens", "Helemaal mee oneens"); 

# Create a dataframe for the plot
# Select only the current users
data_selected = data[ which(data$Behavior_UTAUT=='Ik gebruik de CoronaMelder app op dit moment'
), ]
#First only keep the variables you wish to keep. Note: nomem_enc is the participant id. 
data_graph_wideformat = select(data_selected, nomem_encr, all_of(graph_variablenames))

#Convert it to long format
data_graph_longformat = melt(data_graph_wideformat, id.vars = c('nomem_encr'), measure.vars = graph_variablenames)

# Set the correct ordering of the questions (by default the first variable is placed on the bottom)
# It is not needed to reverse the order of the questionlabels. 
data_graph_longformat$variable <- factor(data_graph_longformat$variable,levels = rev(graph_variablenames))

# Also invert the order of the question labels (as default is that the first element of the vector is placed on the bottom)
graph_questionlabels = rev(graph_questionlabels)

# Set the correct ordering of the answer categories (by default on alphabetic order)
data_graph_longformat$value <- factor(data_graph_longformat$value,levels = graph_answercategories)

# Create the plot
theplot <- ggplot(data=data_graph_longformat, aes(fill=value, x=variable)) + theme_bw() + geom_bar(aes(y = (..count..)/sum(..count..)*length(graph_variablenames))) + scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1)) + coord_flip() + labs(x = "", y = "", fill = "") + scale_fill_manual(values=color_palette, drop=FALSE, labels=stringr::str_wrap(graph_answercategories, width = 10)) + scale_x_discrete(labels=stringr::str_wrap(graph_questionlabels, width = 30)) + theme(plot.margin = margin(0, 0, 0, 0), legend.text=element_text(size=8))

aligned <- align_plots(baseplot, theplot, align="v")
ggdraw(aligned[[2]])


```

```{r perceivedsuscsev, echo=FALSE, fig.width=7, fig.height=2, fig.cap="Waargenomen ernst en vatbaarheid - Niet gebruikers", tab.cap="Waargenomen ernst en vatbaarheid - Niet gebruikers"}

# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("HBM_PSus_self1", 
                        "HBM_PSus_other2", 
                        "HBM_PSev_self1", 
                        "HBM_PSev_other2")
graph_questionlabels = c("Ik loop in de komende twee maanden risico op een besmetting met het coronavirus", 
                         "Als ik besmet raak is de kans  groot dat ik anderen zal besmetten", 
                         "Ik vind het erg om besmet te raken", 
                         "Ik vind het erg als ik andere mensen besmet"); 

# These questions have 7 answer categories: Helemaal mee eens - Helemaal mee oneens. The following color palette should be used:
color_palette = my_palette7
# Order of the question categories: first = most green, last = most red # Check if the answer categories match with the codebook (e.g, sometimes also 'weet ik niet is one of the answeroptions')
graph_answercategories = c("Helemaal mee eens", "Mee eens", "Een beetje mee eens", "Neutraal", "Een beetje oneens", "Oneens", "Helemaal mee oneens"); 

# Create a dataframe for the plot
# Select only the current users
data_selected = data[ which(data$Behavior_UTAUT=='Ik heb de CoronaMelder app nooit gebruikt'
), ]
#First only keep the variables you wish to keep. Note: nomem_enc is the participant id. 
data_graph_wideformat = select(data_selected, nomem_encr, all_of(graph_variablenames))

#Convert it to long format
data_graph_longformat = melt(data_graph_wideformat, id.vars = c('nomem_encr'), measure.vars = graph_variablenames)

# Set the correct ordering of the questions (by default the first variable is placed on the bottom)
# It is not needed to reverse the order of the questionlabels. 
data_graph_longformat$variable <- factor(data_graph_longformat$variable,levels = rev(graph_variablenames))

# Also invert the order of the question labels (as default is that the first element of the vector is placed on the bottom)
graph_questionlabels = rev(graph_questionlabels)

# Set the correct ordering of the answer categories (by default on alphabetic order)
data_graph_longformat$value <- factor(data_graph_longformat$value,levels = graph_answercategories)

# Create the plot
theplot <- ggplot(data=data_graph_longformat, aes(fill=value, x=variable)) + theme_bw() + geom_bar(aes(y = (..count..)/sum(..count..)*length(graph_variablenames))) + scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1)) + coord_flip() + labs(x = "", y = "", fill = "") + scale_fill_manual(values=color_palette, drop=FALSE, labels=stringr::str_wrap(graph_answercategories, width = 10)) + scale_x_discrete(labels=stringr::str_wrap(graph_questionlabels, width = 30)) + theme(plot.margin = margin(0, 0, 0, 0), legend.text=element_text(size=8))

aligned <- align_plots(baseplot, theplot, align="v")
ggdraw(aligned[[2]])


```

  
### Naleving en intentie tot naleving algemene gedragsregels naar gebruikersstatus
Relevant om te weten is of de mensen die de CoronaMelder momenteel gebruiken, mensen zijn die zich in het algemeen al beter aan de gedragsregels houden. 

Chi kwadraat toetsen zijn uitgevoerd om te bepalen of het totaal aandeel respondenten dat het eens  (een beetje, eens, helemaal mee eens) is met de stellingen verschilt tussen de huidige gebruikers en degenen die de CoronaMelder nooit gebruikt hebben.  

```{r chiintentionhandwashingusernonuser, echo=FALSE}
# First calculate a proportion for the variable. 
data$Intention_AdherenceGeneralMeasures_handwashing_agree[(data$Intention_AdherenceGeneralMeasures_handwashing == 'Helemaal mee eens'| data$Intention_AdherenceGeneralMeasures_handwashing == 'Mee eens'| data$Intention_AdherenceGeneralMeasures_handwashing == 'Een beetje mee eens')] <- "Totaal eens"
data$Intention_AdherenceGeneralMeasures_handwashing_agree[(data$Intention_AdherenceGeneralMeasures_handwashing == 'Neutraal'| data$Intention_AdherenceGeneralMeasures_handwashing == 'Een beetje oneens'| data$Intention_AdherenceGeneralMeasures_handwashing == 'Oneens'| data$Intention_AdherenceGeneralMeasures_handwashing == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens" 
# Select the data: Only compare the current users and never users
data_selected = data[data$nomem_encr %in% data_currentvsneveruser$nomem_encr, ]
data_selected$user_status = droplevels(data_selected$user_status)

# Convert into a table that can be used for the chi square test
chisq.table = table(data_selected$Intention_AdherenceGeneralMeasures_handwashing_agree, data_selected$user_status)
chisqtest = chisq.test(chisq.table) 
```
De chi kwadraat toets (X²(`r chisqtest$parameter`) = `r round(chisqtest$statistic, digits = 2)`, p `r ifelse(chisqtest$p.value < 0.001, "<0.001", paste("=", round(chisqtest$p.value, digits = 3)))`) liet zien dat er `r if(chisqtest$p.value > 0.05){"g"}`een significant verschil was in het percentage gebruikers (`r round((nrow(filter(data_selected, (user_status == 'Gebruiker'& Intention_AdherenceGeneralMeasures_handwashing_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status == 'Gebruiker'))))*100, digits = 1)`%) dat aangaf de handen regelmatig te wassen vergeleken met degenen die de app nooit hebben gebruikt (`r round((nrow(filter(data_selected, (user_status == 'Niet gebruiker' & Intention_AdherenceGeneralMeasures_handwashing_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status == 'Niet gebruiker'))))*100, digits = 1)`%).  

```{r chibehaviorhandwashingusernonuser, echo=FALSE}
# First calculate a proportion for the variable. 
data$Behavior_AdherenceGeneralMeasures_handwashing_agree[(data$Behavior_AdherenceGeneralMeasures_handwashing == 'Vaak'| data$Behavior_AdherenceGeneralMeasures_handwashing == 'Meestal'| data$Behavior_AdherenceGeneralMeasures_handwashing == 'Altijd')] <- "Totaal eens"
data$Behavior_AdherenceGeneralMeasures_handwashing_agree[(data$Behavior_AdherenceGeneralMeasures_handwashing == 'Nooit'| data$Behavior_AdherenceGeneralMeasures_handwashing == 'Zelden'| data$Behavior_AdherenceGeneralMeasures_handwashing == 'Soms'| data$Behavior_AdherenceGeneralMeasures_handwashing == 'Regelmatig')] <- "Neutraal, niet mee eens" 
# Select the data: Only compare the current users and never users
data_selected = data[data$nomem_encr %in% data_currentvsneveruser$nomem_encr, ]
data_selected$user_status = droplevels(data_selected$user_status)

# Convert into a table that can be used for the chi square test
chisq.table = table(data_selected$Behavior_AdherenceGeneralMeasures_handwashing_agree, data_selected$user_status)
chisqtest = chisq.test(chisq.table) 
```
De chi kwadraat toets (X²(`r chisqtest$parameter`) = `r round(chisqtest$statistic, digits = 2)`, p `r ifelse(chisqtest$p.value < 0.001, "<0.001", paste("=", round(chisqtest$p.value, digits = 3)))`) liet zien dat er `r if(chisqtest$p.value > 0.05){"g"}`een significant verschil was in het percentage gebruikers (`r round((nrow(filter(data_selected, (user_status == 'Gebruiker'& Behavior_AdherenceGeneralMeasures_handwashing_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status == 'Gebruiker'))))*100, digits = 1)`%) dat aangaf vaak, meestal of altijd de handen te wassen met water en zeep vergeleken met degenen die de app nooit hebben gebruikt (`r round((nrow(filter(data_selected, (user_status == 'Niet gebruiker' & Behavior_AdherenceGeneralMeasures_handwashing_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status == 'Niet gebruiker'))))*100, digits = 1)`%).  


```{r chiintentiondistancingusernonuser, echo=FALSE}
# First calculate a proportion for the variable. 
data$Intention_AdherenceGeneralMeasures_distance_agree[(data$Intention_AdherenceGeneralMeasures_distance == 'Helemaal mee eens'| data$Intention_AdherenceGeneralMeasures_distance == 'Mee eens'| data$Intention_AdherenceGeneralMeasures_distance == 'Een beetje mee eens')] <- "Totaal eens"
data$Intention_AdherenceGeneralMeasures_distance_agree[(data$Intention_AdherenceGeneralMeasures_distance == 'Neutraal'| data$Intention_AdherenceGeneralMeasures_distance == 'Een beetje oneens'| data$Intention_AdherenceGeneralMeasures_distance == 'Oneens'| data$Intention_AdherenceGeneralMeasures_distance == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens" 
# Select the data: Only compare the current users and never users
data_selected = data[data$nomem_encr %in% data_currentvsneveruser$nomem_encr, ]
data_selected$user_status = droplevels(data_selected$user_status)

# Convert into a table that can be used for the chi square test
chisq.table = table(data_selected$Intention_AdherenceGeneralMeasures_distance_agree, data_selected$user_status)
chisqtest = chisq.test(chisq.table) 
```
De chi kwadraat toets (X²(`r chisqtest$parameter`) = `r round(chisqtest$statistic, digits = 2)`, p `r ifelse(chisqtest$p.value < 0.001, "<0.001", paste("=", round(chisqtest$p.value, digits = 3)))`) liet zien dat er `r if(chisqtest$p.value > 0.05){"g"}`een significant verschil was in het percentage gebruikers (`r round((nrow(filter(data_selected, (user_status == 'Gebruiker'& Intention_AdherenceGeneralMeasures_distance_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status == 'Gebruiker'))))*100, digits = 1)`%) dat aangaf de intentie te hebben om 1.5 meter afstand te houden van mensen buiten hun huishouden vergeleken met degenen die de app nooit hebben gebruikt (`r round((nrow(filter(data_selected, (user_status == 'Niet gebruiker' & Intention_AdherenceGeneralMeasures_distance_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status == 'Niet gebruiker'))))*100, digits = 1)`%).  

```{r chibehaviordistancingusernonuser, echo=FALSE}
# First calculate a proportion for the variable. 
data$Behavior_AdherenceGeneralMeasures_distance_agree[(data$Behavior_AdherenceGeneralMeasures_distance == 'Vaak'| data$Behavior_AdherenceGeneralMeasures_distance == 'Meestal'| data$Behavior_AdherenceGeneralMeasures_distance == 'Altijd')] <- "Totaal eens"
data$Behavior_AdherenceGeneralMeasures_distance_agree[(data$Behavior_AdherenceGeneralMeasures_distance == 'Nooit'| data$Behavior_AdherenceGeneralMeasures_distance == 'Zelden'| data$Behavior_AdherenceGeneralMeasures_distance == 'Soms'| data$Behavior_AdherenceGeneralMeasures_distance == 'Regelmatig')] <- "Neutraal, niet mee eens" 
# Select the data: Only compare the current users and never users
data_selected = data[data$nomem_encr %in% data_currentvsneveruser$nomem_encr, ]
data_selected$user_status = droplevels(data_selected$user_status)

# Convert into a table that can be used for the chi square test
chisq.table = table(data_selected$Behavior_AdherenceGeneralMeasures_distance_agree, data_selected$user_status)
chisqtest = chisq.test(chisq.table) 
```
De chi kwadraat toets (X²(`r chisqtest$parameter`) = `r round(chisqtest$statistic, digits = 2)`, p `r ifelse(chisqtest$p.value < 0.001, "<0.001", paste("=", round(chisqtest$p.value, digits = 3)))`) liet zien dat er `r if(chisqtest$p.value > 0.05){"g"}`een significant verschil was in het percentage gebruikers (`r round((nrow(filter(data_selected, (user_status == 'Gebruiker'& Behavior_AdherenceGeneralMeasures_distance_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status == 'Gebruiker'))))*100, digits = 1)`%) dat aangaf vaak, meestal of altijd 1.5 meter afstand te houden van mensen buiten hun huishouden vergeleken met degenen die de app nooit hebben gebruikt (`r round((nrow(filter(data_selected, (user_status == 'Niet gebruiker' & Behavior_AdherenceGeneralMeasures_distance_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status == 'Niet gebruiker'))))*100, digits = 1)`%).  

```{r chiintentionbusyusernonuser, echo=FALSE}
# First calculate a proportion for the variable. 
data$Intention_AdherenceGeneralMeasures_avoidbusyplaces_agree[(data$Intention_AdherenceGeneralMeasures_avoidbusyplaces == 'Helemaal mee eens'| data$Intention_AdherenceGeneralMeasures_avoidbusyplaces == 'Mee eens'| data$Intention_AdherenceGeneralMeasures_avoidbusyplaces == 'Een beetje mee eens')] <- "Totaal eens"
data$Intention_Intention_AdherenceGeneralMeasures_avoidbusyplaces_agree[(data$Intention_AdherenceGeneralMeasures_avoidbusyplaces == 'Neutraal'| data$Intention_AdherenceGeneralMeasures_avoidbusyplaces == 'Een beetje oneens'| data$Intention_AdherenceGeneralMeasures_avoidbusyplaces == 'Oneens'| data$Intention_AdherenceGeneralMeasures_avoidbusyplaces == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens" 
# Select the data: Only compare the current users and never users
data_selected = data[data$nomem_encr %in% data_currentvsneveruser$nomem_encr, ]
data_selected$user_status = droplevels(data_selected$user_status)

# Convert into a table that can be used for the chi square test
chisq.table = table(data_selected$Intention_AdherenceGeneralMeasures_avoidbusyplaces_agree, data_selected$user_status)
chisqtest = chisq.test(chisq.table) 
```
De chi kwadraat toets (X²(`r chisqtest$parameter`) = `r round(chisqtest$statistic, digits = 2)`, p `r ifelse(chisqtest$p.value < 0.001, "<0.001", paste("=", round(chisqtest$p.value, digits = 3)))`) liet zien dat er `r if(chisqtest$p.value > 0.05){"g"}`een significant verschil was in het percentage gebruikers (`r round((nrow(filter(data_selected, (user_status == 'Gebruiker'& Intention_AdherenceGeneralMeasures_avoidbusyplaces_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status == 'Gebruiker'))))*100, digits = 1)`%) dat aangaf de intentie te hebben om drukke plekken te vermijden vergeleken met degenen die de app nooit hebben gebruikt (`r round((nrow(filter(data_selected, (user_status == 'Niet gebruiker' & Intention_AdherenceGeneralMeasures_avoidbusyplaces_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status == 'Niet gebruiker'))))*100, digits = 1)`%).  

```{r chibehaviorbusyusernonuser, echo=FALSE}
# First calculate a proportion for the variable. 
data$Behavior_AdherenceGeneralMeasures_avoidbusyplaces_agree[(data$Behavior_AdherenceGeneralMeasures_avoidbusyplaces == 'Vaak'| data$Behavior_AdherenceGeneralMeasures_avoidbusyplaces == 'Meestal'| data$Behavior_AdherenceGeneralMeasures_avoidbusyplaces == 'Altijd')] <- "Totaal eens"
data$Behavior_AdherenceGeneralMeasures_avoidbusyplaces_agree[(data$Behavior_AdherenceGeneralMeasures_avoidbusyplaces == 'Nooit'| data$Behavior_AdherenceGeneralMeasures_avoidbusyplaces == 'Zelden'| data$Behavior_AdherenceGeneralMeasures_avoidbusyplaces == 'Soms'| data$Behavior_AdherenceGeneralMeasures_avoidbusyplaces == 'Regelmatig')] <- "Neutraal, niet mee eens" 
# Select the data: Only compare the current users and never users
data_selected = data[data$nomem_encr %in% data_currentvsneveruser$nomem_encr, ]
data_selected$user_status = droplevels(data_selected$user_status)

# Convert into a table that can be used for the chi square test
chisq.table = table(data_selected$Behavior_AdherenceGeneralMeasures_avoidbusyplaces_agree, data_selected$user_status)
chisqtest = chisq.test(chisq.table) 
```
De chi kwadraat toets (X²(`r chisqtest$parameter`) = `r round(chisqtest$statistic, digits = 2)`, p `r ifelse(chisqtest$p.value < 0.001, "<0.001", paste("=", round(chisqtest$p.value, digits = 3)))`) liet zien dat er `r if(chisqtest$p.value > 0.05){"g"}`een significant verschil was in het percentage gebruikers (`r round((nrow(filter(data_selected, (user_status == 'Gebruiker'& Behavior_AdherenceGeneralMeasures_avoidbusyplaces_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status == 'Gebruiker'))))*100, digits = 1)`%) dat aangaf vaak, meestal of altijd op plekken te zijn geweest die eigenlijk te druk waren om de 1.5 meter afstand te houden, vergeleken met degenen die de app nooit hebben gebruikt (`r round((nrow(filter(data_selected, (user_status == 'Niet gebruiker' & Behavior_AdherenceGeneralMeasures_avoidbusyplaces_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status == 'Niet gebruiker'))))*100, digits = 1)`%).  


```{r chiIntentionadherencequarantaine, echo=FALSE}
# First calculate a proportion for the variable. 
data$Intention_AdherenceGeneralMeasures_quarantaine_agree[(data$Intention_AdherenceGeneralMeasures_quarantaine == 'Helemaal mee eens'| data$Intention_AdherenceGeneralMeasures_quarantaine == 'Mee eens'| data$Intention_AdherenceGeneralMeasures_quarantaine == 'Een beetje mee eens')] <- "Totaal eens"
data$Intention_AdherenceGeneralMeasures_quarantaine_agree[(data$Intention_AdherenceGeneralMeasures_quarantaine == 'Neutraal'| data$Intention_AdherenceGeneralMeasures_quarantaine == 'Een beetje oneens'| data$Intention_AdherenceGeneralMeasures_quarantaine == 'Oneens'| data$Intention_AdherenceGeneralMeasures_quarantaine == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens" 
# Select the data: Only compare the current users and never users
data_selected = data[data$nomem_encr %in% data_currentvsneveruser$nomem_encr, ]
data_selected$user_status = droplevels(data_selected$user_status)

# Convert into a table that can be used for the chi square test
chisq.table = table(data_selected$Intention_AdherenceGeneralMeasures_quarantaine_agree, data_selected$user_status)
chisqtest = chisq.test(chisq.table) 
```
De chi kwadraat toets (X²(`r chisqtest$parameter`) = `r round(chisqtest$statistic, digits = 2)`, p `r ifelse(chisqtest$p.value < 0.001, "<0.001", paste("=", round(chisqtest$p.value, digits = 3)))`) liet zien dat er `r if(chisqtest$p.value > 0.05){"g"}`een significant verschil was in het percentage gebruikers (`r round((nrow(filter(data_selected, (user_status == 'Gebruiker'& Intention_AdherenceGeneralMeasures_quarantaine_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status == 'Gebruiker'))))*100, digits = 1)`%) dat aangaf intentie te hebben om in quarantaine te gaan in geval van klachten vergeleken met degenen die de app nooit hebben gebruikt (`r round((nrow(filter(data_selected, (user_status == 'Niet gebruiker' & Intention_AdherenceGeneralMeasures_quarantaine_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status == 'Niet gebruiker'))))*100, digits = 1)`%).  


```{r, echo=FALSE, tab.cap = "Intentie tot houden aan algemene gedragsadviezen naar gebruikersstatus. Aantal en totaal percentage eens (beetje mee eens, eens, helemaal mee eens) per gedragsadvies. Ik ben van plan om de komende 2 maanden ..."}

# === EDIT THESE TO CUSTOMIZE TABLE ===

# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("Intention_AdherenceGeneralMeasures_handwashing", 
                        "Intention_AdherenceGeneralMeasures_distance",
                        "Intention_AdherenceGeneralMeasures_avoidbusyplaces",
                        "Intention_AdherenceGeneralMeasures_quarantaine"
                        )                     
graph_questionlabels = c("... mijn handen regelmatig te wassen", 
                         "... 1,5 meter afstand te houden van mensen buiten mijn huishouden",
                         "... drukke plekken te vermijden", 
                         "... thuis te blijven als ik last heb van klachten die passen bij het coronavirus"
                         ) 

# Which values do we want to include in the table cells?
include_vars = c("Helemaal mee eens", "Mee eens", "Een beetje mee eens")

# === NO MORE EDITS SHOULD BE NEEDED BELOW THIS POINT ===

# Split by user groups
data_grouptable = data.frame(matrix(ncol = length(colnames(user_totals))+1, nrow = length(graph_variablenames)))

colnames(data_grouptable) <- c("variable", usergroup_names)

# Set the values for each variable. Note: this still contains too much logic right now, the values that are counted 
# as correct (in this case "Helemaal mee eens", "Mee eens", and "Een beetje mee eens") are manually added
# and will not apply to all variables (sometimes it is "Waar", or a different likert-scale)
for(idx in 1:length(graph_variablenames)) {
  data_grouptable[idx,"variable"] = graph_questionlabels[idx]
  
  data_grouptable[idx,2] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status == "Gebruiker"))
  
  data_grouptable[idx,3] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status == "Niet gebruiker"))

  data_grouptable[idx,4] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status_intention == "Nooit gebruikt en niet van plan"))

  data_grouptable[idx,5] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status_intention == "Nooit gebruikt en neutraal"))

  data_grouptable[idx,6] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status_intention == "Nooit gebruikt en wel van plan"))
}

# Build the basic table
ft <- flextable(
  head(data_grouptable, n = nrow(data_grouptable))
)

# Header labels
tmp_labels = as.data.frame(t(c("", usergroup_labels)))
colnames(tmp_labels) <- c("variable", usergroup_names)
ft <- set_header_labels(ft, values = tmp_labels)

# Set up the footer of totals
totals = c("Totaal", user_totals)
totals[-1] <- paste(totals[-1], " (100.0%)")

# Percentages and totals
for(colname in colnames(data_grouptable)) {
  if(colname != "variable") {
    # Add percentage to cell
    if (user_totals[1,colname]==0) {
      ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (0.0%)"))
    }
    else {
      ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (", sprintf("%.1f", eval(parse(text=colname))/user_totals[1,colname]*100), "%)"))
    }
    
  }
}

# Actually add the footer with totals
ft <- add_footer_row(ft, values = totals, colwidths = rep(1, length(totals)))

# Change layout of table, and footer specifically
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "right", part = "footer")
ft <- padding(ft, padding = 5, part = "footer")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.

# Note: 7 inch is the page width in Word
# We now divide this into 1.5 inch for the first column (the values),
# and divide the other columns equally among the remaining 5.5 inch.
# If you only have one or few columns, you might want to reduce the total width below:
table_width <- 7

# Set width
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 1.5)
ft_out <- width(ft_out, j = -1, width = (table_width-1.5)/(length(colnames(data_grouptable))-1))

ft_out

```


```{r, echo=FALSE, tab.cap = "Zelfgerapporteerde naleving algemene gedragsadviezen naar gebruikersstatus. Aantal en totaal percentage hoogfrequent (vaak, meestal en altijd) per gedragsadvies. In de afgelopen 2 maanden, hoe vaak ..."}

# === EDIT THESE TO CUSTOMIZE TABLE ===

# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("Behavior_AdherenceGeneralMeasures_handwashing", 
                        "Behavior_AdherenceGeneralMeasures_distance",
                        "Behavior_AdherenceGeneralMeasures_avoidbusyplaces"
                        )                     
graph_questionlabels = c("... hebt u uw handen gewassen met water en zeep?", 
                         "... bent u minder dan op 1,5 meter afstand geweest van mensen buiten uw huishouden?",
                         "... bent u op een plek geweest waar het eigenlijk te druk was om de 1,5 meter afstand te houden?"
                         ) 

# Which values do we want to include in the table cells?
include_vars = c("Vaak", "Meestal", "Altijd")

# === NO MORE EDITS SHOULD BE NEEDED BELOW THIS POINT ===

# Split by user groups
data_grouptable = data.frame(matrix(ncol = length(colnames(user_totals))+1, nrow = length(graph_variablenames)))

colnames(data_grouptable) <- c("variable", usergroup_names)

# Set the values for each variable. Note: this still contains too much logic right now, the values that are counted 
# as correct (in this case "Helemaal mee eens", "Mee eens", and "Een beetje mee eens") are manually added
# and will not apply to all variables (sometimes it is "Waar", or a different likert-scale)
for(idx in 1:length(graph_variablenames)) {
  data_grouptable[idx,"variable"] = graph_questionlabels[idx]
  
  data_grouptable[idx,2] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status == "Gebruiker"))
  
  data_grouptable[idx,3] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status == "Niet gebruiker"))

  data_grouptable[idx,4] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status_intention == "Nooit gebruikt en niet van plan"))

  data_grouptable[idx,5] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status_intention == "Nooit gebruikt en neutraal"))

  data_grouptable[idx,6] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status_intention == "Nooit gebruikt en wel van plan"))
}

# Build the basic table
ft <- flextable(
  head(data_grouptable, n = nrow(data_grouptable))
)

# Header labels
tmp_labels = as.data.frame(t(c("", usergroup_labels)))
colnames(tmp_labels) <- c("variable", usergroup_names)
ft <- set_header_labels(ft, values = tmp_labels)

# Set up the footer of totals
totals = c("Totaal", user_totals)
totals[-1] <- paste(totals[-1], " (100.0%)")

# Percentages and totals
for(colname in colnames(data_grouptable)) {
  if(colname != "variable") {
    # Add percentage to cell
    if (user_totals[1,colname]==0) {
      ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (0.0%)"))
    }
    else {
      ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (", sprintf("%.1f", eval(parse(text=colname))/user_totals[1,colname]*100), "%)"))
    }
    
  }
}

# Actually add the footer with totals
ft <- add_footer_row(ft, values = totals, colwidths = rep(1, length(totals)))

# Change layout of table, and footer specifically
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "right", part = "footer")
ft <- padding(ft, padding = 5, part = "footer")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.

# Note: 7 inch is the page width in Word
# We now divide this into 1.5 inch for the first column (the values),
# and divide the other columns equally among the remaining 5.5 inch.
# If you only have one or few columns, you might want to reduce the total width below:
table_width <- 7

# Set width
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 1.5)
ft_out <- width(ft_out, j = -1, width = (table_width-1.5)/(length(colnames(data_grouptable))-1))

ft_out

```

#### Algemene opvattingen over het coronavirus naar gebruikersstatus
Chi kwadraat toetsen zijn uitgevoerd om te bepalen of het totaal aandeel respondenten die denkt dat de stelling waar is (*zeker waar* en *misschien waar*) verschilt tussen de huidige gebruikers en degenen die de CoronaMelder nooit gebruikt hebben. Daarnaast is gekeken of de subgroep die de CoronaMelder nooit gebruikt heeft en aangaf neutraal te zijn met betrekking tot toekomstig gebruik verschilt van de huidig gebruikers. 
```{r chiconspiracy1usernonuser, echo=FALSE}
# First calculate a proportion for the variable. 
data$Beliefs_Conspiracy1_agree[data$Beliefs_Conspiracy1 == 'Zeker waar'| data$Beliefs_Conspiracy1 == 'Misschien waar'] <- "Totaal waar"
data$Beliefs_Conspiracy1_agree[data$Beliefs_Conspiracy1 == 'Weet ik niet'| data$Beliefs_Conspiracy1 == 'Misschien niet waar'| data$Beliefs_Conspiracy1 == 'Zeker niet waar'] <- "Weet niet, niet waar" 
# Select the data: Only compare the current users and never users
data_selected = data[data$nomem_encr %in% data_currentvsneveruser$nomem_encr, ]
data_selected$user_status = droplevels(data_selected$user_status)

# Convert into a table that can be used for the chi square test
chisq.table = table(data_selected$Beliefs_Conspiracy1_agree, data_selected$user_status)
chisqtest = chisq.test(chisq.table) 
```
De chi kwadraat toets (X²(`r chisqtest$parameter`) = `r round(chisqtest$statistic, digits = 2)`, p `r ifelse(chisqtest$p.value < 0.001, "<0.001", paste("=", round(chisqtest$p.value, digits = 3)))`) liet zien dat er `r if(chisqtest$p.value > 0.05){"g"}`een significant verschil was in het percentage gebruikers (`r round((nrow(filter(data_selected, (user_status == 'Gebruiker'& Beliefs_Conspiracy1_agree == 'Totaal waar'))) /nrow(filter(data_selected, (user_status == 'Gebruiker'))))*100, digits = 1)`%) dat aangaf dat het waar is dat het coronavirus een biologisch wapen dat in een laboratorium is gemaakt, vergeleken met degenen die de app nooit hebben gebruikt (`r round((nrow(filter(data_selected, (user_status == 'Niet gebruiker' & Beliefs_Conspiracy1_agree == 'Totaal waar'))) /nrow(filter(data_selected, (user_status == 'Niet gebruiker'))))*100, digits = 1)`%).  

```{r chiconspiracy1usernonuserneutral, echo=FALSE}
# First calculate a proportion for the variable. 
data$Beliefs_Conspiracy1_agree[data$Beliefs_Conspiracy1 == 'Zeker waar'| data$HBM_PSus_self1 == 'Misschien waar'] <- "Totaal waar"
data$Beliefs_Conspiracy1_agree[data$Beliefs_Conspiracy1 == 'Weet ik niet'| data$Beliefs_Conspiracy1 == 'Misschien niet waar'| data$Beliefs_Conspiracy1 == 'Zeker niet waar'] <- "Weet niet, niet waar" 
# Select the data: Only compare the current users and never users
data_selected = data[data$nomem_encr %in% data_currentvsneveruserneutral$nomem_encr, ]
data_selected$user_status_intention = droplevels(data_selected$user_status_intention)

# Convert into a table that can be used for the chi square test
chisq.table = table(data_selected$Beliefs_Conspiracy1_agree, data_selected$user_status_intention)
chisqtest = chisq.test(chisq.table) 
```
De chi kwadraat toets (X²(`r chisqtest$parameter`) = `r round(chisqtest$statistic, digits = 2)`, p `r ifelse(chisqtest$p.value < 0.001, "<0.001", paste("=", round(chisqtest$p.value, digits = 3)))`) liet zien dat er `r if(chisqtest$p.value > 0.05){"g"}`een significant verschil was in het percentage gebruikers (`r round((nrow(filter(data_selected, (user_status_intention == 'Gebruiker'& Beliefs_Conspiracy1_agree == 'Totaal waar'))) /nrow(filter(data_selected, (user_status_intention == 'Gebruiker'))))*100, digits = 1)`%) dat aangaf dat het waar is dat het coronavirus een biologisch wapen dat in een laboratorium is gemaakt, vergeleken met degenen die de app nooit hebben gebruikt en daarnaast aangaven neutraal te zijn in hun intentie om de CoronaMelder te gaan gebruiken (`r round((nrow(filter(data_selected, (user_status_intention == 'Nooit gebruikt en neutraal' & Beliefs_Conspiracy1_agree == 'Totaal waar'))) /nrow(filter(data_selected, (user_status_intention == 'Nooit gebruikt en neutraal'))))*100, digits = 1)`%). 

```{r chiconspiracy2usernonuser, echo=FALSE}
# First calculate a proportion for the variable. 
data$Beliefs_Conspiracy2_agree[data$Beliefs_Conspiracy2 == 'Zeker waar'| data$Beliefs_Conspiracy2 == 'Misschien waar'] <- "Totaal waar"
data$Beliefs_Conspiracy2_agree[data$Beliefs_Conspiracy2 == 'Weet ik niet'| data$Beliefs_Conspiracy2 == 'Misschien niet waar'| data$Beliefs_Conspiracy2 == 'Zeker niet waar'] <- "Weet niet, niet waar" 
# Select the data: Only compare the current users and never users
data_selected = data[data$nomem_encr %in% data_currentvsneveruser$nomem_encr, ]
data_selected$user_status = droplevels(data_selected$user_status)

# Convert into a table that can be used for the chi square test
chisq.table = table(data_selected$Beliefs_Conspiracy2_agree, data_selected$user_status)
chisqtest = chisq.test(chisq.table) 
```
De chi kwadraat toets (X²(`r chisqtest$parameter`) = `r round(chisqtest$statistic, digits = 2)`, p `r ifelse(chisqtest$p.value < 0.001, "<0.001", paste("=", round(chisqtest$p.value, digits = 3)))`) liet zien dat er `r if(chisqtest$p.value > 0.05){"g"}`een significant verschil was in het percentage gebruikers (`r round((nrow(filter(data_selected, (user_status == 'Gebruiker'& Beliefs_Conspiracy2_agree == 'Totaal waar'))) /nrow(filter(data_selected, (user_status == 'Gebruiker'))))*100, digits = 1)`%) dat aangaf dat het waar is dat de uitbraak van het coronavirus heeft te maken met het 5G netwerk, vergeleken met degenen die de app nooit hebben gebruikt (`r round((nrow(filter(data_selected, (user_status == 'Niet gebruiker' & Beliefs_Conspiracy2_agree == 'Totaal waar'))) /nrow(filter(data_selected, (user_status == 'Niet gebruiker'))))*100, digits = 1)`%).  

```{r chiconspiracy2usernonuserneutral, echo=FALSE}
# First calculate a proportion for the variable. 
data$Beliefs_Conspiracy1_agree[data$Beliefs_Conspiracy2 == 'Zeker waar'| data$Beliefs_Conspiracy2 == 'Misschien waar'] <- "Totaal waar"
data$Beliefs_Conspiracy2_agree[data$Beliefs_Conspiracy2 == 'Weet ik niet'| data$Beliefs_Conspiracy2 == 'Misschien niet waar'| data$Beliefs_Conspiracy2 == 'Zeker niet waar'] <- "Weet niet, niet waar" 
# Select the data: Only compare the current users and never users
data_selected = data[data$nomem_encr %in% data_currentvsneveruserneutral$nomem_encr, ]
data_selected$user_status_intention = droplevels(data_selected$user_status_intention)

# Convert into a table that can be used for the chi square test
chisq.table = table(data_selected$Beliefs_Conspiracy2_agree, data_selected$user_status_intention)
chisqtest = chisq.test(chisq.table) 
```
De chi kwadraat toets (X²(`r chisqtest$parameter`) = `r round(chisqtest$statistic, digits = 2)`, p `r ifelse(chisqtest$p.value < 0.001, "<0.001", paste("=", round(chisqtest$p.value, digits = 3)))`) liet zien dat er `r if(chisqtest$p.value > 0.05){"g"}`een significant verschil was in het percentage gebruikers (`r round((nrow(filter(data_selected, (user_status_intention == 'Gebruiker'& Beliefs_Conspiracy2_agree == 'Totaal waar'))) /nrow(filter(data_selected, (user_status_intention == 'Gebruiker'))))*100, digits = 1)`%) dat aangaf dat het waar is dat de uitbraak van het coronavirus heeft te maken met het 5G netwerk, vergeleken met degenen die de app nooit hebben gebruikt en daarnaast aangaven neutraal te zijn in hun intentie om de CoronaMelder te gaan gebruiken (`r round((nrow(filter(data_selected, (user_status_intention == 'Nooit gebruikt en neutraal' & Beliefs_Conspiracy2_agree == 'Totaal waar'))) /nrow(filter(data_selected, (user_status_intention == 'Nooit gebruikt en neutraal'))))*100, digits = 1)`%). 


```{r, echo=FALSE, tab.cap ="Geloof in complottheorieën. Aantal en totaal percentage dat overtuigd is dat de stelling waar is (zeker waar, misschien waar)."}

# === EDIT THESE TO CUSTOMIZE TABLE ===

# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("Beliefs_Conspiracy1", 
                        "Beliefs_Conspiracy2")                     
graph_questionlabels = c("Het coronavirus is een biologisch wapen dat in een laboratorium is gemaakt", 
                         "De uitbraak van het coronavirus heeft te maken met (de aanleg van) het 5G netwerk") 

# Which values do we want to include in the table cells?
include_vars = c("Zeker waar", "Misschien waar")

# === NO MORE EDITS SHOULD BE NEEDED BELOW THIS POINT ===

# Split by user groups
data_grouptable = data.frame(matrix(ncol = length(colnames(user_totals))+1, nrow = length(graph_variablenames)))

colnames(data_grouptable) <- c("variable", usergroup_names)

# Set the values for each variable. Note: this still contains too much logic right now, the values that are counted 
# as correct (in this case "Helemaal mee eens", "Mee eens", and "Een beetje mee eens") are manually added
# and will not apply to all variables (sometimes it is "Waar", or a different likert-scale)
for(idx in 1:length(graph_variablenames)) {
  data_grouptable[idx,"variable"] = graph_questionlabels[idx]
  
  data_grouptable[idx,2] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status == "Gebruiker"))
  
  data_grouptable[idx,3] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status == "Niet gebruiker"))

  data_grouptable[idx,4] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status_intention == "Nooit gebruikt en niet van plan"))

  data_grouptable[idx,5] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status_intention == "Nooit gebruikt en neutraal"))

  data_grouptable[idx,6] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status_intention == "Nooit gebruikt en wel van plan"))
}

# Build the basic table
ft <- flextable(
  head(data_grouptable, n = nrow(data_grouptable))
)

# Header labels
tmp_labels = as.data.frame(t(c("", usergroup_labels)))
colnames(tmp_labels) <- c("variable", usergroup_names)
ft <- set_header_labels(ft, values = tmp_labels)

# Set up the footer of totals
totals = c("Totaal", user_totals)
totals[-1] <- paste(totals[-1], " (100.0%)")

# Percentages and totals
for(colname in colnames(data_grouptable)) {
  if(colname != "variable") {
    # Add percentage to cell
    if (user_totals[1,colname]==0) {
      ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (0.0%)"))
    }
    else {
      ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (", sprintf("%.1f", eval(parse(text=colname))/user_totals[1,colname]*100), "%)"))
    }
    
  }
}

# Actually add the footer with totals
ft <- add_footer_row(ft, values = totals, colwidths = rep(1, length(totals)))

# Change layout of table, and footer specifically
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "right", part = "footer")
ft <- padding(ft, padding = 5, part = "footer")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.

# Note: 7 inch is the page width in Word
# We now divide this into 1.5 inch for the first column (the values),
# and divide the other columns equally among the remaining 5.5 inch.
# If you only have one or few columns, you might want to reduce the total width below:
table_width <- 7

# Set width
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 1.5)
ft_out <- width(ft_out, j = -1, width = (table_width-1.5)/(length(colnames(data_grouptable))-1))

ft_out

```

```{r chiPBeliefsTrustGovernmentusernonuser, echo=FALSE}
# First calculate a proportion for the variable. 
data$Beliefs_TrustGovernment_agree[(data$Beliefs_TrustGovernment == 'Helemaal mee eens'| data$Beliefs_TrustGovernment == 'Mee eens'| data$Beliefs_TrustGovernment == 'Een beetje mee eens')] <- "Totaal eens"
data$Beliefs_TrustGovernment_agree[(data$Beliefs_TrustGovernment == 'Neutraal'| data$Beliefs_TrustGovernment == 'Een beetje oneens'| data$Beliefs_TrustGovernment == 'Oneens'| data$Beliefs_TrustGovernment == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens" 
# Select the data: Only compare the current users and never users
data_selected = data[data$nomem_encr %in% data_currentvsneveruser$nomem_encr, ]
data_selected$user_status = droplevels(data_selected$user_status)

# Convert into a table that can be used for the chi square test
chisq.table = table(data_selected$Beliefs_TrustGovernment_agree, data_selected$user_status)
chisqtest = chisq.test(chisq.table) 
```
De chi kwadraat toets (X²(`r chisqtest$parameter`) = `r round(chisqtest$statistic, digits = 2)`, p `r ifelse(chisqtest$p.value < 0.001, "<0.001", paste("=", round(chisqtest$p.value, digits = 3)))`) liet zien dat er `r if(chisqtest$p.value > 0.05){"g"}`een significant verschil was in het percentage gebruikers (`r round((nrow(filter(data_selected, (user_status == 'Gebruiker'& Beliefs_TrustGovernment_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status == 'Gebruiker'))))*100, digits = 1)`%) dat aangaf het eens te zijn met de stelling dat ze vertrouwen hebben in de aanpak van de Nederlandse overheid om het coronavirus onder controle te krijgen, vergeleken met degenen die de app nooit hebben gebruikt (`r round((nrow(filter(data_selected, (user_status == 'Niet gebruiker' & Beliefs_TrustGovernment_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status == 'Niet gebruiker'))))*100, digits = 1)`%).  

```{r chiBeliefsTrustGovernmentusernonuserneutral, echo=FALSE}
# First calculate a proportion for the variable. 
data$Beliefs_TrustGovernment_agree[(data$Beliefs_TrustGovernment == 'Helemaal mee eens'| data$Beliefs_TrustGovernment == 'Mee eens'| data$Beliefs_TrustGovernment == 'Een beetje mee eens')] <- "Totaal eens"
data$Beliefs_TrustGovernment_agree[(data$Beliefs_TrustGovernment == 'Neutraal'| data$Beliefs_TrustGovernment == 'Een beetje oneens'| data$Beliefs_TrustGovernment == 'Oneens'| data$Beliefs_TrustGovernment == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens" 
# Select the data: Only compare the current users and never users
data_selected = data[data$nomem_encr %in% data_currentvsneveruserneutral$nomem_encr, ]
data_selected$user_status_intention = droplevels(data_selected$user_status_intention)

# Convert into a table that can be used for the chi square test
chisq.table = table(data_selected$Beliefs_TrustGovernment_agree, data_selected$user_status_intention)
chisqtest = chisq.test(chisq.table) 
```

De chi kwadraat toets (X²(`r chisqtest$parameter`) = `r round(chisqtest$statistic, digits = 2)`, p `r ifelse(chisqtest$p.value < 0.001, "<0.001", paste("=", round(chisqtest$p.value, digits = 3)))`) liet zien dat er `r if(chisqtest$p.value > 0.05){"g"}`een significant verschil was in het percentage gebruikers (`r round((nrow(filter(data_selected, (user_status_intention == 'Gebruiker'& Beliefs_TrustGovernment_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status_intention == 'Gebruiker'))))*100, digits = 1)`%) dat aangaf het eens te zijn met de stelling dat ze vertrouwen hebben in de aanpak van de Nederlandse overheid om het coronavirus onder controle te krijgen,vergeleken met degenen die de app nooit hebben gebruikt en daarnaast aangaven neutraal te zijn in hun intentie om de CoronaMelder te gaan gebruiken (`r round((nrow(filter(data_selected, (user_status_intention == 'Nooit gebruikt en neutraal' & Beliefs_TrustGovernment_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status_intention == 'Nooit gebruikt en neutraal'))))*100, digits = 1)`%). 


```{r, echo=FALSE, tab.cap ="Vertrouwen in aanpak overheid naar gebruikersstatus. Aantal en totaal percentage dat het eens is met de stelling (helemaal mee eens, mee eens, een beetje mee eens)."}

# === EDIT THESE TO CUSTOMIZE TABLE ===

# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("Beliefs_TrustGovernment")                     
graph_questionlabels = c("Ik heb vertrouwen in de manier waarop de Nederlandse overheid probeert het coronavirus onder controle te houden") 

# Which values do we want to include in the table cells?
include_vars = c("Helemaal mee eens", "Mee eens", "Een beetje mee eens")

# === NO MORE EDITS SHOULD BE NEEDED BELOW THIS POINT ===

# Split by user groups
data_grouptable = data.frame(matrix(ncol = length(colnames(user_totals))+1, nrow = length(graph_variablenames)))

colnames(data_grouptable) <- c("variable", usergroup_names)

# Set the values for each variable. Note: this still contains too much logic right now, the values that are counted 
# as correct (in this case "Helemaal mee eens", "Mee eens", and "Een beetje mee eens") are manually added
# and will not apply to all variables (sometimes it is "Waar", or a different likert-scale)
for(idx in 1:length(graph_variablenames)) {
  data_grouptable[idx,"variable"] = graph_questionlabels[idx]
  
  data_grouptable[idx,2] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status == "Gebruiker"))
  
  data_grouptable[idx,3] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status == "Niet gebruiker"))

  data_grouptable[idx,4] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status_intention == "Nooit gebruikt en niet van plan"))

  data_grouptable[idx,5] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status_intention == "Nooit gebruikt en neutraal"))

  data_grouptable[idx,6] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status_intention == "Nooit gebruikt en wel van plan"))
}

# Build the basic table
ft <- flextable(
  head(data_grouptable, n = nrow(data_grouptable))
)

# Header labels
tmp_labels = as.data.frame(t(c("", usergroup_labels)))
colnames(tmp_labels) <- c("variable", usergroup_names)
ft <- set_header_labels(ft, values = tmp_labels)

# Set up the footer of totals
totals = c("Totaal", user_totals)
totals[-1] <- paste(totals[-1], " (100.0%)")

# Percentages and totals
for(colname in colnames(data_grouptable)) {
  if(colname != "variable") {
    # Add percentage to cell
    if (user_totals[1,colname]==0) {
      ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (0.0%)"))
    }
    else {
      ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (", sprintf("%.1f", eval(parse(text=colname))/user_totals[1,colname]*100), "%)"))
    }
    
  }
}

# Actually add the footer with totals
ft <- add_footer_row(ft, values = totals, colwidths = rep(1, length(totals)))

# Change layout of table, and footer specifically
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "right", part = "footer")
ft <- padding(ft, padding = 5, part = "footer")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.

# Note: 7 inch is the page width in Word
# We now divide this into 1.5 inch for the first column (the values),
# and divide the other columns equally among the remaining 5.5 inch.
# If you only have one or few columns, you might want to reduce the total width below:
table_width <- 7

# Set width
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 1.5)
ft_out <- width(ft_out, j = -1, width = (table_width-1.5)/(length(colnames(data_grouptable))-1))

ft_out

```





```{r IntentieHL, echo=FALSE}
#Plot intenties gesplitst op HL (mensen die de CoronaMelder al gebruiken)
#df_PSev %>% filter(!is.na(Value))

data_nona1a <- data[!is.na(data$BI1a_UTAUT),]
data_nona1b <- data[!is.na(data$BI1b_UTAUT),]

#ggplot(data=data_nona1a, aes(fill=BI1a_UTAUT, x=CatHL)) + geom_bar(position=position_fill(reverse = TRUE), aes(y = (..count..)/sum(..count..))) + scale_y_continuous(labels=percent) + coord_flip() + labs(x = " ", y = "", fill = "") + ggtitle("Intenties gesplitst op gezondheidsvaardigheden") + scale_fill_manual(values=my_palette7) + guides(fill = guide_legend(reverse = TRUE)) + theme(plot.margin = margin(0.2, 0.2, 0, 0, "cm"), legend.position = "bottom", legend.text=element_text(size=8))

#Plot intenties gesplitst op HL (mensen die de CoronaMelder nog niet gebruiken)
#ggplot(data=data_nona1b, aes(fill=BI1b_UTAUT, x=CatHL)) + geom_bar(position=position_fill(reverse = TRUE), aes(y = (..count..)/sum(..count..))) + scale_y_continuous(labels=percent) + coord_flip() + labs(x = " ", y = "", fill = "") + ggtitle("Intenties gesplitst op gezondheidsvaardigheden") + scale_fill_manual(values=my_palette7) + guides(fill = guide_legend(reverse = TRUE)) + theme(plot.margin = margin(0.2, 0.2, 0, 0, "cm"), legend.position = "bottom", legend.text=element_text(size=8))

rm(data_nona1a)
rm(data_nona1b)
```

## Verklarende variabelen voor adoptie
### Verwachte effectiviteit CoronaMelder in bestrijding coronavirus
In kaart is gebracht in welke mate men denkt dat de CoronaMelder bijdraagt aan de bestrijding van het coronavirus. In totaal gaf `r round((nrow(filter(data, (PE1_UTAUT == 'Helemaal mee eens'| PE1_UTAUT == 'Mee eens'| PE1_UTAUT == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`% aan het eens te zijn met de stelling dat men door het gebruiken van de CoronaMelder bijdraagt aan de bestrijding van het coronavirus. Daarnaast gaf `r round((nrow(filter(data, (PE2_UTAUT == 'Helemaal mee eens'| PE2_UTAUT == 'Mee eens'| PE2_UTAUT == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`% aan dat de CoronaMelder nuttig is om ervoor te zorgen dat het coronavirus zich minder verspreidt en geeft `r round((nrow(filter(data, (Beliefs_Protectriskgroups == 'Helemaal mee eens'| Beliefs_Protectriskgroups == 'Mee eens'| Beliefs_Protectriskgroups == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`% aan dat de CoronaMelder helpt om mensen met een kwetsbare gezondheid te beschermen. 

```{r, echo=FALSE, fig.width=7, fig.height=2, fig.cap="Verwachte effeciviteit CoronaMelder", tab.cap="Verwachte effeciviteit CoronaMelder"}

# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("PE1_UTAUT", 
                        "PE2_UTAUT", 
                        "Beliefs_Protectriskgroups")
graph_questionlabels = c("Door de CoronaMelder app te gebruiken help ik mee bij de bestrijding van het coronavirus", 
                         "De CoronaMelder app is nuttig om ervoor te zorgen dat het coronavirus zich minder verspreidt", 
                         "De CoronaMelder app helpt om mensen met een kwetsbare gezondheid te beschermen") 

# These questions have 7 answer categories: Helemaal mee eens - Helemaal mee oneens. The following color palette should be used:
color_palette = my_palette7
# Order of the question categories: first = most green, last = most red # Check if the answer categories match with the codebook (e.g, sometimes also 'weet ik niet is one of the answeroptions')
graph_answercategories = c("Helemaal mee eens", "Mee eens", "Een beetje mee eens", "Neutraal", "Een beetje oneens", "Oneens", "Helemaal mee oneens"); 

# Create a dataframe for the plot
#First only keep the variables you wish to keep. Note: nomem_enc is the participant id
data_graph_wideformat = select(data, nomem_encr, all_of(graph_variablenames))

#Convert it to long format
data_graph_longformat = melt(data_graph_wideformat, id.vars = c('nomem_encr'), measure.vars = graph_variablenames)

# Set the correct ordering of the questions (by default the first variable is placed on the bottom)
# It is not needed to reverse the order of the questionlabels. 
data_graph_longformat$variable <- factor(data_graph_longformat$variable,levels = rev(graph_variablenames))

# Also invert the order of the question labels (as default is that the first element of the vector is placed on the bottom)
graph_questionlabels = rev(graph_questionlabels)

# Set the correct ordering of the answer categories (by default on alphabetic order)
data_graph_longformat$value <- factor(data_graph_longformat$value,levels = graph_answercategories)

# Create the plot
theplot <- ggplot(data=data_graph_longformat, aes(fill=value, x=variable)) + theme_bw() + geom_bar(aes(y = (..count..)/sum(..count..)*length(graph_variablenames))) + scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1)) + coord_flip() + labs(x = "", y = "", fill = "") + scale_fill_manual(values=color_palette, drop=FALSE, labels=stringr::str_wrap(graph_answercategories, width = 10)) + scale_x_discrete(labels=stringr::str_wrap(graph_questionlabels, width = 30)) + theme(plot.margin = margin(0, 0, 0, 0), legend.text=element_text(size=8))

aligned <- align_plots(baseplot, theplot, align="v")
ggdraw(aligned[[2]])

# Create the table. Step 1: new data frame containing counts
data_table = data.frame(matrix(0, ncol = 0, nrow = length(levels(data[[graph_variablenames[1]]]))))

# We need one extra (empty) column label for the row with the possible values
table_questionlabels = list()
table_questionlabels["table_answercategories"] <- ""

# We also need the 'unreversed' question labels ;)
graph_questionlabels_unrev <- rev(graph_questionlabels)

# Inefficient loop, but it does a lot for us: add the counts as columns to the dataframe,
# and add the correct labels for column headings
for(idx in 1:length(graph_variablenames)) {
  if (idx == 1) {
    data_table["table_answercategories"] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[1]
  }
  
  # Add to new dataframe
  data_table[graph_variablenames[idx]] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[2]
  
  # Add correct mapping to column headings
  table_questionlabels[graph_variablenames[idx]] <- graph_questionlabels_unrev[idx]
}




# Build the basic table
ft <- flextable(
  head(data_table, n = nrow(data_table))
)

# Header labels
ft <- set_header_labels(ft, values = table_questionlabels)

# Set up the footer of totals
totals = c("Totaal")

# Percentages and totals
for(colname in colnames(data_table)) {
  if(colname != "table_answercategories") {
    # Add percentage to cell
    ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (", sprintf("%.1f", eval(parse(text=colname))/sum(eval(parse(text=colname)))*100), "%)"))
    
    # Add total to footer
    tablecolumn = paste("data_table$", colname)
    totals <- c(totals, paste(sum(eval(parse(text=tablecolumn))), " (100%)"))
  }
}

# Actually add the footer with totals
ft <- add_footer_row(ft, values = totals, colwidths = rep(1, length(totals)))

# Change layout of table, and footer specifically
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "right", part = "footer")
ft <- padding(ft, padding = 5, part = "footer")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.

# Note: 7 inch is the page width in Word
# We now divide this into 1.5 inch for the first column (the values),
# and divide the other columns equally among the remaining 5.5 inch.
# If you only have one or few columns, you might want to reduce the total width below:
table_width <- 7

# Set width
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 1.5)
ft_out <- width(ft_out, j = -1, width = (table_width-1.5)/(length(colnames(data_table))-1))

ft_out
```

Er is ook gevraagd hoeveel procent van de Nederlandse bevolking volgens de respondent de CoronaMelder app zou moeten gebruiken om de verspreiding van het coronavirus tegen te gaan. De meeste respondenten (`r round(nrow(filter(data, Beliefs_ResponseefficasyOther == '76-90%'))/nrow(data)*100, digits = 1)`%) dachten dat 76-90% van de Nederlandse bevolking de CoronaMelder moet gebruiken om de verspreiding van het coronavirus tegen te gaan. In totaal dacht `r round(((nrow(filter(data, Beliefs_ResponseefficasyOther == '51-75%')) + nrow(filter(data, Beliefs_ResponseefficasyOther == '76-90%')) + nrow(filter(data, Beliefs_ResponseefficasyOther == '91-100%')))/nrow(data)*100), digits = 1)`% van de respondenten dat meer dan 50% van de Nederlandse bevolking de CoronaMelder app moet gebruiken om effectief te zijn. Het aandeel respondenten dat aan gaf niet te weten hoeveel mensen de CoronaMelder app zouden moeten gebruiken is `r round(nrow(filter(data, Beliefs_ResponseefficasyOther == 'Weet ik niet'))/nrow(data)*100, digits = 1)`%. 

```{r, echo=FALSE, fig.width=5.5, fig.height=3, fig.cap="Percentage van Nederlandse bevolking dat de CoronaMelder moet gebruiken om verspreiding van het virus tegen te gaan", tab.cap="Percentage van Nederlandse bevolking dat de CoronaMelder moet gebruiken om verspreiding van het virus tegen te gaan"}
# Beliefs_ResponseefficasyOther
ggplot(data=data, aes(x = Beliefs_ResponseefficasyOther)) +
  theme_bw() +
  xlab(paste(names(table(data$Beliefs_ResponseefficasyOther)))) + 
  ylab(" ") + 
  xlab(" ") + 
  geom_bar(fill = "#bdd7e7", color = "#6baed6") + 
  theme(plot.margin = margin(0, 0.1, 0, 0)) + 
  theme(axis.title=element_text(size=10))

graph_variablenames = "Beliefs_ResponseefficasyOther"
graph_questionlabels = "Hoeveel procent van de Nederlandse bevolking zou volgens u de CoronaMelder app moeten gebruiken om de verspreiding van het coronavirus tegen te gaan?"

# Create the table. Step 1: new data frame containing counts
data_table = data.frame(matrix(0, ncol = 0, nrow = length(levels(data[[graph_variablenames[1]]]))))

# We need one extra (empty) column label for the row with the possible values
table_questionlabels = list()
table_questionlabels["table_answercategories"] <- ""

# We also need the 'unreversed' question labels ;)
graph_questionlabels_unrev <- rev(graph_questionlabels)

# Inefficient loop, but it does a lot for us: add the counts as columns to the dataframe,
# and add the correct labels for column headings
for(idx in 1:length(graph_variablenames)) {
  if (idx == 1) {
    data_table["table_answercategories"] <- as.data.frame(table(data[graph_variablenames[idx]]))[1]
  }
  
  # Add to new dataframe
  data_table[graph_variablenames[idx]] <- as.data.frame(table(data[graph_variablenames[idx]]))[2]
  
  # Add correct mapping to column headings
  table_questionlabels[graph_variablenames[idx]] <- graph_questionlabels_unrev[idx]
}

# Build the basic table
ft <- flextable(
  head(data_table, n = nrow(data_table))
)

# Header labels
ft <- set_header_labels(ft, values = table_questionlabels)

# Set up the footer of totals
totals = c("Totaal")

# Percentages and totals
for(colname in colnames(data_table)) {
  if(colname != "table_answercategories") {
    # Add percentage to cell
    ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (", sprintf("%.1f", eval(parse(text=colname))/sum(eval(parse(text=colname)))*100), "%)"))
    
    # Add total to footer
    tablecolumn = paste("data_table$", colname)
    totals <- c(totals, paste(sum(eval(parse(text=tablecolumn))), " (100%)"))
  }
}

# Actually add the footer with totals
ft <- add_footer_row(ft, values = totals, colwidths = rep(1, length(totals)))

# Change layout of table, and footer specifically
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "right", part = "footer")
ft <- padding(ft, padding = 5, part = "footer")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.

# Note: 7 inch is the page width in Word
# We now divide this into 1.5 inch for the first column (the values),
# and divide the other columns equally among the remaining 5.5 inch.
# If you only have one or few columns, you might want to reduce the total width below:
table_width <- 7

# Set width
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 1.5)
ft_out <- width(ft_out, j = -1, width = (table_width-1.5)/(length(colnames(data_table))-1))

ft_out
```

#### Verwachte effectiviteit CoronaMelder naar gebruikersstatus

Om te onderzoeken of de verwachte effectiviteit een rol speelt in adoptie, is gekeken of er verschillen waren in verwachte effectiviteit naar gebruikersstatus. 
```{r chiPE1utautusernonuser, echo=FALSE}
# First calculate a proportion for the variable. 
data$PE1_UTAUT_agree[(data$PE1_UTAUT == 'Helemaal mee eens'| data$PE1_UTAUT == 'Mee eens'| data$PE1_UTAUT == 'Een beetje mee eens')] <- "Totaal eens"
data$PE1_UTAUT_agree[(data$PE1_UTAUT == 'Neutraal'| data$PE1_UTAUT == 'Een beetje oneens'| data$PE1_UTAUT == 'Oneens'| data$PE1_UTAUT == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens" 
# Select the data: Only compare the current users and never users
data_selected = data[data$nomem_encr %in% data_currentvsneveruser$nomem_encr, ]
data_selected$user_status = droplevels(data_selected$user_status)

# Convert into a table that can be used for the chi square test
chisq.table = table(data_selected$PE1_UTAUT_agree, data_selected$user_status)
chisqtest = chisq.test(chisq.table) 
```
De chi kwadraat toets (X²(`r chisqtest$parameter`) = `r round(chisqtest$statistic, digits = 2)`, p `r ifelse(chisqtest$p.value < 0.001, "<0.001", paste("=", round(chisqtest$p.value, digits = 3)))`) liet zien dat er `r if(chisqtest$p.value > 0.05){"g"}`een significant verschil was in het percentage gebruikers (`r round((nrow(filter(data_selected, (user_status == 'Gebruiker'& PE1_UTAUT_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status == 'Gebruiker'))))*100, digits = 1)`%) dat aangaf het eens te zijn met de stelling dat, door de CoronaMelder te gebruiken, men bijdraagt aan de bestrijding van het coronavirus, vergeleken met degenen die de app nooit hebben gebruikt (`r round((nrow(filter(data_selected, (user_status == 'Niet gebruiker' & PE1_UTAUT_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status == 'Niet gebruiker'))))*100, digits = 1)`%).  
```{r chiPE1utautusernonuserneutral, echo=FALSE}
# First calculate a proportion for the variable. 
data$PE1_UTAUT_agree[(data$PE1_UTAUT == 'Helemaal mee eens'| data$PE1_UTAUT == 'Mee eens'| data$PE1_UTAUT == 'Een beetje mee eens')] <- "Totaal eens"
data$PE1_UTAUT_agree[(data$PE1_UTAUT == 'Neutraal'| data$PE1_UTAUT == 'Een beetje oneens'| data$PE1_UTAUT == 'Oneens'| data$PE1_UTAUT == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens" 
# Select the data: Only compare the current users and never users
data_selected = data[data$nomem_encr %in% data_currentvsneveruserneutral$nomem_encr, ]
data_selected$user_status_intention = droplevels(data_selected$user_status_intention)

# Convert into a table that can be used for the chi square test
chisq.table = table(data_selected$PE1_UTAUT_agree, data_selected$user_status_intention)
chisqtest = chisq.test(chisq.table) 
```
Daarnaast liet de chi kwadraat toets (X²(`r chisqtest$parameter`) = `r round(chisqtest$statistic, digits = 2)`, p `r ifelse(chisqtest$p.value < 0.001, "<0.001", paste("=", round(chisqtest$p.value, digits = 3)))`) zien dat er `r if(chisqtest$p.value > 0.05){"g"}`een significant verschil was in het percentage gebruikers (`r round((nrow(filter(data_selected, (user_status_intention == 'Gebruiker'& PE1_UTAUT_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status_intention == 'Gebruiker'))))*100, digits = 1)`%) dat aangaf het eens te zijn met de stelling dat, door de CoronaMelder te gebruiken, men bijdraagt aan de bestrijding van het coronavirus, vergeleken met degenen die de app nooit hebben gebruikt en daarnaast aangaven neutraal te zijn in hun intentie om de CoronaMelder te gaan gebruiken (`r round((nrow(filter(data_selected, (user_status_intention == 'Nooit gebruikt en neutraal' & PE1_UTAUT_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status_intention == 'Nooit gebruikt en neutraal'))))*100, digits = 1)`%). 
```{r chiPE2utautusernonuser, echo=FALSE}
# First calculate a proportion for the variable. 
data$PE2_UTAUT_agree[(data$PE2_UTAUT == 'Helemaal mee eens'| data$PE2_UTAUT == 'Mee eens'| data$PE2_UTAUT == 'Een beetje mee eens')] <- "Totaal eens"
data$PE2_UTAUT_agree[(data$PE2_UTAUT == 'Neutraal'| data$PE2_UTAUT == 'Een beetje oneens'| data$PE2_UTAUT == 'Oneens'| data$PE2_UTAUT == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens" 
# Select the data: Only compare the current users and never users
data_selected = data[data$nomem_encr %in% data_currentvsneveruser$nomem_encr, ]
data_selected$user_status = droplevels(data_selected$user_status)

# Convert into a table that can be used for the chi square test
chisq.table = table(data_selected$PE2_UTAUT_agree, data_selected$user_status)
chisqtest = chisq.test(chisq.table) 
```
De chi kwadraat toets (X²(`r chisqtest$parameter`) = `r round(chisqtest$statistic, digits = 2)`, p `r ifelse(chisqtest$p.value < 0.001, "<0.001", paste("=", round(chisqtest$p.value, digits = 3)))`) liet zien dat er `r if(chisqtest$p.value > 0.05){"g"}`een significant verschil was in het percentage gebruikers (`r round((nrow(filter(data_selected, (user_status == 'Gebruiker'& PE2_UTAUT_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status == 'Gebruiker'))))*100, digits = 1)`%) dat aangaf het eens te zijn met de stelling dat de CoronaMelder nuttig is om ervoor te zorgen dat het coronavirus zich minder verspreidt, vergeleken met degenen die de app nooit hebben gebruikt (`r round((nrow(filter(data_selected, (user_status == 'Niet gebruiker' & PE2_UTAUT_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status == 'Niet gebruiker'))))*100, digits = 1)`%).  
```{r chiPE2utautusernonuserneutral, echo=FALSE}
# First calculate a proportion for the variable. 
data$PE2_UTAUT_agree[(data$PE2_UTAUT == 'Helemaal mee eens'| data$PE2_UTAUT == 'Mee eens'| data$PE2_UTAUT == 'Een beetje mee eens')] <- "Totaal eens"
data$PE2_UTAUT_agree[(data$PE2_UTAUT == 'Neutraal'| data$PE2_UTAUT == 'Een beetje oneens'| data$PE2_UTAUT == 'Oneens'| data$PE2_UTAUT == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens" 
# Select the data: Only compare the current users and never users
data_selected = data[data$nomem_encr %in% data_currentvsneveruserneutral$nomem_encr, ]
data_selected$user_status_intention = droplevels(data_selected$user_status_intention)

# Convert into a table that can be used for the chi square test
chisq.table = table(data_selected$PE2_UTAUT_agree, data_selected$user_status_intention)
chisqtest = chisq.test(chisq.table) 
```
Daarnaast liet de chi kwadraat toets (X²(`r chisqtest$parameter`) = `r round(chisqtest$statistic, digits = 2)`, p `r ifelse(chisqtest$p.value < 0.001, "<0.001", paste("=", round(chisqtest$p.value, digits = 3)))`) zien dat er `r if(chisqtest$p.value > 0.05){"g"}`een significant verschil was in het percentage gebruikers (`r round((nrow(filter(data_selected, (user_status_intention == 'Gebruiker'& PE2_UTAUT_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status_intention == 'Gebruiker'))))*100, digits = 1)`%) dat aangaf het eens te zijn met de stelling dat de CoronaMelder nuttig is om ervoor te zorgen dat het coronavirus zich minder verspreidt, vergeleken met degenen die de app nooit hebben gebruikt en daarnaast aangaven neutraal te zijn in hun intentie om de CoronaMelder te gaan gebruiken (`r round((nrow(filter(data_selected, (user_status_intention == 'Nooit gebruikt en neutraal' & PE2_UTAUT_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status_intention == 'Nooit gebruikt en neutraal'))))*100, digits = 1)`%). 
```{r chiBeliefsprotectriskgroupsusernonuser, echo=FALSE}
# First calculate a proportion for the variable. 
data$Beliefs_Protectriskgroups_agree[(data$Beliefs_Protectriskgroups == 'Helemaal mee eens'| data$Beliefs_Protectriskgroups == 'Mee eens'| data$Beliefs_Protectriskgroups == 'Een beetje mee eens')] <- "Totaal eens"
data$Beliefs_Protectriskgroups_agree[(data$Beliefs_Protectriskgroups == 'Neutraal'| data$Beliefs_Protectriskgroups == 'Een beetje oneens'| data$Beliefs_Protectriskgroups == 'Oneens'| data$Beliefs_Protectriskgroups == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens" 
# Select the data: Only compare the current users and never users
data_selected = data[data$nomem_encr %in% data_currentvsneveruser$nomem_encr, ]
data_selected$user_status = droplevels(data_selected$user_status)

# Convert into a table that can be used for the chi square test
chisq.table = table(data_selected$Beliefs_Protectriskgroups_agree, data_selected$user_status)
chisqtest = chisq.test(chisq.table) 
```
De chi kwadraat toets (X²(`r chisqtest$parameter`) = `r round(chisqtest$statistic, digits = 2)`, p `r ifelse(chisqtest$p.value < 0.001, "<0.001", paste("=", round(chisqtest$p.value, digits = 3)))`) liet zien dat er `r if(chisqtest$p.value > 0.05){"g"}`een significant verschil was in het percentage gebruikers (`r round((nrow(filter(data_selected, (user_status == 'Gebruiker'& Beliefs_Protectriskgroups_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status == 'Gebruiker'))))*100, digits = 1)`%) dat aangaf het eens te zijn met de stelling dat de CoronaMelder helpt om mensen met een kwetsbare gezondheid te beschermen, vergeleken met degenen die de app nooit hebben gebruikt (`r round((nrow(filter(data_selected, (user_status == 'Niet gebruiker' & Beliefs_Protectriskgroups_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status == 'Niet gebruiker'))))*100, digits = 1)`%).
```{r chiBeliefsprotectriskgroupsusernonuserneutral, echo=FALSE}
# First calculate a proportion for the variable. 
data$Beliefs_Protectriskgroups_agree[(data$Beliefs_Protectriskgroups == 'Helemaal mee eens'| data$Beliefs_Protectriskgroups == 'Mee eens'| data$Beliefs_Protectriskgroups == 'Een beetje mee eens')] <- "Totaal eens"
data$Beliefs_Protectriskgroups_agree[(data$Beliefs_Protectriskgroups == 'Neutraal'| data$Beliefs_Protectriskgroups == 'Een beetje oneens'| data$Beliefs_Protectriskgroups == 'Oneens'| data$Beliefs_Protectriskgroups == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens" 
# Select the data: Only compare the current users and never users
data_selected = data[data$nomem_encr %in% data_currentvsneveruserneutral$nomem_encr, ]
data_selected$user_status_intention = droplevels(data_selected$user_status_intention)

# Convert into a table that can be used for the chi square test
chisq.table = table(data_selected$Beliefs_Protectriskgroups_agree, data_selected$user_status_intention)
chisqtest = chisq.test(chisq.table) 
```
Daarnaast liet de chi kwadraat toets (X²(`r chisqtest$parameter`) = `r round(chisqtest$statistic, digits = 2)`, p `r ifelse(chisqtest$p.value < 0.001, "<0.001", paste("=", round(chisqtest$p.value, digits = 3)))`) zien dat er `r if(chisqtest$p.value > 0.05){"g"}`een significant verschil was in het percentage gebruikers (`r round((nrow(filter(data_selected, (user_status_intention == 'Gebruiker'& Beliefs_Protectriskgroups_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status_intention == 'Gebruiker'))))*100, digits = 1)`%) dat aangaf het eens te zijn met de stelling dat de CoronaMelder helpt om mensen met een kwetsbare gezondheid te beschermen, vergeleken met degenen die de app nooit hebben gebruikt en daarnaast aangaven neutraal te zijn in hun intentie om de CoronaMelder te gaan gebruiken (`r round((nrow(filter(data_selected, (user_status_intention == 'Nooit gebruikt en neutraal' & Beliefs_Protectriskgroups_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status_intention == 'Nooit gebruikt en neutraal'))))*100, digits = 1)`%). 

```{r, echo=FALSE, tab.cap = "Verwachte effectiviteit CoronaMelder naar gebruikersstatus. Aantal en totaal percentage eens (beetje mee eens, eens, helemaal mee eens)."}

# === EDIT THESE TO CUSTOMIZE TABLE ===

# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("PE1_UTAUT", 
                        "PE2_UTAUT", 
                        "Beliefs_Protectriskgroups")
graph_questionlabels = c("Door de CoronaMelder app te gebruiken help ik mee bij de bestrijding van het coronavirus", 
                         "De CoronaMelder app is nuttig om ervoor te zorgen dat het coronavirus zich minder verspreidt", 
                         "De CoronaMelder app helpt om mensen met een kwetsbare gezondheid te beschermen") 

# Which values do we want to include in the table cells?
include_vars = c("Helemaal mee eens", "Mee eens", "Een beetje mee eens")

# === NO MORE EDITS SHOULD BE NEEDED BELOW THIS POINT ===

# Split by user groups
data_grouptable = data.frame(matrix(ncol = length(colnames(user_totals))+1, nrow = length(graph_variablenames)))

colnames(data_grouptable) <- c("variable", usergroup_names)

# Set the values for each variable. Note: this still contains too much logic right now, the values that are counted 
# as correct (in this case "Helemaal mee eens", "Mee eens", and "Een beetje mee eens") are manually added
# and will not apply to all variables (sometimes it is "Waar", or a different likert-scale)
for(idx in 1:length(graph_variablenames)) {
  data_grouptable[idx,"variable"] = graph_questionlabels[idx]
  
  data_grouptable[idx,2] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status == "Gebruiker"))
  
  data_grouptable[idx,3] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status == "Niet gebruiker"))

  data_grouptable[idx,4] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status_intention == "Nooit gebruikt en niet van plan"))

  data_grouptable[idx,5] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status_intention == "Nooit gebruikt en neutraal"))

  data_grouptable[idx,6] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status_intention == "Nooit gebruikt en wel van plan"))
}

# Build the basic table
ft <- flextable(
  head(data_grouptable, n = nrow(data_grouptable))
)

# Header labels
tmp_labels = as.data.frame(t(c("", usergroup_labels)))
colnames(tmp_labels) <- c("variable", usergroup_names)
ft <- set_header_labels(ft, values = tmp_labels)

# Set up the footer of totals
totals = c("Totaal", user_totals)
totals[-1] <- paste(totals[-1], " (100.0%)")

# Percentages and totals
for(colname in colnames(data_grouptable)) {
  if(colname != "variable") {
    # Add percentage to cell
    if (user_totals[1,colname]==0) {
      ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (0.0%)"))
    }
    else {
      ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (", sprintf("%.1f", eval(parse(text=colname))/user_totals[1,colname]*100), "%)"))
    }
    
  }
}

# Actually add the footer with totals
ft <- add_footer_row(ft, values = totals, colwidths = rep(1, length(totals)))

# Change layout of table, and footer specifically
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "right", part = "footer")
ft <- padding(ft, padding = 5, part = "footer")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.

# Note: 7 inch is the page width in Word
# We now divide this into 1.5 inch for the first column (the values),
# and divide the other columns equally among the remaining 5.5 inch.
# If you only have one or few columns, you might want to reduce the total width below:
table_width <- 7

# Set width
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 1.5)
ft_out <- width(ft_out, j = -1, width = (table_width-1.5)/(length(colnames(data_grouptable))-1))

ft_out

```





### Vertrouwen in adequaatheid techniek
In de vragenlijst werd gepeild in welke mate men vertrouwen heeft in de adequaatheid van de techniek. Het overgrote deel van de respondenten antwoordde 'zeker waar' of 'misschien waar' op de stelling 'De techniek (Bluetooth) die wordt gebruikt in de CoronaMelder geeft aan wie er in de buurt is geweest van een persoon die besmet is' (`r round((nrow(filter(data, (Beliefs_technologyperformance == 'Zeker waar'| Beliefs_technologyperformance == 'Misschien waar'))) /nrow(data))*100, digits = 1)`%). 

```{r technology, echo=FALSE, fig.width=7, fig.height=2, fig.cap="Vertrouwen in techniek", tab.cap="Vertrouwen in techniek"}
# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("Beliefs_technologyperformance")
                        
graph_questionlabels = c("De techniek (bluetooth) die wordt gebruikt in de CoronaMelder geeft aan wie er in de buurt is geweest van een persoon die besmet is"); 

# These questions have 5 answer categories: Zeker niet waar - Zeker waar en Weet ik niet. The following color palette should be used:
color_palette = my_palette5blue
# Order of the question categories: first = most green, last = most red # Check if the answer categories match with the codebook (e.g, sometimes also 'weet ik niet is one of the answeroptions')
graph_answercategories = c("Weet ik niet", "Zeker waar", "Misschien waar", "Misschien niet waar", "Zeker niet waar"); 

### Nothing needs to be changed in the script below. 
# Create a dataframe for the plot
#First only keep the variables you wish to keep. Note: nomem_enc is the participant id
data_graph_wideformat = select(data, nomem_encr, all_of(graph_variablenames))

#Convert it to long format
data_graph_longformat = melt(data_graph_wideformat, id.vars = c('nomem_encr'), measure.vars = graph_variablenames)

# Set the correct ordering of the questions (by default the first variable is placed on the bottom)
# It is not needed to reverse the order of the questionlabels. 
data_graph_longformat$variable <- factor(data_graph_longformat$variable,levels = rev(graph_variablenames))

# Also invert the order of the question labels (as default is that the first element of the vector is placed on the bottom)
graph_questionlabels = rev(graph_questionlabels)

# Set the correct ordering of the answer categories (by default on alphabetic order)
data_graph_longformat$value <- factor(data_graph_longformat$value,levels = graph_answercategories)

# Create the plot
theplot <- ggplot(data=data_graph_longformat, aes(fill=value, x=variable)) + theme_bw() + geom_bar(aes(y = (..count..)/sum(..count..)*length(graph_variablenames))) + scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1)) + coord_flip() + labs(x = "", y = "", fill = "") + scale_fill_manual(values=color_palette, drop=FALSE, labels=stringr::str_wrap(graph_answercategories, width = 10)) + scale_x_discrete(labels=stringr::str_wrap(graph_questionlabels, width = 30)) + theme(plot.margin = margin(0, 0, 0, 0), legend.text=element_text(size=8))

aligned <- align_plots(baseplot, theplot, align="v")
ggdraw(aligned[[2]])

# To check: also create the plot with variable labels
#ggplot(data=data_graph_longformat, aes(fill=value, x=variable)) + theme_bw() + geom_bar(aes(y = (..count..)/sum(..count..)*length(graph_variablenames))) + scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1)) + coord_flip() + labs(x = "", y = "", fill = "") + scale_fill_manual(values=color_palette, drop=FALSE, labels=stringr::str_wrap(graph_answercategories, width = 10)) + theme(plot.margin = margin(0, 0, 0, 0), legend.text=element_text(size=8))

# Create the table. Step 1: new data frame containing counts
data_table = data.frame(matrix(0, ncol = 0, nrow = length(levels(data[[graph_variablenames[1]]]))))

# We need one extra (empty) column label for the row with the possible values
table_questionlabels = list()
table_questionlabels["table_answercategories"] <- ""

# We also need the 'unreversed' question labels ;)
graph_questionlabels_unrev <- rev(graph_questionlabels)

# Inefficient loop, but it does a lot for us: add the counts as columns to the dataframe,
# and add the correct labels for column headings
for(idx in 1:length(graph_variablenames)) {
  
  if (idx == 1) {
    data_table["table_answercategories"] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[1]
  }
  
  # Add to new dataframe
  data_table[graph_variablenames[idx]] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[2]
  
  # Add correct mapping to column headings
  table_questionlabels[graph_variablenames[idx]] <- graph_questionlabels_unrev[idx]
}




# Build the basic table
ft <- flextable(
  head(data_table, n = nrow(data_table))
)

# Header labels
ft <- set_header_labels(ft, values = table_questionlabels)

# Set up the footer of totals
totals = c("Totaal")

# Percentages and totals
for(colname in colnames(data_table)) {
  if(colname != "table_answercategories") {
    # Add percentage to cell
    ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (", sprintf("%.1f", eval(parse(text=colname))/sum(eval(parse(text=colname)))*100), "%)"))
    
    # Add total to footer
    tablecolumn = paste("data_table$", colname)
    totals <- c(totals, paste(sum(eval(parse(text=tablecolumn))), " (100%)"))
  }
}

# Actually add the footer with totals
ft <- add_footer_row(ft, values = totals, colwidths = rep(1, length(totals)))

# Change layout of table, and footer specifically
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "right", part = "footer")
ft <- padding(ft, padding = 5, part = "footer")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.

# Note: 7 inch is the page width in Word
# We now divide this into 1.5 inch for the first column (the values),
# and divide the other columns equally among the remaining 5.5 inch.
# If you only have one or few columns, you might want to reduce the total width below:
table_width <- 7

# Set width
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 1.5)
ft_out <- width(ft_out, j = -1, width = (table_width-1.5)/(length(colnames(data_table))-1))

ft_out
```


#### Vertrouwen in adequaatheid techniek naar gebruikersstatus
```{r, echo=FALSE}
# First calculate a proportion for the variable. 
data$Beliefs_technologyperformance_agree[(data$Beliefs_technologyperformance == 'Zeker waar'| data$Beliefs_technologyperformance == 'Misschien waar')] <- "Totaal waar"
data$Beliefs_technologyperformance_agree[(data$Beliefs_technologyperformance == 'Weet ik niet'| data$Beliefs_technologyperformance == 'Zeker niet waar'| data$Beliefs_technologyperformance == 'Misschien niet waar')] <- "Weet niet, niet waar" 
# Select the data: Only compare the current users and never users
data_selected = data[data$nomem_encr %in% data_currentvsneveruser$nomem_encr, ]
data_selected$user_status = droplevels(data_selected$user_status)

# Convert into a table that can be used for the chi square test
chisq.table = table(data_selected$Beliefs_technologyperformance_agree, data_selected$user_status)
chisqtest = chisq.test(chisq.table) 
```

De chi kwadraat toets (X²(`r chisqtest$parameter`) = `r round(chisqtest$statistic, digits = 2)`, p `r ifelse(chisqtest$p.value < 0.001, "<0.001", paste("=", round(chisqtest$p.value, digits = 3)))`) liet zien dat er `r if(chisqtest$p.value > 0.05){"g"}`een significant verschil was in het percentage gebruikers (`r round((nrow(filter(data_selected, (user_status == 'Gebruiker'& Beliefs_technologyperformance_agree == 'Totaal waar'))) /nrow(filter(data_selected, (user_status == 'Gebruiker'))))*100, digits = 1)`%) dat aangaf de CoronaMelder via bluetooth kan aangeven wie er in de buurt is geweest van een persoon die besmet is, vergeleken met degenen die de app nooit hebben gebruikt (`r round((nrow(filter(data_selected, (user_status == 'Niet gebruiker' & Beliefs_technologyperformance_agree == 'Totaal waar'))) /nrow(filter(data_selected, (user_status == 'Niet gebruiker'))))*100, digits = 1)`%). 

```{r chiBeliefstechnologyperformanceusernonuserneutral, echo=FALSE}
# First calculate a proportion for the variable. 
data$Beliefs_technologyperformance_agree[(data$Beliefs_technologyperformance == 'Zeker waar'| data$Beliefs_technologyperformance == 'Misschien waar')] <- "Totaal waar"
data$Beliefs_technologyperformance_agree[(data$Beliefs_technologyperformance == 'Weet ik niet'| data$Beliefs_technologyperformance == 'Zeker niet waar'| data$Beliefs_technologyperformance == 'Misschien niet waar')] <- "Weet niet, niet waar" 
# Select the data: Only compare the current users and never users
data_selected = data[data$nomem_encr %in% data_currentvsneveruserneutral$nomem_encr, ]
data_selected$user_status_intention = droplevels(data_selected$user_status_intention)

# Convert into a table that can be used for the chi square test
chisq.table = table(data_selected$Beliefs_technologyperformance_agree, data_selected$user_status_intention)
chisqtest = chisq.test(chisq.table) 
```

Daarnaast liet de chi kwadraat toets (X²(`r chisqtest$parameter`) = `r round(chisqtest$statistic, digits = 2)`, p `r ifelse(chisqtest$p.value < 0.001, "<0.001", paste("=", round(chisqtest$p.value, digits = 3)))`) zien dat er `r if(chisqtest$p.value > 0.05){"g"}`een significant verschil was in het percentage gebruikers (`r round((nrow(filter(data_selected, (user_status_intention == 'Gebruiker'& Beliefs_technologyperformance_agree == 'Totaal waar'))) /nrow(filter(data_selected, (user_status_intention == 'Gebruiker'))))*100, digits = 1)`%) dat aangaf dat de CoronaMelder via bluetooth kan aangeven wie er in de buurt is geweest van een persoon die besmet is, vergeleken met degenen die de app nooit hebben gebruikt, vergeleken met degenen die de app nooit hebben gebruikt en daarnaast aangaven neutraal te zijn in hun intentie om de CoronaMelder te gaan gebruiken (`r round((nrow(filter(data_selected, (user_status_intention == 'Nooit gebruikt en neutraal' & Beliefs_technologyperformance_agree == 'Totaal waar'))) /nrow(filter(data_selected, (user_status_intention == 'Nooit gebruikt en neutraal'))))*100, digits = 1)`%). 

```{r, echo=FALSE, tab.cap ="Vertrouwen in technologie naar gebruikersstatus. Aantal en totaal percentage waar (misschien waar, zeker waar)."}

# === EDIT THESE TO CUSTOMIZE TABLE ===

# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("Beliefs_technologyperformance")
graph_questionlabels = c("De techniek (bluetooth) die wordt gebruikt in de CoronaMelder geeft aan wie er in de buurt is geweest van een persoon die besmet is") 

# Which values do we want to include in the table cells?
include_vars = c("Zeker waar", "Misschien waar")

# === NO MORE EDITS SHOULD BE NEEDED BELOW THIS POINT ===

# Split by user groups
data_grouptable = data.frame(matrix(ncol = length(colnames(user_totals))+1, nrow = length(graph_variablenames)))

colnames(data_grouptable) <- c("variable", usergroup_names)

# Set the values for each variable. Note: this still contains too much logic right now, the values that are counted 
# as correct (in this case "Helemaal mee eens", "Mee eens", and "Een beetje mee eens") are manually added
# and will not apply to all variables (sometimes it is "Waar", or a different likert-scale)
for(idx in 1:length(graph_variablenames)) {
  data_grouptable[idx,"variable"] = graph_questionlabels[idx]
  
  data_grouptable[idx,2] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status == "Gebruiker"))
  
  data_grouptable[idx,3] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status == "Niet gebruiker"))

  data_grouptable[idx,4] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status_intention == "Nooit gebruikt en niet van plan"))

  data_grouptable[idx,5] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status_intention == "Nooit gebruikt en neutraal"))

  data_grouptable[idx,6] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status_intention == "Nooit gebruikt en wel van plan"))
}

# Build the basic table
ft <- flextable(
  head(data_grouptable, n = nrow(data_grouptable))
)

# Header labels
tmp_labels = as.data.frame(t(c("", usergroup_labels)))
colnames(tmp_labels) <- c("variable", usergroup_names)
ft <- set_header_labels(ft, values = tmp_labels)

# Set up the footer of totals
totals = c("Totaal", user_totals)
totals[-1] <- paste(totals[-1], " (100.0%)")

# Percentages and totals
for(colname in colnames(data_grouptable)) {
  if(colname != "variable") {
    # Add percentage to cell
    if (user_totals[1,colname]==0) {
      ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (0.0%)"))
    }
    else {
      ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (", sprintf("%.1f", eval(parse(text=colname))/user_totals[1,colname]*100), "%)"))
    }
    
  }
}

# Actually add the footer with totals
ft <- add_footer_row(ft, values = totals, colwidths = rep(1, length(totals)))

# Change layout of table, and footer specifically
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "right", part = "footer")
ft <- padding(ft, padding = 5, part = "footer")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.

# Note: 7 inch is the page width in Word
# We now divide this into 1.5 inch for the first column (the values),
# and divide the other columns equally among the remaining 5.5 inch.
# If you only have one or few columns, you might want to reduce the total width below:
table_width <- 7

# Set width
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 1.5)
ft_out <- width(ft_out, j = -1, width = (table_width-1.5)/(length(colnames(data_grouptable))-1))

ft_out

```


### Maatschappelijke gevolgen gebruik CoronaMelder
Aan de respondenten werd gevraagd in hoeverre zij dachten dat gebruik van de CoronaMelder de Nederlandse economie helpt. Ongeveer één op de drie respondenten heeft de overtuiging dat de CoronaMelder de Nederlandse economie zal helpen (`r round((nrow(filter(data, (Beliefs_benefiteconomic == 'Helemaal mee eens'| Beliefs_benefiteconomic == 'Mee eens'| Beliefs_benefiteconomic == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`%).

```{r beneficteconomic, echo=FALSE, fig.width=7, fig.height=2, fig.cap="Overtuiging dat de CoronaMelder de Nederlandse economie helpt", tab.cap="Geloof dat de CoronaMelder de Nederlandse economie helpt"}

# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("Beliefs_benefiteconomic")
graph_questionlabels = c("Gebruik van de CoronaMelder helpt de Nederlandse economie"); 

# These questions have 7 answer categories: Helemaal mee eens - Helemaal mee oneens. The following color palette should be used:
color_palette = my_palette7
# Order of the question categories: first = most green, last = most red # Check if the answer categories match with the codebook (e.g, sometimes also 'weet ik niet is one of the answeroptions')
graph_answercategories = c("Helemaal mee eens", "Mee eens", "Een beetje mee eens", "Neutraal", "Een beetje oneens", "Oneens", "Helemaal mee oneens"); 

# Create a dataframe for the plot
#First only keep the variables you wish to keep. Note: nomem_enc is the participant id
data_graph_wideformat = select(data, nomem_encr, all_of(graph_variablenames))

#Convert it to long format
data_graph_longformat = melt(data_graph_wideformat, id.vars = c('nomem_encr'), measure.vars = graph_variablenames)

# Set the correct ordering of the questions (by default the first variable is placed on the bottom)
data_graph_longformat$variable <- factor(data_graph_longformat$variable,levels = rev(graph_variablenames))

# Also invert the order of the question labels (as default is that the first element of the vector is placed on the bottom)
graph_questionlabels = rev(graph_questionlabels)

# Set the correct ordering of the answer categories (by default on alphabetic order)
data_graph_longformat$value <- factor(data_graph_longformat$value,levels = graph_answercategories)

# Create the plot
theplot <- ggplot(data=data_graph_longformat, aes(fill=value, x=variable)) + theme_bw() + geom_bar(aes(y = (..count..)/sum(..count..)*length(graph_variablenames))) + scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1)) + coord_flip() + labs(x = "", y = "", fill = "") + scale_fill_manual(values=color_palette, drop=FALSE, labels=stringr::str_wrap(graph_answercategories, width = 10)) + scale_x_discrete(labels=stringr::str_wrap(graph_questionlabels, width = 30)) + theme(plot.margin = margin(0, 0, 0, 0), legend.text=element_text(size=8)) 

aligned <- align_plots(baseplot, theplot, align="v")
ggdraw(aligned[[2]])

# Create the table. Step 1: new data frame containing counts
data_table = data.frame(matrix(0, ncol = 0, nrow = length(levels(data[[graph_variablenames[1]]]))))

# We need one extra (empty) column label for the row with the possible values
table_questionlabels = list()
table_questionlabels["table_answercategories"] <- ""

# We also need the 'unreversed' question labels ;)
graph_questionlabels_unrev <- rev(graph_questionlabels)

# Inefficient loop, but it does a lot for us: add the counts as columns to the dataframe,
# and add the correct labels for column headings
for(idx in 1:length(graph_variablenames)) {
  
  if (idx == 1) {
    data_table["table_answercategories"] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[1]
  }
  
  # Add to new dataframe
  data_table[graph_variablenames[idx]] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[2]
  
  # Add correct mapping to column headings
  table_questionlabels[graph_variablenames[idx]] <- graph_questionlabels_unrev[idx]
}




# Build the basic table
ft <- flextable(
  head(data_table, n = nrow(data_table))
)

# Header labels
ft <- set_header_labels(ft, values = table_questionlabels)

# Set up the footer of totals
totals = c("Totaal")

# Percentages and totals
for(colname in colnames(data_table)) {
  if(colname != "table_answercategories") {
    # Add percentage to cell
    ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (", sprintf("%.1f", eval(parse(text=colname))/sum(eval(parse(text=colname)))*100), "%)"))
    
    # Add total to footer
    tablecolumn = paste("data_table$", colname)
    totals <- c(totals, paste(sum(eval(parse(text=tablecolumn))), " (100%)"))
  }
}

# Actually add the footer with totals
ft <- add_footer_row(ft, values = totals, colwidths = rep(1, length(totals)))

# Change layout of table, and footer specifically
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "right", part = "footer")
ft <- padding(ft, padding = 5, part = "footer")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.

# Note: 7 inch is the page width in Word
# We now divide this into 1.5 inch for the first column (the values),
# and divide the other columns equally among the remaining 5.5 inch.
# If you only have one or few columns, you might want to reduce the total width below:
table_width <- 7

# Set width
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 1.5)
ft_out <- width(ft_out, j = -1, width = (table_width-1.5)/(length(colnames(data_table))-1))

ft_out
```


#### Maatschappelijke gevolgen gebruik CoronaMelder naar gebruikersstatus
```{r chiBeliefsbenefiteconomicusernonuser, echo=FALSE}
# First calculate a proportion for the variable. 
data$Beliefs_benefiteconomic_agree[(data$Beliefs_benefiteconomic == 'Helemaal mee eens'| data$Beliefs_benefiteconomic == 'Mee eens'| data$Beliefs_benefiteconomic == 'Een beetje mee eens')] <- "Totaal eens"
data$Beliefs_benefiteconomic_agree[(data$Beliefs_benefiteconomic == 'Neutraal'| data$Beliefs_benefiteconomic == 'Een beetje oneens'| data$Beliefs_benefiteconomic == 'Oneens'| data$Beliefs_benefiteconomic == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens" 
# Select the data: Only compare the current users and never users
data_selected = data[data$nomem_encr %in% data_currentvsneveruser$nomem_encr, ]
data_selected$user_status = droplevels(data_selected$user_status)

# Convert into a table that can be used for the chi square test
chisq.table = table(data_selected$Beliefs_benefiteconomic_agree, data_selected$user_status)
chisqtest = chisq.test(chisq.table) 
```
De chi kwadraat toets (X²(`r chisqtest$parameter`) = `r round(chisqtest$statistic, digits = 2)`, p `r ifelse(chisqtest$p.value < 0.001, "<0.001", paste("=", round(chisqtest$p.value, digits = 3)))`) liet zien dat er `r if(chisqtest$p.value > 0.05){"g"}`een significant verschil was in het percentage gebruikers (`r round((nrow(filter(data_selected, (user_status == 'Gebruiker'& Beliefs_benefiteconomic_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status == 'Gebruiker'))))*100, digits = 1)`%) dat aangaf het eens te zijn met de stelling dat gebruik van de CoronaMelder de Nederlandse economie helpt, vergeleken met degenen die de app nooit hebben gebruikt (`r round((nrow(filter(data_selected, (user_status == 'Niet gebruiker' & Beliefs_benefiteconomic_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status == 'Niet gebruiker'))))*100, digits = 1)`%).  
```{r chiBeliefsbenefiteconomicusernonuserneutral, echo=FALSE}
# First calculate a proportion for the variable. 
data$Beliefs_benefiteconomic_agree[(data$Beliefs_benefiteconomic == 'Helemaal mee eens'| data$Beliefs_benefiteconomic == 'Mee eens'| data$Beliefs_benefiteconomic == 'Een beetje mee eens')] <- "Totaal eens"
data$Beliefs_benefiteconomic_agree[(data$Beliefs_benefiteconomic == 'Neutraal'| data$Beliefs_benefiteconomic == 'Een beetje oneens'| data$Beliefs_benefiteconomic == 'Oneens'| data$Beliefs_benefiteconomic == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens" 
# Select the data: Only compare the current users and never users
data_selected = data[data$nomem_encr %in% data_currentvsneveruserneutral$nomem_encr, ]
data_selected$user_status_intention = droplevels(data_selected$user_status_intention)

# Convert into a table that can be used for the chi square test
chisq.table = table(data_selected$Beliefs_benefiteconomic_agree, data_selected$user_status_intention)
chisqtest = chisq.test(chisq.table) 
```
Daarnaast liet de chi kwadraat toets (X²(`r chisqtest$parameter`) = `r round(chisqtest$statistic, digits = 2)`, p `r ifelse(chisqtest$p.value < 0.001, "<0.001", paste("=", round(chisqtest$p.value, digits = 3)))`) zien dat er `r if(chisqtest$p.value > 0.05){"g"}`een significant verschil was in het percentage gebruikers (`r round((nrow(filter(data_selected, (user_status_intention == 'Gebruiker'& Beliefs_benefiteconomic_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status_intention == 'Gebruiker'))))*100, digits = 1)`%) dat aangaf het eens te zijn met de stelling dat gebruik van de CoronaMelder de Nederlandse economie helpt, vergeleken met degenen die de app nooit hebben gebruikt en daarnaast aangaven neutraal te zijn in hun intentie om de CoronaMelder te gaan gebruiken (`r round((nrow(filter(data_selected, (user_status_intention == 'Nooit gebruikt en neutraal' & Beliefs_benefiteconomic_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status_intention == 'Nooit gebruikt en neutraal'))))*100, digits = 1)`%). 


```{r, echo=FALSE, tab.cap ="Maatschappelijke gevolgen gebruik CoronaMelder naar gebruikersstatus. Aantal en totaal percentage eens (beetje mee eens, eens, helemaal mee eens)."}

# === EDIT THESE TO CUSTOMIZE TABLE ===

# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("Beliefs_benefiteconomic")
graph_questionlabels = c("Gebruik van de CoronaMelder helpt de Nederlandse economie") 

# Which values do we want to include in the table cells?
include_vars = c("Helemaal mee eens", "Mee eens", "Een beetje mee eens")

# === NO MORE EDITS SHOULD BE NEEDED BELOW THIS POINT ===

# Split by user groups
data_grouptable = data.frame(matrix(ncol = length(colnames(user_totals))+1, nrow = length(graph_variablenames)))

colnames(data_grouptable) <- c("variable", usergroup_names)

# Set the values for each variable. Note: this still contains too much logic right now, the values that are counted 
# as correct (in this case "Helemaal mee eens", "Mee eens", and "Een beetje mee eens") are manually added
# and will not apply to all variables (sometimes it is "Waar", or a different likert-scale)
for(idx in 1:length(graph_variablenames)) {
  data_grouptable[idx,"variable"] = graph_questionlabels[idx]
  
  data_grouptable[idx,2] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status == "Gebruiker"))
  
  data_grouptable[idx,3] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status == "Niet gebruiker"))

  data_grouptable[idx,4] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status_intention == "Nooit gebruikt en niet van plan"))

  data_grouptable[idx,5] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status_intention == "Nooit gebruikt en neutraal"))

  data_grouptable[idx,6] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status_intention == "Nooit gebruikt en wel van plan"))
}

# Build the basic table
ft <- flextable(
  head(data_grouptable, n = nrow(data_grouptable))
)

# Header labels
tmp_labels = as.data.frame(t(c("", usergroup_labels)))
colnames(tmp_labels) <- c("variable", usergroup_names)
ft <- set_header_labels(ft, values = tmp_labels)

# Set up the footer of totals
totals = c("Totaal", user_totals)
totals[-1] <- paste(totals[-1], " (100.0%)")

# Percentages and totals
for(colname in colnames(data_grouptable)) {
  if(colname != "variable") {
    # Add percentage to cell
    if (user_totals[1,colname]==0) {
      ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (0.0%)"))
    }
    else {
      ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (", sprintf("%.1f", eval(parse(text=colname))/user_totals[1,colname]*100), "%)"))
    }
    
  }
}

# Actually add the footer with totals
ft <- add_footer_row(ft, values = totals, colwidths = rep(1, length(totals)))

# Change layout of table, and footer specifically
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "right", part = "footer")
ft <- padding(ft, padding = 5, part = "footer")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.

# Note: 7 inch is the page width in Word
# We now divide this into 1.5 inch for the first column (the values),
# and divide the other columns equally among the remaining 5.5 inch.
# If you only have one or few columns, you might want to reduce the total width below:
table_width <- 7

# Set width
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 1.5)
ft_out <- width(ft_out, j = -1, width = (table_width-1.5)/(length(colnames(data_grouptable))-1))

ft_out

```

### Verwachte gebruiksvriendelijkheid, inspanningsverwachting en zelfeffectiviteit

Gebruiksvriendelijkheid, inspanningsverwachting en zelfeffectiviteit zijn factoren die belangrijk zijn in de adoptie van nieuwe technologie. Opvallend is dat van de mensen die de CoronaMelder nog *niet* gebruiken, 1 op de 5 mensen (`r round((nrow(filter(data, (EE1b_UTAUT == 'Helemaal mee eens'| EE1b_UTAUT == 'Mee eens'| EE1b_UTAUT == 'Een beetje mee eens') & Behavior_UTAUT == 'Ik heb de CoronaMelder app nooit gebruikt')) /nrow(filter(data, Behavior_UTAUT == 'Ik heb de CoronaMelder app nooit gebruikt')))*100, digits = 1)`%) denkt dat het veel tijd en energie kost om deze te gaan gebruiken en een aanzienlijk deel hier neutraal in staat (`r round((nrow(filter(data, (EE1b_UTAUT == 'Neutraal') & Behavior_UTAUT == 'Ik heb de CoronaMelder app nooit gebruikt')) /nrow(filter(data, Behavior_UTAUT == 'Ik heb de CoronaMelder app nooit gebruikt')))*100, digits = 1)`%). Ongeveer de helft (`r round((nrow(filter(data, (EE1b_UTAUT == 'Helemaal mee oneens'| EE1b_UTAUT == 'Oneens'| EE1b_UTAUT == 'Een beetje oneens') & Behavior_UTAUT == 'Ik heb de CoronaMelder app nooit gebruikt')) /nrow(filter(data, Behavior_UTAUT == 'Ik heb de CoronaMelder app nooit gebruikt')))*100, digits = 1)`%) is het hier mee oneens.

Daar staat tegenover dat van de mensen die de CoronaMelder al *wel* gebruiken, slechts `r round((nrow(filter(data, (EE1a_UTAUT == 'Helemaal mee eens'| EE1a_UTAUT == 'Mee eens'| EE1a_UTAUT == 'Een beetje mee eens') & Behavior_UTAUT == 'Ik gebruik de CoronaMelder app op dit moment')) /nrow(filter(data, Behavior_UTAUT == 'Ik gebruik de CoronaMelder app op dit moment')))*100, digits = 1)`% aangaf dat het ze veel tijd en energie gekost had. Bijna 9 op de 10 (`r round((nrow(filter(data, (EE1a_UTAUT == 'Helemaal mee oneens'| EE1a_UTAUT == 'Oneens'| EE1a_UTAUT == 'Een beetje oneens') & Behavior_UTAUT == 'Ik gebruik de CoronaMelder app op dit moment')) /nrow(filter(data, Behavior_UTAUT == 'Ik gebruik de CoronaMelder app op dit moment')))*100, digits = 1)`%) respondenten gaf aan het niet eens te zijn met deze stelling. 

Hetzelfde patroon was te zien voor de vraag over gebruiksgemak: het merendeel (`r round((nrow(filter(data, (EE2a_UTAUT == 'Helemaal mee eens'| EE2a_UTAUT == 'Mee eens'| EE2a_UTAUT == 'Een beetje mee eens') & Behavior_UTAUT == 'Ik gebruik de CoronaMelder app op dit moment')) /nrow(filter(data, Behavior_UTAUT == 'Ik gebruik de CoronaMelder app op dit moment')))*100, digits = 1)`%) van de respondenten die de CoronaMelder op dit moment gebruiken was het eens met de stelling dat de CoronaMelder makkelijk te gebruiken is. Van degenen die de CoronaMelder nooit hebben gebruikt gaf `r round((nrow(filter(data, (EE2b_UTAUT == 'Helemaal mee eens'| EE2b_UTAUT == 'Mee eens'| EE2b_UTAUT == 'Een beetje mee eens') & Behavior_UTAUT == 'Ik heb de CoronaMelder app nooit gebruikt')) /nrow(filter(data, Behavior_UTAUT == 'Ik heb de CoronaMelder app nooit gebruikt')))*100, digits = 1)`% aan dat hij/zij verwacht dat de CoronaMelder makkelijk te gebruiken is. 

```{r effortexpectancynonusers, echo=FALSE, fig.width=7, fig.height=2, fig.cap="Inspanningsverwachting en zelfeffectiviteit bij respondenten die de CoronaMelder op dit moment niet gebruiken", tab.cap="Inspanningsverwachting en zelfeffectiviteit bij respondenten die de CoronaMelder op dit moment niet gebruiken"}

# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("EE1b_UTAUT", 
                        "EE2b_UTAUT")
graph_questionlabels = c("Ik denk dat het mij veel tijd en energie kost om de CoronaMelder te gebruiken", 
                         "Ik denk dat de CoronaMelder makkelijk te gebruiken is"); 

# These questions have 7 answer categories: Helemaal mee eens - Helemaal mee oneens. The following color palette should be used:
color_palette = my_palette7
# Order of the question categories: first = most green, last = most red # Check if the answer categories match with the codebook (e.g, sometimes also 'weet ik niet is one of the answeroptions')
graph_answercategories = c("Helemaal mee eens", "Mee eens", "Een beetje mee eens", "Neutraal", "Een beetje oneens", "Oneens", "Helemaal mee oneens"); 

# Create a dataframe for the plot
# Select only the current users
data_selected = data[ which(data$Behavior_UTAUT=='Ik heb de CoronaMelder app nooit gebruikt'
), ]
#First only keep the variables you wish to keep. Note: nomem_enc is the participant id. 
data_graph_wideformat = select(data_selected, nomem_encr, all_of(graph_variablenames))

#Convert it to long format
data_graph_longformat = melt(data_graph_wideformat, id.vars = c('nomem_encr'), measure.vars = graph_variablenames)

# Set the correct ordering of the questions (by default the first variable is placed on the bottom)
# It is not needed to reverse the order of the questionlabels. 
data_graph_longformat$variable <- factor(data_graph_longformat$variable,levels = rev(graph_variablenames))

# Also invert the order of the question labels (as default is that the first element of the vector is placed on the bottom)
graph_questionlabels = rev(graph_questionlabels)

# Set the correct ordering of the answer categories (by default on alphabetic order)
data_graph_longformat$value <- factor(data_graph_longformat$value,levels = graph_answercategories)

# Create the plot
theplot <- ggplot(data=data_graph_longformat, aes(fill=value, x=variable)) + theme_bw() + geom_bar(aes(y = (..count..)/sum(..count..)*length(graph_variablenames))) + scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1)) + coord_flip() + labs(x = "", y = "", fill = "") + scale_fill_manual(values=color_palette, drop=FALSE, labels=stringr::str_wrap(graph_answercategories, width = 10)) + scale_x_discrete(labels=stringr::str_wrap(graph_questionlabels, width = 30)) + theme(plot.margin = margin(0, 0, 0, 0), legend.text=element_text(size=8))

aligned <- align_plots(baseplot, theplot, align="v")
ggdraw(aligned[[2]])

# Create the table. Step 1: new data frame containing counts
data_table = data.frame(matrix(0, ncol = 0, nrow = length(levels(data[[graph_variablenames[1]]]))))

# We need one extra (empty) column label for the row with the possible values
table_questionlabels = list()
table_questionlabels["table_answercategories"] <- ""

# We also need the 'unreversed' question labels ;)
graph_questionlabels_unrev <- rev(graph_questionlabels)

# Inefficient loop, but it does a lot for us: add the counts as columns to the dataframe,
# and add the correct labels for column headings
for(idx in 1:length(graph_variablenames)) {
  
  if (idx == 1) {
    data_table["table_answercategories"] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[1]
  }
  
  # Add to new dataframe
  data_table[graph_variablenames[idx]] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[2]
  
  # Add correct mapping to column headings
  table_questionlabels[graph_variablenames[idx]] <- graph_questionlabels_unrev[idx]
}




# Build the basic table
ft <- flextable(
  head(data_table, n = nrow(data_table))
)

# Header labels
ft <- set_header_labels(ft, values = table_questionlabels)

# Set up the footer of totals
totals = c("Totaal")

# Percentages and totals
for(colname in colnames(data_table)) {
  if(colname != "table_answercategories") {
    # Add percentage to cell
    ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (", sprintf("%.1f", eval(parse(text=colname))/sum(eval(parse(text=colname)))*100), "%)"))
    
    # Add total to footer
    tablecolumn = paste("data_table$", colname)
    totals <- c(totals, paste(sum(eval(parse(text=tablecolumn))), " (100%)"))
  }
}

# Actually add the footer with totals
ft <- add_footer_row(ft, values = totals, colwidths = rep(1, length(totals)))

# Change layout of table, and footer specifically
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "right", part = "footer")
ft <- padding(ft, padding = 5, part = "footer")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.

# Note: 7 inch is the page width in Word
# We now divide this into 1.5 inch for the first column (the values),
# and divide the other columns equally among the remaining 5.5 inch.
# If you only have one or few columns, you might want to reduce the total width below:
table_width <- 7

# Set width
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 1.5)
ft_out <- width(ft_out, j = -1, width = (table_width-1.5)/(length(colnames(data_table))-1))

ft_out
```

In onderstaande grafiek en tabellen zijn de resultaten voor de respondenten die de CoronaMelder momenteel niet gebruiken, te vinden. 

```{r effortexpectancyusers, echo=FALSE, fig.width=7, fig.height=2, fig.cap="Zelfeffectiviteit bij respondenten die de CoronaMelder op dit moment gebruiken", tab.cap="Zelfeffectiviteit bij respondenten die de CoronaMelder op dit moment gebruiken"}

# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("EE1a_UTAUT", 
                        "EE2a_UTAUT")
graph_questionlabels = c("Het kost(te) mij veel tijd en energie om de CoronaMelder te gebruiken", 
                         "De CoronaMelder is makkelijk te gebruiken"); 

# These questions have 7 answer categories: Helemaal mee eens - Helemaal mee oneens. The following color palette should be used:
color_palette = my_palette7
# Order of the question categories: first = most green, last = most red # Check if the answer categories match with the codebook (e.g, sometimes also 'weet ik niet is one of the answeroptions')
graph_answercategories = c("Helemaal mee eens", "Mee eens", "Een beetje mee eens", "Neutraal", "Een beetje oneens", "Oneens", "Helemaal mee oneens"); 

# Create a dataframe for the plot
# Select only the current users
data_selected = data[ which(data$Behavior_UTAUT=='Ik gebruik de CoronaMelder app op dit moment'), ]
#First only keep the variables you wish to keep. Note: nomem_enc is the participant id. 
data_graph_wideformat = select(data_selected, nomem_encr, all_of(graph_variablenames))

#Convert it to long format
data_graph_longformat = melt(data_graph_wideformat, id.vars = c('nomem_encr'), measure.vars = graph_variablenames)

# Set the correct ordering of the questions (by default the first variable is placed on the bottom)
# It is not needed to reverse the order of the questionlabels. 
data_graph_longformat$variable <- factor(data_graph_longformat$variable,levels = rev(graph_variablenames))

# Also invert the order of the question labels (as default is that the first element of the vector is placed on the bottom)
graph_questionlabels = rev(graph_questionlabels)

# Set the correct ordering of the answer categories (by default on alphabetic order)
data_graph_longformat$value <- factor(data_graph_longformat$value,levels = graph_answercategories)

# Create the plot
theplot <- ggplot(data=data_graph_longformat, aes(fill=value, x=variable)) + theme_bw() + geom_bar(aes(y = (..count..)/sum(..count..)*length(graph_variablenames))) + scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1)) + coord_flip() + labs(x = "", y = "", fill = "") + scale_fill_manual(values=color_palette, drop=FALSE, labels=stringr::str_wrap(graph_answercategories, width = 10)) + scale_x_discrete(labels=stringr::str_wrap(graph_questionlabels, width = 30)) + theme(plot.margin = margin(0, 0, 0, 0), legend.text=element_text(size=8))

aligned <- align_plots(baseplot, theplot, align="v")
ggdraw(aligned[[2]])

# Create the table. Step 1: new data frame containing counts
data_table = data.frame(matrix(0, ncol = 0, nrow = length(levels(data[[graph_variablenames[1]]]))))

# We need one extra (empty) column label for the row with the possible values
table_questionlabels = list()
table_questionlabels["table_answercategories"] <- ""

# We also need the 'unreversed' question labels ;)
graph_questionlabels_unrev <- rev(graph_questionlabels)

# Inefficient loop, but it does a lot for us: add the counts as columns to the dataframe,
# and add the correct labels for column headings
for(idx in 1:length(graph_variablenames)) {
  
  if (idx == 1) {
    data_table["table_answercategories"] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[1]
  }
  
  # Add to new dataframe
  data_table[graph_variablenames[idx]] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[2]
  
  # Add correct mapping to column headings
  table_questionlabels[graph_variablenames[idx]] <- graph_questionlabels_unrev[idx]
}




# Build the basic table
ft <- flextable(
  head(data_table, n = nrow(data_table))
)

# Header labels
ft <- set_header_labels(ft, values = table_questionlabels)

# Set up the footer of totals
totals = c("Totaal")

# Percentages and totals
for(colname in colnames(data_table)) {
  if(colname != "table_answercategories") {
    # Add percentage to cell
    ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (", sprintf("%.1f", eval(parse(text=colname))/sum(eval(parse(text=colname)))*100), "%)"))
    
    # Add total to footer
    tablecolumn = paste("data_table$", colname)
    totals <- c(totals, paste(sum(eval(parse(text=tablecolumn))), " (100%)"))
  }
}

# Actually add the footer with totals
ft <- add_footer_row(ft, values = totals, colwidths = rep(1, length(totals)))

# Change layout of table, and footer specifically
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "right", part = "footer")
ft <- padding(ft, padding = 5, part = "footer")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.

# Note: 7 inch is the page width in Word
# We now divide this into 1.5 inch for the first column (the values),
# and divide the other columns equally among the remaining 5.5 inch.
# If you only have one or few columns, you might want to reduce the total width below:
table_width <- 7

# Set width
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 1.5)
ft_out <- width(ft_out, j = -1, width = (table_width-1.5)/(length(colnames(data_table))-1))

ft_out

```

Zelfeffectiviteit is de persoonlijke inschatting van de eigen bekwaamheid om bepaald gedrag uit te kunnen voeren. Er is gevraagd of men zich zelf in staat achtte om de CoronaMelder te gebruiken:`r round((nrow(filter(data, (HBM_selfefficacy_CoronaMelder == 'Helemaal mee eens'| HBM_selfefficacy_CoronaMelder == 'Mee eens'| HBM_selfefficacy_CoronaMelder == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`% acht zichzelf in staat de CoronaMelder te gebruiken. In onderstaande grafiek en tabel zijn de resultaten voor de gehele sample te zien. 

```{r selfefficacyCM, echo=FALSE, fig.width=7, fig.height=2, fig.cap="Zelfeffectiviteit om CoronaMelder te gebruiken", tab.cap="Zelfeffectiviteit om CoronaMelder te gebruiken"}

# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("HBM_selfefficacy_CoronaMelder")
graph_questionlabels = c("Ik ben in staat om de CoronaMelder te gebruiken"); 

# These questions have 7 answer categories: Helemaal mee eens - Helemaal mee oneens. The following color palette should be used:
color_palette = my_palette7
# Order of the question categories: first = most green, last = most red # Check if the answer categories match with the codebook (e.g, sometimes also 'weet ik niet is one of the answeroptions')
graph_answercategories = c("Helemaal mee eens", "Mee eens", "Een beetje mee eens", "Neutraal", "Een beetje oneens", "Oneens", "Helemaal mee oneens"); 

# Create a dataframe for the plot
#First only keep the variables you wish to keep. Note: nomem_enc is the participant id
data_graph_wideformat = select(data, nomem_encr, all_of(graph_variablenames))

#Convert it to long format
data_graph_longformat = melt(data_graph_wideformat, id.vars = c('nomem_encr'), measure.vars = graph_variablenames)

# Set the correct ordering of the questions (by default the first variable is placed on the bottom)
data_graph_longformat$variable <- factor(data_graph_longformat$variable,levels = rev(graph_variablenames))

# Also invert the order of the question labels (as default is that the first element of the vector is placed on the bottom)
graph_questionlabels = rev(graph_questionlabels)

# Set the correct ordering of the answer categories (by default on alphabetic order)
data_graph_longformat$value <- factor(data_graph_longformat$value,levels = graph_answercategories)

theplot <- ggplot(data=data_graph_longformat, aes(fill=value, x=variable)) + theme_bw() + geom_bar(aes(y = (..count..)/sum(..count..)*length(graph_variablenames))) + scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1)) + coord_flip() + labs(x = "", y = "", fill = "") + scale_fill_manual(values=color_palette, drop=FALSE, labels=stringr::str_wrap(graph_answercategories, width = 10)) + scale_x_discrete(labels=stringr::str_wrap(graph_questionlabels, width = 30)) + theme(plot.margin = margin(0, 0, 0, 0), legend.text=element_text(size=8)) + theme(plot.title = element_text(size=11))

aligned <- align_plots(baseplot, theplot, align="v")
ggdraw(aligned[[2]])

# Create the table. Step 1: new data frame containing counts
data_table = data.frame(matrix(0, ncol = 0, nrow = length(levels(data[[graph_variablenames[1]]]))))

# We need one extra (empty) column label for the row with the possible values
table_questionlabels = list()
table_questionlabels["table_answercategories"] <- ""

# We also need the 'unreversed' question labels ;)
graph_questionlabels_unrev <- rev(graph_questionlabels)

# Inefficient loop, but it does a lot for us: add the counts as columns to the dataframe,
# and add the correct labels for column headings
for(idx in 1:length(graph_variablenames)) {
  
  if (idx == 1) {
    data_table["table_answercategories"] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[1]
  }
  
  # Add to new dataframe
  data_table[graph_variablenames[idx]] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[2]
  
  # Add correct mapping to column headings
  table_questionlabels[graph_variablenames[idx]] <- graph_questionlabels_unrev[idx]
}




# Build the basic table
ft <- flextable(
  head(data_table, n = nrow(data_table))
)

# Header labels
ft <- set_header_labels(ft, values = table_questionlabels)

# Set up the footer of totals
totals = c("Totaal")

# Percentages and totals
for(colname in colnames(data_table)) {
  if(colname != "table_answercategories") {
    # Add percentage to cell
    ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (", sprintf("%.1f", eval(parse(text=colname))/sum(eval(parse(text=colname)))*100), "%)"))
    
    # Add total to footer
    tablecolumn = paste("data_table$", colname)
    totals <- c(totals, paste(sum(eval(parse(text=tablecolumn))), " (100%)"))
  }
}

# Actually add the footer with totals
ft <- add_footer_row(ft, values = totals, colwidths = rep(1, length(totals)))

# Change layout of table, and footer specifically
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "right", part = "footer")
ft <- padding(ft, padding = 5, part = "footer")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.

# Note: 7 inch is the page width in Word
# We now divide this into 1.5 inch for the first column (the values),
# and divide the other columns equally among the remaining 5.5 inch.
# If you only have one or few columns, you might want to reduce the total width below:
table_width <- 7

# Set width
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 1.5)
ft_out <- width(ft_out, j = -1, width = (table_width-1.5)/(length(colnames(data_table))-1))

ft_out
```


### Technologie gerelateerde belemmeringen
Vanuit het UTAUT is bekend dat technologie gerelateerde belemmeringen een rol kunnen spelen in de adoptie van nieuwe technologieën zoals de CoronaMelder. In totaal gaf slechts `r round((nrow(filter(data, (FC1_UTAUT == 'Helemaal mee oneens'| FC1_UTAUT == 'Oneens'| FC1_UTAUT == 'Een beetje oneens'))) /nrow(data))*100, digits = 1)`% aan het oneens te zijn met de stelling dat hij/zij beschikking heeft over een smartphone waarmee de CoronaMelder gebruikt kan worden. Daarnaast gaf een laag percentage (`r round((nrow(filter(data, (FC2_UTAUT == 'Helemaal mee oneens'| FC2_UTAUT == 'Oneens'| FC2_UTAUT == 'Een beetje oneens'))) /nrow(data))*100, digits = 1)`%) aan het oneens te zijn met de stelling dat hij/zij genoeg (technische) kennis heeft om de CoronaMelder te gebruiken. Ten slot gaf `r round((nrow(filter(data, (DS_Mobile1 == 'Helemaal mee eens'| DS_Mobile1 == 'Mee eens'| DS_Mobile1 == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`% het aan eens te zijn met de stelling te weten hoe je apps op je telefoon kan installeren en `r round((nrow(filter(data, (DS_Mobile2 == 'Helemaal mee eens'| DS_Mobile2 == 'Mee eens'| DS_Mobile2 == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`% hoe je bluetooth kan aan- en uitzetten. 

```{r , echo=FALSE, fig.width=7, fig.height=3, fig.cap="Technologie gerelateerde belemmeringen", tab.cap="Technologie gerelateerde belemmeringen"}

# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("FC1_UTAUT", 
                        "FC2_UTAUT", 
                        "DS_Mobile1", 
                        "DS_Mobile2")
graph_questionlabels = c("Ik heb een smartphone tot mijn beschikking met toegang tot het internet waarmee ik de CoronaMelder kan gebruiken", 
                         "Ik heb genoeg (technische) kennis om de CoronaMelder te gebruiken", 
                         "Ik weet hoe ik apps op mijn telefoon kan installeren", 
                         "Ik weet hoe ik bluetooth kan aan- en uitzetten op mijn telefoon"); 

# These questions have 7 answer categories: Helemaal mee eens - Helemaal mee oneens. The following color palette should be used:
color_palette = my_palette7
# Order of the question categories: first = most green, last = most red # Check if the answer categories match with the codebook (e.g, sometimes also 'weet ik niet is one of the answeroptions')
graph_answercategories = c("Helemaal mee eens", "Mee eens", "Een beetje mee eens", "Neutraal", "Een beetje oneens", "Oneens", "Helemaal mee oneens"); 

# Create a dataframe for the plot
#First only keep the variables you wish to keep. Note: nomem_enc is the participant id
data_graph_wideformat = select(data, nomem_encr, all_of(graph_variablenames))

#Convert it to long format
data_graph_longformat = melt(data_graph_wideformat, id.vars = c('nomem_encr'), measure.vars = graph_variablenames)

# Set the correct ordering of the questions (by default the first variable is placed on the bottom)
data_graph_longformat$variable <- factor(data_graph_longformat$variable,levels = rev(graph_variablenames))

# Also invert the order of the question labels (as default is that the first element of the vector is placed on the bottom)
graph_questionlabels = rev(graph_questionlabels)

# Set the correct ordering of the answer categories (by default on alphabetic order)
data_graph_longformat$value <- factor(data_graph_longformat$value,levels = graph_answercategories)

# Create the plot
theplot <- ggplot(data=data_graph_longformat, aes(fill=value, x=variable)) + theme_bw() + geom_bar(aes(y = (..count..)/sum(..count..)*length(graph_variablenames))) + scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1)) + coord_flip() + labs(x = "", y = "", fill = "") + scale_fill_manual(values=color_palette, drop=FALSE, labels=stringr::str_wrap(graph_answercategories, width = 10)) + scale_x_discrete(labels=stringr::str_wrap(graph_questionlabels, width = 30)) + theme(plot.margin = margin(0, 0, 0, 0), legend.text=element_text(size=8))

aligned <- align_plots(baseplot, theplot, align="v")
ggdraw(aligned[[2]])

# Create the table. Step 1: new data frame containing counts
data_table = data.frame(matrix(0, ncol = 0, nrow = length(levels(data[[graph_variablenames[1]]]))))

# We need one extra (empty) column label for the row with the possible values
table_questionlabels = list()
table_questionlabels["table_answercategories"] <- ""

# We also need the 'unreversed' question labels ;)
graph_questionlabels_unrev <- rev(graph_questionlabels)

# Inefficient loop, but it does a lot for us: add the counts as columns to the dataframe,
# and add the correct labels for column headings
for(idx in 1:length(graph_variablenames)) {
  if (idx == 1) {
    data_table["table_answercategories"] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[1]
  }
  
  # Add to new dataframe
  data_table[graph_variablenames[idx]] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[2]
  
  # Add correct mapping to column headings
  table_questionlabels[graph_variablenames[idx]] <- graph_questionlabels_unrev[idx]
}




# Build the basic table
ft <- flextable(
  head(data_table, n = nrow(data_table))
)

# Header labels
ft <- set_header_labels(ft, values = table_questionlabels)

# Set up the footer of totals
totals = c("Totaal")

# Percentages and totals
for(colname in colnames(data_table)) {
  if(colname != "table_answercategories") {
    # Add percentage to cell
    ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (", sprintf("%.1f", eval(parse(text=colname))/sum(eval(parse(text=colname)))*100), "%)"))
    
    # Add total to footer
    tablecolumn = paste("data_table$", colname)
    totals <- c(totals, paste(sum(eval(parse(text=tablecolumn))), " (100%)"))
  }
}

# Actually add the footer with totals
ft <- add_footer_row(ft, values = totals, colwidths = rep(1, length(totals)))

# Change layout of table, and footer specifically
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "right", part = "footer")
ft <- padding(ft, padding = 5, part = "footer")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.

# Note: 7 inch is the page width in Word
# We now divide this into 1.5 inch for the first column (the values),
# and divide the other columns equally among the remaining 5.5 inch.
# If you only have one or few columns, you might want to reduce the total width below:
table_width <- 7

# Set width
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 1.5)
ft_out <- width(ft_out, j = -1, width = (table_width-1.5)/(length(colnames(data_table))-1))

ft_out
```


#### Technologie gerelateerde belemmeringen naar gebruikersstatus
```{r chiFC1utautusernonuser, echo=FALSE}
# First calculate a proportion for the variable. 
data$FC1_UTAUT_agree[(data$FC1_UTAUT == 'Helemaal mee eens'| data$FC1_UTAUT == 'Mee eens'| data$FC1_UTAUT == 'Een beetje mee eens')] <- "Totaal eens"
data$FC1_UTAUT_agree[(data$FC1_UTAUT == 'Neutraal'| data$FC1_UTAUT == 'Een beetje oneens'| data$FC1_UTAUT == 'Oneens'| data$FC1_UTAUT == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens" 
# Select the data: Only compare the current users and never users
data_selected = data[data$nomem_encr %in% data_currentvsneveruser$nomem_encr, ]
data_selected$user_status = droplevels(data_selected$user_status)

# Convert into a table that can be used for the chi square test
chisq.table = table(data_selected$FC1_UTAUT_agree, data_selected$user_status)
chisqtest = chisq.test(chisq.table) 
```
De chi kwadraat toets (X²(`r chisqtest$parameter`) = `r round(chisqtest$statistic, digits = 2)`, p `r ifelse(chisqtest$p.value < 0.001, "<0.001", paste("=", round(chisqtest$p.value, digits = 3)))`) liet zien dat er `r if(chisqtest$p.value > 0.05){"g"}`een significant verschil was in het percentage gebruikers (`r round((nrow(filter(data_selected, (user_status == 'Gebruiker'& FC1_UTAUT_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status == 'Gebruiker'))))*100, digits = 1)`%) dat aangaf het eens te zijn beschikking te hebben over een smartphone met internet, vergeleken met degenen die de app nooit hebben gebruikt (`r round((nrow(filter(data_selected, (user_status == 'Niet gebruiker' & FC1_UTAUT_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status == 'Niet gebruiker'))))*100, digits = 1)`%).

```{r chiFC1utautusernonuserneutral, echo=FALSE}
# First calculate a proportion for the variable. 
data$FC1_UTAUT_agree[(data$FC1_UTAUT == 'Helemaal mee eens'| data$FC1_UTAUT == 'Mee eens'| data$FC1_UTAUT == 'Een beetje mee eens')] <- "Totaal eens"
data$FC1_UTAUT_agree[(data$FC1_UTAUT == 'Neutraal'| data$FC1_UTAUT == 'Een beetje oneens'| data$FC1_UTAUT == 'Oneens'| data$FC1_UTAUT == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens" 
# Select the data: Only compare the current users and never users
data_selected = data[data$nomem_encr %in% data_currentvsneveruserneutral$nomem_encr, ]
data_selected$user_status_intention = droplevels(data_selected$user_status_intention)

# Convert into a table that can be used for the chi square test
chisq.table = table(data_selected$FC1_UTAUT_agree, data_selected$user_status_intention)
chisqtest = chisq.test(chisq.table) 
```
Daarnaast liet de chi kwadraat toets (X²(`r chisqtest$parameter`) = `r round(chisqtest$statistic, digits = 2)`, p `r ifelse(chisqtest$p.value < 0.001, "<0.001", paste("=", round(chisqtest$p.value, digits = 3)))`) zien dat er `r if(chisqtest$p.value > 0.05){"g"}`een significant verschil was in het percentage gebruikers (`r round((nrow(filter(data_selected, (user_status_intention == 'Gebruiker'& FC1_UTAUT_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status_intention == 'Gebruiker'))))*100, digits = 1)`%) dat aangaf het eens te zijn beschikking te hebben over een smartphone met internet, vergeleken met degenen die de app nooit hebben gebruikt en daarnaast aangaven neutraal te zijn in hun intentie om de CoronaMelder te gaan gebruiken (`r round((nrow(filter(data_selected, (user_status_intention == 'Nooit gebruikt en neutraal' & FC1_UTAUT_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status_intention == 'Nooit gebruikt en neutraal'))))*100, digits = 1)`%). 

```{r chiFC2utautusernonuser, echo=FALSE}
# First calculate a proportion for the variable. 
data$FC2_UTAUT_agree[(data$FC2_UTAUT == 'Helemaal mee eens'| data$FC2_UTAUT == 'Mee eens'| data$FC2_UTAUT == 'Een beetje mee eens')] <- "Totaal eens"
data$FC2_UTAUT_agree[(data$FC2_UTAUT == 'Neutraal'| data$FC2_UTAUT == 'Een beetje oneens'| data$FC2_UTAUT == 'Oneens'| data$FC2_UTAUT == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens" 
# Select the data: Only compare the current users and never users
data_selected = data[data$nomem_encr %in% data_currentvsneveruser$nomem_encr, ]
data_selected$user_status = droplevels(data_selected$user_status)

# Convert into a table that can be used for the chi square test
chisq.table = table(data_selected$FC2_UTAUT_agree, data_selected$user_status)
chisqtest = chisq.test(chisq.table) 
```
De chi kwadraat toets (X²(`r chisqtest$parameter`) = `r round(chisqtest$statistic, digits = 2)`, p `r ifelse(chisqtest$p.value < 0.001, "<0.001", paste("=", round(chisqtest$p.value, digits = 3)))`) liet zien dat er `r if(chisqtest$p.value > 0.05){"g"}`een significant verschil was in het percentage gebruikers (`r round((nrow(filter(data_selected, (user_status == 'Gebruiker'& FC2_UTAUT_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status == 'Gebruiker'))))*100, digits = 1)`%) dat aangaf het eens te zijn met de stelling genoeg technische kennis te hebben om de CoronaMelder te installeren, vergeleken met degenen die de app nooit hebben gebruikt (`r round((nrow(filter(data_selected, (user_status == 'Niet gebruiker' & FC2_UTAUT_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status == 'Niet gebruiker'))))*100, digits = 1)`%).  

```{r chiFC2utautusernonuserneutral, echo=FALSE}
# First calculate a proportion for the variable. 
data$FC2_UTAUT_agree[(data$FC2_UTAUT == 'Helemaal mee eens'| data$FC2_UTAUT == 'Mee eens'| data$FC2_UTAUT == 'Een beetje mee eens')] <- "Totaal eens"
data$FC2_UTAUT_agree[(data$FC2_UTAUT == 'Neutraal'| data$FC2_UTAUT == 'Een beetje oneens'| data$FC2_UTAUT == 'Oneens'| data$FC2_UTAUT == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens" 
# Select the data: Only compare the current users and never users
data_selected = data[data$nomem_encr %in% data_currentvsneveruserneutral$nomem_encr, ]
data_selected$user_status_intention = droplevels(data_selected$user_status_intention)

# Convert into a table that can be used for the chi square test
chisq.table = table(data_selected$FC2_UTAUT_agree, data_selected$user_status_intention)
chisqtest = chisq.test(chisq.table) 
```
Daarnaast liet de chi kwadraat toets (X²(`r chisqtest$parameter`) = `r round(chisqtest$statistic, digits = 2)`, p `r ifelse(chisqtest$p.value < 0.001, "<0.001", paste("=", round(chisqtest$p.value, digits = 3)))`) zien dat er `r if(chisqtest$p.value > 0.05){"g"}`een significant verschil was in het percentage gebruikers (`r round((nrow(filter(data_selected, (user_status_intention == 'Gebruiker'& FC2_UTAUT_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status_intention == 'Gebruiker'))))*100, digits = 1)`%) dat aangaf het eens te zijn met de stelling genoeg technische kennis te hebben om de CoronaMelder te installeren, vergeleken met degenen die de app nooit hebben gebruikt en daarnaast aangaven neutraal te zijn in hun intentie om de CoronaMelder te gaan gebruiken (`r round((nrow(filter(data_selected, (user_status_intention == 'Nooit gebruikt en neutraal' & FC2_UTAUT_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status_intention == 'Nooit gebruikt en neutraal'))))*100, digits = 1)`%). 

```{r chiDS1mobileusernonuser, echo=FALSE}
# First calculate a proportion for the variable. 
data$DS_Mobile1_agree[(data$DS_Mobile1 == 'Helemaal mee eens'| data$DS_Mobile1 == 'Mee eens'| data$DS_Mobile1 == 'Een beetje mee eens')] <- "Totaal eens"
data$DS_Mobile1_agree[(data$DS_Mobile1 == 'Neutraal'| data$DS_Mobile1 == 'Een beetje oneens'| data$DS_Mobile1 == 'Oneens'| data$DS_Mobile1 == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens" 
# Select the data: Only compare the current users and never users
data_selected = data[data$nomem_encr %in% data_currentvsneveruser$nomem_encr, ]
data_selected$user_status = droplevels(data_selected$user_status)

# Convert into a table that can be used for the chi square test
chisq.table = table(data_selected$DS_Mobile1_agree, data_selected$user_status)
chisqtest = chisq.test(chisq.table) 
```
De chi kwadraat toets (X²(`r chisqtest$parameter`) = `r round(chisqtest$statistic, digits = 2)`, p `r ifelse(chisqtest$p.value < 0.001, "<0.001", paste("=", round(chisqtest$p.value, digits = 3)))`) liet zien dat er `r if(chisqtest$p.value > 0.05){"g"}`een significant verschil was in het percentage gebruikers (`r round((nrow(filter(data_selected, (user_status == 'Gebruiker'& DS_Mobile1_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status == 'Gebruiker'))))*100, digits = 1)`%) dat aangaf het eens te zijn met de stelling dat hij/zij weet hoe je apps op de telefoon kan installeren, vergeleken met degenen die de app nooit hebben gebruikt (`r round((nrow(filter(data_selected, (user_status == 'Niet gebruiker' & DS_Mobile1_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status == 'Niet gebruiker'))))*100, digits = 1)`%).  

```{r chiDSMobile1utautusernonuserneutral, echo=FALSE}
# First calculate a proportion for the variable. 
data$DS_Mobile1_agree[(data$DS_Mobile1 == 'Helemaal mee eens'| data$DS_Mobile1 == 'Mee eens'| data$DS_Mobile1 == 'Een beetje mee eens')] <- "Totaal eens"
data$DS_Mobile1_agree[(data$DS_Mobile1 == 'Neutraal'| data$DS_Mobile1 == 'Een beetje oneens'| data$DS_Mobile1 == 'Oneens'| data$DS_Mobile1 == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens" 
# Select the data: Only compare the current users and never users
data_selected = data[data$nomem_encr %in% data_currentvsneveruserneutral$nomem_encr, ]
data_selected$user_status_intention = droplevels(data_selected$user_status_intention)

# Convert into a table that can be used for the chi square test
chisq.table = table(data_selected$DS_Mobile1_agree, data_selected$user_status_intention)
chisqtest = chisq.test(chisq.table) 
```
Daarnaast liet de chi kwadraat toets (X²(`r chisqtest$parameter`) = `r round(chisqtest$statistic, digits = 2)`, p `r ifelse(chisqtest$p.value < 0.001, "<0.001", paste("=", round(chisqtest$p.value, digits = 3)))`) zien dat er `r if(chisqtest$p.value > 0.05){"g"}`een significant verschil was in het percentage gebruikers (`r round((nrow(filter(data_selected, (user_status_intention == 'Gebruiker'& DS_Mobile1_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status_intention == 'Gebruiker'))))*100, digits = 1)`%) dat aangaf het eens te zijn met de stelling dat hij/zij weet hoe je apps op de telefoon kan installeren, vergeleken met degenen die de app nooit hebben gebruikt en daarnaast aangaven neutraal te zijn in hun intentie om de CoronaMelder te gaan gebruiken (`r round((nrow(filter(data_selected, (user_status_intention == 'Nooit gebruikt en neutraal' & DS_Mobile1_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status_intention == 'Nooit gebruikt en neutraal'))))*100, digits = 1)`%). 
 
```{r chiDS2mobileusernonuser, echo=FALSE}
# First calculate a proportion for the variable. 
data$DS_Mobile2_agree[(data$DS_Mobile2 == 'Helemaal mee eens'| data$DS_Mobile2 == 'Mee eens'| data$DS_Mobile2 == 'Een beetje mee eens')] <- "Totaal eens"
data$DS_Mobile2_agree[(data$DS_Mobile2 == 'Neutraal'| data$DS_Mobile2 == 'Een beetje oneens'| data$DS_Mobile2 == 'Oneens'| data$DS_Mobile2 == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens" 
# Select the data: Only compare the current users and never users
data_selected = data[data$nomem_encr %in% data_currentvsneveruser$nomem_encr, ]
data_selected$user_status = droplevels(data_selected$user_status)

# Convert into a table that can be used for the chi square test
chisq.table = table(data_selected$DS_Mobile2_agree, data_selected$user_status)
chisqtest = chisq.test(chisq.table) 
```
De chi kwadraat toets (X²(`r chisqtest$parameter`) = `r round(chisqtest$statistic, digits = 2)`, p `r ifelse(chisqtest$p.value < 0.001, "<0.001", paste("=", round(chisqtest$p.value, digits = 3)))`) liet zien dat er `r if(chisqtest$p.value > 0.05){"g"}`een significant verschil was in het percentage gebruikers (`r round((nrow(filter(data_selected, (user_status == 'Gebruiker'& DS_Mobile2_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status == 'Gebruiker'))))*100, digits = 1)`%) dat aangaf het eens te zijn met de stelling dat hij/zij weet hoe je apps op de telefoon kan installeren, vergeleken met degenen die de app nooit hebben gebruikt (`r round((nrow(filter(data_selected, (user_status == 'Niet gebruiker' & DS_Mobile2_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status == 'Niet gebruiker'))))*100, digits = 1)`%).  

```{r chiDSMobile2utautusernonuserneutral, echo=FALSE}
# First calculate a proportion for the variable. 
data$DS_Mobile2_agree[(data$DS_Mobile2 == 'Helemaal mee eens'| data$DS_Mobile2 == 'Mee eens'| data$DS_Mobile2 == 'Een beetje mee eens')] <- "Totaal eens"
data$DS_Mobile2_agree[(data$DS_Mobile2 == 'Neutraal'| data$DS_Mobile2 == 'Een beetje oneens'| data$DS_Mobile2 == 'Oneens'| data$DS_Mobile2 == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens" 
# Select the data: Only compare the current users and never users
data_selected = data[data$nomem_encr %in% data_currentvsneveruserneutral$nomem_encr, ]
data_selected$user_status_intention = droplevels(data_selected$user_status_intention)

# Convert into a table that can be used for the chi square test
chisq.table = table(data_selected$DS_Mobile2_agree, data_selected$user_status_intention)
chisqtest = chisq.test(chisq.table) 
```
Daarnaast liet de chi kwadraat toets (X²(`r chisqtest$parameter`) = `r round(chisqtest$statistic, digits = 2)`, p `r ifelse(chisqtest$p.value < 0.001, "<0.001", paste("=", round(chisqtest$p.value, digits = 3)))`) zien dat er `r if(chisqtest$p.value > 0.05){"g"}`een significant verschil was in het percentage gebruikers (`r round((nrow(filter(data_selected, (user_status_intention == 'Gebruiker'& DS_Mobile2_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status_intention == 'Gebruiker'))))*100, digits = 1)`%) dat aangaf het eens te zijn met de stelling dat hij/zij weet hoe je apps op de telefoon kan installeren, vergeleken met degenen die de app nooit hebben gebruikt en daarnaast aangaven neutraal te zijn in hun intentie om de CoronaMelder te gaan gebruiken (`r round((nrow(filter(data_selected, (user_status_intention == 'Nooit gebruikt en neutraal' & DS_Mobile2_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status_intention == 'Nooit gebruikt en neutraal'))))*100, digits = 1)`%). 
 
 
```{r, echo=FALSE, tab.cap = "Technologie gerelateerde belemmeringen naar gebruikersstatus. Aantal en totaal percentage eens (beetje mee eens, eens, helemaal mee eens)."}

# === EDIT THESE TO CUSTOMIZE TABLE ===

# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("FC1_UTAUT", 
                        "FC2_UTAUT", 
                        "DS_Mobile1", 
                        "DS_Mobile2")
graph_questionlabels = c("Ik heb een smartphone tot mijn beschikking met toegang tot het internet waarmee ik de CoronaMelder kan gebruiken", 
                         "Ik heb genoeg (technische) kennis om de CoronaMelder te gebruiken", 
                         "Ik weet hoe ik apps op mijn telefoon kan installeren", 
                         "Ik weet hoe ik bluetooth kan aan- en uitzetten op mijn telefoon"); 

# Which values do we want to include in the table cells?
include_vars = c("Helemaal mee eens", "Mee eens", "Een beetje mee eens")

# === NO MORE EDITS SHOULD BE NEEDED BELOW THIS POINT ===

# Split by user groups
data_grouptable = data.frame(matrix(ncol = length(colnames(user_totals))+1, nrow = length(graph_variablenames)))

colnames(data_grouptable) <- c("variable", usergroup_names)

# Set the values for each variable. Note: this still contains too much logic right now, the values that are counted 
# as correct (in this case "Helemaal mee eens", "Mee eens", and "Een beetje mee eens") are manually added
# and will not apply to all variables (sometimes it is "Waar", or a different likert-scale)
for(idx in 1:length(graph_variablenames)) {
  data_grouptable[idx,"variable"] = graph_questionlabels[idx]
  
  data_grouptable[idx,2] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status == "Gebruiker"))
  
  data_grouptable[idx,3] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status == "Niet gebruiker"))

  data_grouptable[idx,4] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status_intention == "Nooit gebruikt en niet van plan"))

  data_grouptable[idx,5] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status_intention == "Nooit gebruikt en neutraal"))

  data_grouptable[idx,6] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status_intention == "Nooit gebruikt en wel van plan"))
}

# Build the basic table
ft <- flextable(
  head(data_grouptable, n = nrow(data_grouptable))
)

# Header labels
tmp_labels = as.data.frame(t(c("", usergroup_labels)))
colnames(tmp_labels) <- c("variable", usergroup_names)
ft <- set_header_labels(ft, values = tmp_labels)

# Set up the footer of totals
totals = c("Totaal", user_totals)
totals[-1] <- paste(totals[-1], " (100.0%)")

# Percentages and totals
for(colname in colnames(data_grouptable)) {
  if(colname != "variable") {
    # Add percentage to cell
    if (user_totals[1,colname]==0) {
      ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (0.0%)"))
    }
    else {
      ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (", sprintf("%.1f", eval(parse(text=colname))/user_totals[1,colname]*100), "%)"))
    }
    
  }
}

# Actually add the footer with totals
ft <- add_footer_row(ft, values = totals, colwidths = rep(1, length(totals)))

# Change layout of table, and footer specifically
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "right", part = "footer")
ft <- padding(ft, padding = 5, part = "footer")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.

# Note: 7 inch is the page width in Word
# We now divide this into 1.5 inch for the first column (the values),
# and divide the other columns equally among the remaining 5.5 inch.
# If you only have one or few columns, you might want to reduce the total width below:
table_width <- 7

# Set width
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 1.5)
ft_out <- width(ft_out, j = -1, width = (table_width-1.5)/(length(colnames(data_grouptable))-1))

ft_out

```


### Persoonlijke voor- en nadelen van gebruik en verplichting tot gebruik
Belangrijke variabelen uit het UTAUT en het HBM zijn de verwachte voor- en nadelen van het gebruik en de mate waarin iemand een verplichting voelt om de techniek te gebruiken. Het percentage van de respondenten dat voordelen ziet van het gebruik ligt vrij laag (`r round((nrow(filter(data, (HBM_perceivedbenefits_CoronaMelder == 'Helemaal mee eens'| HBM_perceivedbenefits_CoronaMelder == 'Mee eens'| HBM_perceivedbenefits_CoronaMelder == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`%), evenals het percentage dat nadelen ziet van het gebruik (`r round((nrow(filter(data, (HBM_barriers_CoronaMelder == 'Helemaal mee eens'| HBM_barriers_CoronaMelder == 'Mee eens'| HBM_barriers_CoronaMelder == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`%). Slechts `r round((nrow(filter(data, (Beliefs_voluntariness == 'Helemaal mee eens'| Beliefs_voluntariness == 'Mee eens'| Beliefs_voluntariness == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`% voelt zicht verplicht tot het gebruik.

```{r Motivationsbarriersvoluntariness, echo=FALSE, fig.width=7, fig.height=2, fig.cap="Persoonlijke voor- en nadelen van gebruik en verplichting tot gebruik", tab.cap="Persoonlijke nadelen en verplichting tot gebruik", tab.cap="Persoonlijke voor- en nadelen van gebruik en verplichting tot gebruik", tab.cap="Persoonlijke nadelen en verplichting tot gebruik"}
# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("HBM_perceivedbenefits_CoronaMelder",
                        "HBM_barriers_CoronaMelder", 
                        "Beliefs_voluntariness")
graph_questionlabels = c("Het heeft voor mij persoonlijke voordelen om de CoronaMelder te gebruiken",
                         "Het heeft voor mij persoonlijke nadelen om de CoronaMelder te gebruiken", 
                         "Ik voel me verplicht om de CoronaMelder te gebruiken"); 

# These questions have 7 answer categories: Helemaal mee eens - Helemaal mee oneens. The following color palette should be used:
color_palette = my_palette7blue
# Order of the question categories: first = most green, last = most red # Check if the answer categories match with the codebook (e.g, sometimes also 'weet ik niet is one of the answeroptions')
graph_answercategories = c("Helemaal mee eens", "Mee eens", "Een beetje mee eens", "Neutraal", "Een beetje oneens", "Oneens", "Helemaal mee oneens"); 

# Create a dataframe for the plot
#First only keep the variables you wish to keep. Note: nomem_enc is the participant id
data_graph_wideformat = select(data, nomem_encr, all_of(graph_variablenames))

#Convert it to long format
data_graph_longformat = melt(data_graph_wideformat, id.vars = c('nomem_encr'), measure.vars = graph_variablenames)

# Set the correct ordering of the questions (by default the first variable is placed on the bottom)
data_graph_longformat$variable <- factor(data_graph_longformat$variable,levels = rev(graph_variablenames))

# Also invert the order of the question labels (as default is that the first element of the vector is placed on the bottom)
graph_questionlabels = rev(graph_questionlabels)

# Set the correct ordering of the answer categories (by default on alphabetic order)
data_graph_longformat$value <- factor(data_graph_longformat$value,levels = graph_answercategories)

# Create the plot
theplot <- ggplot(data=data_graph_longformat, aes(fill=value, x=variable)) + theme_bw() + geom_bar(aes(y = (..count..)/sum(..count..)*length(graph_variablenames))) + scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1)) + coord_flip() + labs(x = "", y = "", fill = "") + scale_fill_manual(values=color_palette, drop=FALSE, labels=stringr::str_wrap(graph_answercategories, width = 10)) + scale_x_discrete(labels=stringr::str_wrap(graph_questionlabels, width = 30)) + theme(plot.margin = margin(0, 0, 0, 0), legend.text=element_text(size=8))

aligned <- align_plots(baseplot, theplot, align="v")
ggdraw(aligned[[2]])


# Create the table. Step 1: new data frame containing counts
data_table = data.frame(matrix(0, ncol = 0, nrow = length(levels(data[[graph_variablenames[1]]]))))

# We need one extra (empty) column label for the row with the possible values
table_questionlabels = list()
table_questionlabels["table_answercategories"] <- ""

# We also need the 'unreversed' question labels ;)
graph_questionlabels_unrev <- rev(graph_questionlabels)

# Inefficient loop, but it does a lot for us: add the counts as columns to the dataframe,
# and add the correct labels for column headings
for(idx in 1:length(graph_variablenames)) {
  
  if (idx == 1) {
    data_table["table_answercategories"] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[1]
  }
  
  # Add to new dataframe
  data_table[graph_variablenames[idx]] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[2]
  
  # Add correct mapping to column headings
  table_questionlabels[graph_variablenames[idx]] <- graph_questionlabels_unrev[idx]
}


# Build the basic table
ft <- flextable(
  head(data_table, n = nrow(data_table))
)

# Header labels
ft <- set_header_labels(ft, values = table_questionlabels)

# Set up the footer of totals
totals = c("Totaal")

# Percentages and totals
for(colname in colnames(data_table)) {
  if(colname != "table_answercategories") {
    # Add percentage to cell
    ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (", sprintf("%.1f", eval(parse(text=colname))/sum(eval(parse(text=colname)))*100), "%)"))
    
    # Add total to footer
    tablecolumn = paste("data_table$", colname)
    totals <- c(totals, paste(sum(eval(parse(text=tablecolumn))), " (100%)"))
  }
}

# Actually add the footer with totals
ft <- add_footer_row(ft, values = totals, colwidths = rep(1, length(totals)))

# Change layout of table, and footer specifically
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "right", part = "footer")
ft <- padding(ft, padding = 5, part = "footer")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.

# Note: 7 inch is the page width in Word
# We now divide this into 1.5 inch for the first column (the values),
# and divide the other columns equally among the remaining 5.5 inch.
# If you only have one or few columns, you might want to reduce the total width below:
table_width <- 7

# Set width
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 1.5)
ft_out <- width(ft_out, j = -1, width = (table_width-1.5)/(length(colnames(data_table))-1))

ft_out
```



#### Persoonlijke voor- en nadelen van gebruik en verplichting tot gebruik naar gebruikersstatus

```{r chiHBMperceivedbenefitsCoronaMelderutautusernonuser, echo=FALSE}
# First calculate a proportion for the variable. 
data$HBM_perceivedbenefits_CoronaMelder_agree[(data$HBM_perceivedbenefits_CoronaMelder == 'Helemaal mee eens'| data$HBM_perceivedbenefits_CoronaMelder == 'Mee eens'| data$HBM_perceivedbenefits_CoronaMelder == 'Een beetje mee eens')] <- "Totaal eens"
data$HBM_perceivedbenefits_CoronaMelder_agree[(data$HBM_perceivedbenefits_CoronaMelder == 'Neutraal'| data$HBM_perceivedbenefits_CoronaMelder == 'Een beetje oneens'| data$HBM_perceivedbenefits_CoronaMelder == 'Oneens'| data$HBM_perceivedbenefits_CoronaMelder == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens" 
# Select the data: Only compare the current users and never users
data_selected = data[data$nomem_encr %in% data_currentvsneveruser$nomem_encr, ]
data_selected$user_status = droplevels(data_selected$user_status)

# Convert into a table that can be used for the chi square test
chisq.table = table(data_selected$HBM_perceivedbenefits_CoronaMelder_agree, data_selected$user_status)
chisqtest = chisq.test(chisq.table) 
```
De chi kwadraat toets (X²(`r chisqtest$parameter`) = `r round(chisqtest$statistic, digits = 2)`, p `r ifelse(chisqtest$p.value < 0.001, "<0.001", paste("=", round(chisqtest$p.value, digits = 3)))`) liet zien dat er `r if(chisqtest$p.value > 0.05){"g"}`een significant verschil was in het percentage gebruikers (`r round((nrow(filter(data_selected, (user_status == 'Gebruiker'& HBM_perceivedbenefits_CoronaMelder_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status == 'Gebruiker'))))*100, digits = 1)`%) dat aangaf het eens te zijn met de stelling dat het gebruik van de CoronaMelder persoonlijke voordelen heeft, vergeleken met degenen die de app nooit hebben gebruikt (`r round((nrow(filter(data_selected, (user_status == 'Niet gebruiker' & HBM_perceivedbenefits_CoronaMelder_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status == 'Niet gebruiker'))))*100, digits = 1)`%).  

```{r chiHBMperceivedbenefitsCoronaMelderutautusernonuserneutral, echo=FALSE}
# First calculate a proportion for the variable. 
data$HBM_perceivedbenefits_CoronaMelder_agree[(data$HBM_perceivedbenefits_CoronaMelder == 'Helemaal mee eens'| data$HBM_perceivedbenefits_CoronaMelder == 'Mee eens'| data$HBM_perceivedbenefits_CoronaMelder == 'Een beetje mee eens')] <- "Totaal eens"
data$HBM_perceivedbenefits_CoronaMelder_agree[(data$HBM_perceivedbenefits_CoronaMelder == 'Neutraal'| data$HBM_perceivedbenefits_CoronaMelder == 'Een beetje oneens'| data$HBM_perceivedbenefits_CoronaMelder == 'Oneens'| data$HBM_perceivedbenefits_CoronaMelder == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens" 
# Select the data: Only compare the current users and never users
data_selected = data[data$nomem_encr %in% data_currentvsneveruserneutral$nomem_encr, ]
data_selected$user_status_intention = droplevels(data_selected$user_status_intention)

# Convert into a table that can be used for the chi square test
chisq.table = table(data_selected$HBM_perceivedbenefits_CoronaMelder_agree, data_selected$user_status_intention)
chisqtest = chisq.test(chisq.table) 
```
De chi kwadraat toets (X²(`r chisqtest$parameter`) = `r round(chisqtest$statistic, digits = 2)`, p `r ifelse(chisqtest$p.value < 0.001, "<0.001", paste("=", round(chisqtest$p.value, digits = 3)))`) liet zien dat er `r if(chisqtest$p.value > 0.05){"g"}`een significant verschil was in het percentage gebruikers (`r round((nrow(filter(data_selected, (user_status_intention == 'Gebruiker'& HBM_perceivedbenefits_CoronaMelder_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status_intention == 'Gebruiker'))))*100, digits = 1)`%) dat aangaf het eens te zijn met de stelling dat het gebruik van de CoronaMelder persoonlijke voordelen heeft, vergeleken met degenen die de app nooit hebben gebruikt en daarnaast aangaven neutraal te zijn in hun intentie om de CoronaMelder te gaan gebruiken (`r round((nrow(filter(data_selected, (user_status_intention == 'Nooit gebruikt en neutraal' & HBM_perceivedbenefits_CoronaMelder_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status_intention == 'Nooit gebruikt en neutraal'))))*100, digits = 1)`%).

```{r chiHBMbarriersCoronaMelderutautusernonuser, echo=FALSE}
# First calculate a proportion for the variable. 
data$HBM_barriers_CoronaMelder_agree[(data$HBM_barriers_CoronaMelder == 'Helemaal mee eens'| data$HBM_barriers_CoronaMelder == 'Mee eens'| data$HBM_barriers_CoronaMelder == 'Een beetje mee eens')] <- "Totaal eens"
data$HBM_barriers_CoronaMelder_agree[(data$HBM_barriers_CoronaMelder == 'Neutraal'| data$HBM_barriers_CoronaMelder == 'Een beetje oneens'| data$HBM_barriers_CoronaMelder == 'Oneens'| data$HBM_barriers_CoronaMelder == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens" 
# Select the data: Only compare the current users and never users
data_selected = data[data$nomem_encr %in% data_currentvsneveruser$nomem_encr, ]
data_selected$user_status = droplevels(data_selected$user_status)

# Convert into a table that can be used for the chi square test
chisq.table = table(data_selected$HBM_barriers_CoronaMelder_agree, data_selected$user_status)
chisqtest = chisq.test(chisq.table) 
```
De chi kwadraat toets (X²(`r chisqtest$parameter`) = `r round(chisqtest$statistic, digits = 2)`, p `r ifelse(chisqtest$p.value < 0.001, "<0.001", paste("=", round(chisqtest$p.value, digits = 3)))`) liet zien dat er `r if(chisqtest$p.value > 0.05){"g"}`een significant verschil was in het percentage gebruikers (`r round((nrow(filter(data_selected, (user_status == 'Gebruiker'& HBM_barriers_CoronaMelder_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status == 'Gebruiker'))))*100, digits = 1)`%) dat aangaf het eens te zijn met de stelling dat het gebruik van de CoronaMelder persoonlijke nadelen heeft, vergeleken met degenen die de app nooit hebben gebruikt (`r round((nrow(filter(data_selected, (user_status == 'Niet gebruiker' & HBM_barriers_CoronaMelder_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status == 'Niet gebruiker'))))*100, digits = 1)`%).  

```{r chiHBMbarriersCoronaMelderutautusernonuserneutral, echo=FALSE}
# First calculate a proportion for the variable. 
data$HBM_barriers_CoronaMelder_agree[(data$HBM_barriers_CoronaMelder == 'Helemaal mee eens'| data$HBM_barriers_CoronaMelder == 'Mee eens'| data$HBM_barriers_CoronaMelder == 'Een beetje mee eens')] <- "Totaal eens"
data$HBM_barriers_CoronaMelder_agree[(data$HBM_barriers_CoronaMelder == 'Neutraal'| data$HBM_barriers_CoronaMelder == 'Een beetje oneens'| data$HBM_barriers_CoronaMelder == 'Oneens'| data$HBM_barriers_CoronaMelder == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens" 
# Select the data: Only compare the current users and never users
data_selected = data[data$nomem_encr %in% data_currentvsneveruserneutral$nomem_encr, ]
data_selected$user_status_intention = droplevels(data_selected$user_status_intention)

# Convert into a table that can be used for the chi square test
chisq.table = table(data_selected$HBM_barriers_CoronaMelder_agree, data_selected$user_status_intention)
chisqtest = chisq.test(chisq.table) 
```

De chi kwadraat toets (X²(`r chisqtest$parameter`) = `r round(chisqtest$statistic, digits = 2)`, p `r ifelse(chisqtest$p.value < 0.001, "<0.001", paste("=", round(chisqtest$p.value, digits = 3)))`) liet zien dat er `r if(chisqtest$p.value > 0.05){"g"}`een significant verschil was in het percentage gebruikers (`r round((nrow(filter(data_selected, (user_status_intention == 'Gebruiker'& HBM_barriers_CoronaMelder_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status_intention == 'Gebruiker'))))*100, digits = 1)`%) dat aangaf het eens te zijn met de stelling dat het gebruik van de CoronaMelder persoonlijke nadelen heeft, vergeleken met degenen die de app nooit hebben gebruikt en daarnaast aangaven neutraal te zijn in hun intentie om de CoronaMelder te gaan gebruiken (`r round((nrow(filter(data_selected, (user_status_intention == 'Nooit gebruikt en neutraal' & HBM_barriers_CoronaMelder_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status_intention == 'Nooit gebruikt en neutraal'))))*100, digits = 1)`%). 

```{r chiBeliefsvoluntarinessusernonuser, echo=FALSE}
# First calculate a proportion for the variable. 
data$Beliefs_voluntariness_agree[(data$Beliefs_voluntariness == 'Helemaal mee eens'| data$Beliefs_voluntariness == 'Mee eens'| data$Beliefs_voluntariness == 'Een beetje mee eens')] <- "Totaal eens"
data$Beliefs_voluntariness_agree[(data$Beliefs_voluntariness == 'Neutraal'| data$Beliefs_voluntariness == 'Een beetje oneens'| data$Beliefs_voluntariness == 'Oneens'| data$Beliefs_voluntariness == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens" 
# Select the data: Only compare the current users and never users
data_selected = data[data$nomem_encr %in% data_currentvsneveruser$nomem_encr, ]
data_selected$user_status = droplevels(data_selected$user_status)

# Convert into a table that can be used for the chi square test
chisq.table = table(data_selected$Beliefs_voluntariness_agree, data_selected$user_status)
chisqtest = chisq.test(chisq.table) 
```
De chi kwadraat toets (X²(`r chisqtest$parameter`) = `r round(chisqtest$statistic, digits = 2)`, p `r ifelse(chisqtest$p.value < 0.001, "<0.001", paste("=", round(chisqtest$p.value, digits = 3)))`) liet zien dat er `r if(chisqtest$p.value > 0.05){"g"}`een significant verschil was in het percentage gebruikers (`r round((nrow(filter(data_selected, (user_status == 'Gebruiker'& Beliefs_voluntariness_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status == 'Gebruiker'))))*100, digits = 1)`%) dat aangaf het eens te zijn met de stelling zich verplicht te voelen om de CoronaMelder te gebruiken, vergeleken met degenen die de app nooit hebben gebruikt (`r round((nrow(filter(data_selected, (user_status == 'Niet gebruiker' & Beliefs_voluntariness_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status == 'Niet gebruiker'))))*100, digits = 1)`%).  

```{r chiBeliefsvoluntarinessusernonuserneutral, echo=FALSE}
# First calculate a proportion for the variable. 
data$Beliefs_voluntariness_agree[(data$Beliefs_voluntariness == 'Helemaal mee eens'| data$Beliefs_voluntariness == 'Mee eens'| data$Beliefs_voluntariness == 'Een beetje mee eens')] <- "Totaal eens"
data$Beliefs_voluntariness_agree[(data$Beliefs_voluntariness == 'Neutraal'| data$Beliefs_voluntariness == 'Een beetje oneens'| data$Beliefs_voluntariness == 'Oneens'| data$Beliefs_voluntariness == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens" 
# Select the data: Only compare the current users and never users
data_selected = data[data$nomem_encr %in% data_currentvsneveruserneutral$nomem_encr, ]
data_selected$user_status_intention = droplevels(data_selected$user_status_intention)

# Convert into a table that can be used for the chi square test
chisq.table = table(data_selected$Beliefs_voluntariness_agree, data_selected$user_status_intention)
chisqtest = chisq.test(chisq.table) 
```

De chi kwadraat toets (X²(`r chisqtest$parameter`) = `r round(chisqtest$statistic, digits = 2)`, p `r ifelse(chisqtest$p.value < 0.001, "<0.001", paste("=", round(chisqtest$p.value, digits = 3)))`) liet zien dat er `r if(chisqtest$p.value > 0.05){"g"}`een significant verschil was in het percentage gebruikers (`r round((nrow(filter(data_selected, (user_status_intention == 'Gebruiker'& Beliefs_voluntariness_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status_intention == 'Gebruiker'))))*100, digits = 1)`%) dat aangaf het eens te zijn met de stelling zich verplicht te voelen om de CoronaMelder te gebruiken, vergeleken met degenen die de app nooit hebben gebruikt en daarnaast aangaven neutraal te zijn in hun intentie om de CoronaMelder te gaan gebruiken (`r round((nrow(filter(data_selected, (user_status_intention == 'Nooit gebruikt en neutraal' & Beliefs_voluntariness_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status_intention == 'Nooit gebruikt en neutraal'))))*100, digits = 1)`%). 


```{r, echo=FALSE, tab.cap ="Persoonlijke voor- en nadelen van gebruik en verplichting tot gebruik naar gebruikersstatus. Aantal en totaal percentage eens (beetje mee eens, eens, helemaal mee eens)."}

# === EDIT THESE TO CUSTOMIZE TABLE ===

# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("HBM_perceivedbenefits_CoronaMelder",
                        "HBM_barriers_CoronaMelder", 
                        "Beliefs_voluntariness")
graph_questionlabels = c("Het heeft voor mij persoonlijke voordelen om de CoronaMelder te gebruiken",
                         "Het heeft voor mij persoonlijke nadelen om de CoronaMelder te gebruiken", 
                         "Ik voel me verplicht om de CoronaMelder te gebruiken"); 



# Which values do we want to include in the table cells?
include_vars = c("Helemaal mee eens", "Mee eens", "Een beetje mee eens")

# === NO MORE EDITS SHOULD BE NEEDED BELOW THIS POINT ===

# Split by user groups
data_grouptable = data.frame(matrix(ncol = length(colnames(user_totals))+1, nrow = length(graph_variablenames)))

colnames(data_grouptable) <- c("variable", usergroup_names)

# Set the values for each variable. Note: this still contains too much logic right now, the values that are counted 
# as correct (in this case "Helemaal mee eens", "Mee eens", and "Een beetje mee eens") are manually added
# and will not apply to all variables (sometimes it is "Waar", or a different likert-scale)
for(idx in 1:length(graph_variablenames)) {
  data_grouptable[idx,"variable"] = graph_questionlabels[idx]
  
  data_grouptable[idx,2] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status == "Gebruiker"))
  
  data_grouptable[idx,3] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status == "Niet gebruiker"))

  data_grouptable[idx,4] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status_intention == "Nooit gebruikt en niet van plan"))

  data_grouptable[idx,5] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status_intention == "Nooit gebruikt en neutraal"))

  data_grouptable[idx,6] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status_intention == "Nooit gebruikt en wel van plan"))
}

# Build the basic table
ft <- flextable(
  head(data_grouptable, n = nrow(data_grouptable))
)

# Header labels
tmp_labels = as.data.frame(t(c("", usergroup_labels)))
colnames(tmp_labels) <- c("variable", usergroup_names)
ft <- set_header_labels(ft, values = tmp_labels)

# Set up the footer of totals
totals = c("Totaal", user_totals)
totals[-1] <- paste(totals[-1], " (100.0%)")

# Percentages and totals
for(colname in colnames(data_grouptable)) {
  if(colname != "variable") {
    # Add percentage to cell
    if (user_totals[1,colname]==0) {
      ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (0.0%)"))
    }
    else {
      ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (", sprintf("%.1f", eval(parse(text=colname))/user_totals[1,colname]*100), "%)"))
    }
    
  }
}

# Actually add the footer with totals
ft <- add_footer_row(ft, values = totals, colwidths = rep(1, length(totals)))

# Change layout of table, and footer specifically
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "right", part = "footer")
ft <- padding(ft, padding = 5, part = "footer")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.

# Note: 7 inch is the page width in Word
# We now divide this into 1.5 inch for the first column (the values),
# and divide the other columns equally among the remaining 5.5 inch.
# If you only have one or few columns, you might want to reduce the total width below:
table_width <- 7

# Set width
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 1.5)
ft_out <- width(ft_out, j = -1, width = (table_width-1.5)/(length(colnames(data_grouptable))-1))

ft_out

```

### Affectieve reacties
In kaart is gebracht in welke mate de CoronaMelder in het algemeen en meer specifiek het ontvangen van een melding een emotionele reaktie opwekt. Bijna een kwart geeft aan de CoronaMelder eng te vinden (`r round((nrow(filter(data, (Beliefs_fear == 'Helemaal mee eens'| Beliefs_fear == 'Mee eens'| Beliefs_fear == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`%) en 
`r round((nrow(filter(data, (Beliefs_fear == 'Neutraal'))) /nrow(data))*100, digits = 1)`% staat hier neutraal tegenover. Een iets groter aandeel zou angstig worden bij het ontvangen van een melding (`r round((nrow(filter(data, (Beliefs_notificationfear == 'Helemaal mee eens'| Beliefs_notificationfear == 'Mee eens'| Beliefs_notificationfear == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`%) en `r round((nrow(filter(data, (Beliefs_notificationfear == 'Neutraal'))) /nrow(data))*100, digits = 1)`% staat hier neutraal in.

```{r Affective, echo=FALSE, fig.width=7, fig.height=2, fig.cap="Affectieve reacties", tab.cap="Affectieve reacties"}
# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("Beliefs_fear", 
                        "Beliefs_notificationfear")
graph_questionlabels = c("Ik vind de CoronaMelder eng", 
                         "Ik zou angstig worden als ik een melding ontvang van de CoronaMelder"); 

# These questions have 7 answer categories: Helemaal mee eens - Helemaal mee oneens. The following color palette should be used:
color_palette = my_palette7
# Order of the question categories: first = most green, last = most red # Check if the answer categories match with the codebook (e.g, sometimes also 'weet ik niet is one of the answeroptions')
graph_answercategories = c("Helemaal mee eens", "Mee eens", "Een beetje mee eens", "Neutraal", "Een beetje oneens", "Oneens", "Helemaal mee oneens"); 

# Create a dataframe for the plot
#First only keep the variables you wish to keep. Note: nomem_enc is the participant id
data_graph_wideformat = select(data, nomem_encr, all_of(graph_variablenames))

#Convert it to long format
data_graph_longformat = melt(data_graph_wideformat, id.vars = c('nomem_encr'), measure.vars = graph_variablenames)

# Set the correct ordering of the questions (by default the first variable is placed on the bottom)
data_graph_longformat$variable <- factor(data_graph_longformat$variable,levels = rev(graph_variablenames))

# Also invert the order of the question labels (as default is that the first element of the vector is placed on the bottom)
graph_questionlabels = rev(graph_questionlabels)

# Set the correct ordering of the answer categories (by default on alphabetic order)
data_graph_longformat$value <- factor(data_graph_longformat$value,levels = graph_answercategories)

# Create the plot
theplot <- ggplot(data=data_graph_longformat, aes(fill=value, x=variable)) + theme_bw() + geom_bar(aes(y = (..count..)/sum(..count..)*length(graph_variablenames))) + scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1)) + coord_flip() + labs(x = "", y = "", fill = "") + scale_fill_manual(values=color_palette, drop=FALSE, labels=stringr::str_wrap(graph_answercategories, width = 10)) + scale_x_discrete(labels=stringr::str_wrap(graph_questionlabels, width = 30)) + theme(plot.margin = margin(0, 0, 0, 0), legend.text=element_text(size=8))

aligned <- align_plots(baseplot, theplot, align="v")
ggdraw(aligned[[2]])

# Create the table. Step 1: new data frame containing counts
data_table = data.frame(matrix(0, ncol = 0, nrow = length(levels(data[[graph_variablenames[1]]]))))

# We need one extra (empty) column label for the row with the possible values
table_questionlabels = list()
table_questionlabels["table_answercategories"] <- ""

# We also need the 'unreversed' question labels ;)
graph_questionlabels_unrev <- rev(graph_questionlabels)

# Inefficient loop, but it does a lot for us: add the counts as columns to the dataframe,
# and add the correct labels for column headings
for(idx in 1:length(graph_variablenames)) {
  
  if (idx == 1) {
    data_table["table_answercategories"] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[1]
  }
  
  # Add to new dataframe
  data_table[graph_variablenames[idx]] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[2]
  
  # Add correct mapping to column headings
  table_questionlabels[graph_variablenames[idx]] <- graph_questionlabels_unrev[idx]
}




# Build the basic table
ft <- flextable(
  head(data_table, n = nrow(data_table))
)

# Header labels
ft <- set_header_labels(ft, values = table_questionlabels)

# Set up the footer of totals
totals = c("Totaal")

# Percentages and totals
for(colname in colnames(data_table)) {
  if(colname != "table_answercategories") {
    # Add percentage to cell
    ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (", sprintf("%.1f", eval(parse(text=colname))/sum(eval(parse(text=colname)))*100), "%)"))
    
    # Add total to footer
    tablecolumn = paste("data_table$", colname)
    totals <- c(totals, paste(sum(eval(parse(text=tablecolumn))), " (100%)"))
  }
}

# Actually add the footer with totals
ft <- add_footer_row(ft, values = totals, colwidths = rep(1, length(totals)))

# Change layout of table, and footer specifically
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "right", part = "footer")
ft <- padding(ft, padding = 5, part = "footer")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.

# Note: 7 inch is the page width in Word
# We now divide this into 1.5 inch for the first column (the values),
# and divide the other columns equally among the remaining 5.5 inch.
# If you only have one or few columns, you might want to reduce the total width below:
table_width <- 7

# Set width
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 1.5)
ft_out <- width(ft_out, j = -1, width = (table_width-1.5)/(length(colnames(data_table))-1))

ft_out
```
#### Affectieve reakties naar gebruikersstatus
```{r chiBeliefs_fearusernonuser, echo=FALSE}
# First calculate a proportion for the variable. 
data$Beliefs_fear_agree[(data$Beliefs_fear == 'Helemaal mee eens'| data$Beliefs_fear == 'Mee eens'| data$Beliefs_fear == 'Een beetje mee eens')] <- "Totaal eens"
data$Beliefs_fear_agree[(data$Beliefs_fear == 'Neutraal'| data$Beliefs_fear == 'Een beetje oneens'| data$Beliefs_fear == 'Oneens'| data$Beliefs_fear == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens" 
# Select the data: Only compare the current users and never users
data_selected = data[data$nomem_encr %in% data_currentvsneveruser$nomem_encr, ]
data_selected$user_status = droplevels(data_selected$user_status)

# Convert into a table that can be used for the chi square test
chisq.table = table(data_selected$Beliefs_fear_agree, data_selected$user_status)
chisqtest = chisq.test(chisq.table) 
```
De chi kwadraat toets (X²(`r chisqtest$parameter`) = `r round(chisqtest$statistic, digits = 2)`, p `r ifelse(chisqtest$p.value < 0.001, "<0.001", paste("=", round(chisqtest$p.value, digits = 3)))`) liet zien dat er `r if(chisqtest$p.value > 0.05){"g"}`een significant verschil was in het percentage gebruikers (`r round((nrow(filter(data_selected, (user_status == 'Gebruiker'& Beliefs_fear_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status == 'Gebruiker'))))*100, digits = 1)`%) dat aangaf het eens te zijn met de stelling dat ze de CoronaMelder eng vinden vergeleken met degenen die de app nooit hebben gebruikt (`r round((nrow(filter(data_selected, (user_status == 'Niet gebruiker' & Beliefs_fear_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status == 'Niet gebruiker'))))*100, digits = 1)`%).  

```{r chiBeliefs_fearusernonuserneutral, echo=FALSE}
# First calculate a proportion for the variable. 
data$Beliefs_fear_agree[(data$Beliefs_fear == 'Helemaal mee eens'| data$Beliefs_fear == 'Mee eens'| data$Beliefs_fear == 'Een beetje mee eens')] <- "Totaal eens"
data$Beliefs_fear_agree[(data$Beliefs_fear == 'Neutraal'| data$Beliefs_fear == 'Een beetje oneens'| data$Beliefs_fear == 'Oneens'| data$Beliefs_fear == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens" 
# Select the data: Only compare the current users and never users
data_selected = data[data$nomem_encr %in% data_currentvsneveruserneutral$nomem_encr, ]
data_selected$user_status_intention = droplevels(data_selected$user_status_intention)

# Convert into a table that can be used for the chi square test
chisq.table = table(data_selected$Beliefs_fear_agree, data_selected$user_status_intention)
chisqtest = chisq.test(chisq.table) 
```
De chi kwadraat toets (X²(`r chisqtest$parameter`) = `r round(chisqtest$statistic, digits = 2)`, p `r ifelse(chisqtest$p.value < 0.001, "<0.001", paste("=", round(chisqtest$p.value, digits = 3)))`) liet zien dat er `r if(chisqtest$p.value > 0.05){"g"}`een significant verschil was in het percentage gebruikers (`r round((nrow(filter(data_selected, (user_status_intention == 'Gebruiker'& Beliefs_fear_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status_intention == 'Gebruiker'))))*100, digits = 1)`%) dat aangaf het eens te zijn met de stelling dat ze de CoronaMelder eng vinden vergeleken met degenen die de app nooit hebben gebruikt en daarnaast aangaven neutraal te zijn in hun intentie om de CoronaMelder te gaan gebruiken (`r round((nrow(filter(data_selected, (user_status_intention == 'Nooit gebruikt en neutraal' & Beliefs_fear_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status_intention == 'Nooit gebruikt en neutraal'))))*100, digits = 1)`%). 

```{r chiBeliefs_notificationfearusernonuser, echo=FALSE}
# First calculate a proportion for the variable. 
data$Beliefs_notificationfear_agree[(data$Beliefs_notificationfear == 'Helemaal mee eens'| data$Beliefs_notificationfear == 'Mee eens'| data$Beliefs_notificationfear == 'Een beetje mee eens')] <- "Totaal eens"
data$Beliefs_notificationfear_agree[(data$Beliefs_notificationfear == 'Neutraal'| data$Beliefs_notificationfear == 'Een beetje oneens'| data$Beliefs_notificationfear == 'Oneens'| data$Beliefs_notificationfear == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens" 
# Select the data: Only compare the current users and never users
data_selected = data[data$nomem_encr %in% data_currentvsneveruser$nomem_encr, ]
data_selected$user_status = droplevels(data_selected$user_status)

# Convert into a table that can be used for the chi square test
chisq.table = table(data_selected$Beliefs_notificationfear_agree, data_selected$user_status)
chisqtest = chisq.test(chisq.table) 
```
De chi kwadraat toets (X²(`r chisqtest$parameter`) = `r round(chisqtest$statistic, digits = 2)`, p `r ifelse(chisqtest$p.value < 0.001, "<0.001", paste("=", round(chisqtest$p.value, digits = 3)))`) liet zien dat er `r if(chisqtest$p.value > 0.05){"g"}`een significant verschil was in het percentage gebruikers (`r round((nrow(filter(data_selected, (user_status == 'Gebruiker'& Beliefs_notificationfear_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status == 'Gebruiker'))))*100, digits = 1)`%) dat aangaf het eens te zijn met de stelling dat hij/zij angstig zou worden na het ontvangen van een melding van de CoronaMelder app vergeleken met degenen die de app nooit hebben gebruikt (`r round((nrow(filter(data_selected, (user_status == 'Niet gebruiker' & Beliefs_notificationfear_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status == 'Niet gebruiker'))))*100, digits = 1)`%).  

```{r chiBeliefs_notificationfearusernonuserneutral, echo=FALSE}
# First calculate a proportion for the variable. 
data$Beliefs_notificationfear_agree[(data$Beliefs_notificationfear == 'Helemaal mee eens'| data$Beliefs_notificationfear == 'Mee eens'| data$Beliefs_notificationfear == 'Een beetje mee eens')] <- "Totaal eens"
data$Beliefs_notificationfear_agree[(data$Beliefs_notificationfear == 'Neutraal'| data$Beliefs_notificationfear == 'Een beetje oneens'| data$Beliefs_notificationfear == 'Oneens'| data$Beliefs_notificationfear == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens" 
# Select the data: Only compare the current users and never users
data_selected = data[data$nomem_encr %in% data_currentvsneveruserneutral$nomem_encr, ]
data_selected$user_status_intention = droplevels(data_selected$user_status_intention)

# Convert into a table that can be used for the chi square test
chisq.table = table(data_selected$Beliefs_notificationfear_agree, data_selected$user_status_intention)
chisqtest = chisq.test(chisq.table) 
```

De chi kwadraat toets (X²(`r chisqtest$parameter`) = `r round(chisqtest$statistic, digits = 2)`, p `r ifelse(chisqtest$p.value < 0.001, "<0.001", paste("=", round(chisqtest$p.value, digits = 3)))`) liet zien dat er `r if(chisqtest$p.value > 0.05){"g"}`een significant verschil was in het percentage gebruikers (`r round((nrow(filter(data_selected, (user_status_intention == 'Gebruiker'& Beliefs_notificationfear_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status_intention == 'Gebruiker'))))*100, digits = 1)`%) dat aangaf het eens te zijn met de stelling dat hij/zij angstig zou worden na het ontvangen van een melding van de CoronaMelder app vergeleken met degenen die de app nooit hebben gebruikt en daarnaast aangaven neutraal te zijn in hun intentie om de CoronaMelder te gaan gebruiken (`r round((nrow(filter(data_selected, (user_status_intention == 'Nooit gebruikt en neutraal' & Beliefs_notificationfear_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status_intention == 'Nooit gebruikt en neutraal'))))*100, digits = 1)`%). 

```{r, echo=FALSE, tab.cap ="Affectieve reakties naar gebruikersstatus. Aantal en totaal percentage eens (beetje mee eens, eens, helemaal mee eens)."}

# === EDIT THESE TO CUSTOMIZE TABLE ===

# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("Beliefs_fear", 
                        "Beliefs_notificationfear")                     
graph_questionlabels = c("Ik vind de CoronaMelder app eng", 
                         "Ik zou angstig worden als ik een melding ontvang van de CoronaMelder app") 

# Which values do we want to include in the table cells?
include_vars = c("Helemaal mee eens", "Mee eens", "Een beetje mee eens")

# === NO MORE EDITS SHOULD BE NEEDED BELOW THIS POINT ===

# Split by user groups
data_grouptable = data.frame(matrix(ncol = length(colnames(user_totals))+1, nrow = length(graph_variablenames)))

colnames(data_grouptable) <- c("variable", usergroup_names)

# Set the values for each variable. Note: this still contains too much logic right now, the values that are counted 
# as correct (in this case "Helemaal mee eens", "Mee eens", and "Een beetje mee eens") are manually added
# and will not apply to all variables (sometimes it is "Waar", or a different likert-scale)
for(idx in 1:length(graph_variablenames)) {
  data_grouptable[idx,"variable"] = graph_questionlabels[idx]
  
  data_grouptable[idx,2] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status == "Gebruiker"))
  
  data_grouptable[idx,3] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status == "Niet gebruiker"))

  data_grouptable[idx,4] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status_intention == "Nooit gebruikt en niet van plan"))

  data_grouptable[idx,5] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status_intention == "Nooit gebruikt en neutraal"))

  data_grouptable[idx,6] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status_intention == "Nooit gebruikt en wel van plan"))
}

# Build the basic table
ft <- flextable(
  head(data_grouptable, n = nrow(data_grouptable))
)

# Header labels
tmp_labels = as.data.frame(t(c("", usergroup_labels)))
colnames(tmp_labels) <- c("variable", usergroup_names)
ft <- set_header_labels(ft, values = tmp_labels)

# Set up the footer of totals
totals = c("Totaal", user_totals)
totals[-1] <- paste(totals[-1], " (100.0%)")

# Percentages and totals
for(colname in colnames(data_grouptable)) {
  if(colname != "variable") {
    # Add percentage to cell
    if (user_totals[1,colname]==0) {
      ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (0.0%)"))
    }
    else {
      ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (", sprintf("%.1f", eval(parse(text=colname))/user_totals[1,colname]*100), "%)"))
    }
    
  }
}

# Actually add the footer with totals
ft <- add_footer_row(ft, values = totals, colwidths = rep(1, length(totals)))

# Change layout of table, and footer specifically
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "right", part = "footer")
ft <- padding(ft, padding = 5, part = "footer")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.

# Note: 7 inch is the page width in Word
# We now divide this into 1.5 inch for the first column (the values),
# and divide the other columns equally among the remaining 5.5 inch.
# If you only have one or few columns, you might want to reduce the total width below:
table_width <- 7

# Set width
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 1.5)
ft_out <- width(ft_out, j = -1, width = (table_width-1.5)/(length(colnames(data_grouptable))-1))

ft_out

```


### Sociale invloeden
Om de sociale invloeden in kaart te brengen is gevraagd naar descriptieve en injunctieve normen en is gevraagd om een indicatie te geven van welk percentage van de Nederlandse bevolking de CoronaMelder gebruikt. Opvallend is dat een relatief laag percentage (`r round((nrow(filter(data, (SI1_UTAUT == 'Helemaal mee eens'| SI1_UTAUT == 'Mee eens'| SI1_UTAUT == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`%) van de respondenten het eens is met de stelling dat veel mensen in hun omgeving de CoronaMelder gebruiken. Daarnaast staat een groot percentage neutraal tegenover deze stelling (`r round((nrow(filter(data, (SI1_UTAUT == 'Neutraal'))) /nrow(data))*100, digits = 1)`%).

Ook de injunctieve norm is nauwelijks aanwezig, bijna de helft is het oneens met de stelling 'Mensen in mijn directe omgeving vinden dat ik de CoronaMelder moet gebruiken' (`r round((nrow(filter(data, (SI2_UTAUT == 'Helemaal mee oneens'| SI2_UTAUT == 'Oneens'| SI2_UTAUT == 'Een beetje oneens'))) /nrow(data))*100, digits = 1)`%), en ook een aanzienlijk percentage staat hier neutraal in (`r round((nrow(filter(data, (SI2_UTAUT == 'Neutraal'))) /nrow(data))*100, digits = 1)`%). Van de respondenten is `r round((nrow(filter(data, (Beliefs_civicduty == 'Helemaal mee eens'| Beliefs_civicduty == 'Mee eens'| Beliefs_civicduty == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`% het eens met de stelling dat de CoronaMelder je een goede burger maakt.

```{r Socialnormscivicduty, echo=FALSE, fig.width=7, fig.height=2, fig.cap="Sociale normen", tab.cap="Sociale normen"}
# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("SI1_UTAUT", 
                        "SI2_UTAUT",
                        "Beliefs_civicduty")
graph_questionlabels = c("Veel mensen in mijn omgeving gebruiken de CoronaMelder", 
                         "Mensen in mijn directe omgeving vinden dat ik de CoronaMelder moet gebruiken",
                         "Het gebruiken van de CoronaMelder maakt je een goede burger"); 

# These questions have 7 answer categories: Helemaal mee eens - Helemaal mee oneens. The following color palette should be used:
color_palette = my_palette7
# Order of the question categories: first = most green, last = most red # Check if the answer categories match with the codebook (e.g, sometimes also 'weet ik niet is one of the answeroptions')
graph_answercategories = c("Helemaal mee eens", "Mee eens", "Een beetje mee eens", "Neutraal", "Een beetje oneens", "Oneens", "Helemaal mee oneens"); 

# Create a dataframe for the plot
#First only keep the variables you wish to keep. Note: nomem_enc is the participant id
data_graph_wideformat = select(data, nomem_encr, all_of(graph_variablenames))

#Convert it to long format
data_graph_longformat = melt(data_graph_wideformat, id.vars = c('nomem_encr'), measure.vars = graph_variablenames)

# Set the correct ordering of the questions (by default the first variable is placed on the bottom)
data_graph_longformat$variable <- factor(data_graph_longformat$variable,levels = rev(graph_variablenames))

# Also invert the order of the question labels (as default is that the first element of the vector is placed on the bottom)
graph_questionlabels = rev(graph_questionlabels)

# Set the correct ordering of the answer categories (by default on alphabetic order)
data_graph_longformat$value <- factor(data_graph_longformat$value,levels = graph_answercategories)

# Create the plot
theplot <- ggplot(data=data_graph_longformat, aes(fill=value, x=variable)) + theme_bw() + geom_bar(aes(y = (..count..)/sum(..count..)*length(graph_variablenames))) + scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1)) + coord_flip() + labs(x = "", y = "", fill = "") + scale_fill_manual(values=color_palette, drop=FALSE, labels=stringr::str_wrap(graph_answercategories, width = 10)) + scale_x_discrete(labels=stringr::str_wrap(graph_questionlabels, width = 30)) + theme(plot.margin = margin(0, 0, 0, 0), legend.text=element_text(size=8))

aligned <- align_plots(baseplot, theplot, align="v")
ggdraw(aligned[[2]])

# Create the table. Step 1: new data frame containing counts
data_table = data.frame(matrix(0, ncol = 0, nrow = length(levels(data[[graph_variablenames[1]]]))))

# We need one extra (empty) column label for the row with the possible values
table_questionlabels = list()
table_questionlabels["table_answercategories"] <- ""

# We also need the 'unreversed' question labels ;)
graph_questionlabels_unrev <- rev(graph_questionlabels)

# Inefficient loop, but it does a lot for us: add the counts as columns to the dataframe,
# and add the correct labels for column headings
for(idx in 1:length(graph_variablenames)) {
  if (idx == 1) {
    data_table["table_answercategories"] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[1]
  }
  
  # Add to new dataframe
  data_table[graph_variablenames[idx]] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[2]
  
  # Add correct mapping to column headings
  table_questionlabels[graph_variablenames[idx]] <- graph_questionlabels_unrev[idx]
}




# Build the basic table
ft <- flextable(
  head(data_table, n = nrow(data_table))
)

# Header labels
ft <- set_header_labels(ft, values = table_questionlabels)

# Set up the footer of totals
totals = c("Totaal")

# Percentages and totals
for(colname in colnames(data_table)) {
  if(colname != "table_answercategories") {
    # Add percentage to cell
    ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (", sprintf("%.1f", eval(parse(text=colname))/sum(eval(parse(text=colname)))*100), "%)"))
    
    # Add total to footer
    tablecolumn = paste("data_table$", colname)
    totals <- c(totals, paste(sum(eval(parse(text=tablecolumn))), " (100%)"))
  }
}

# Actually add the footer with totals
ft <- add_footer_row(ft, values = totals, colwidths = rep(1, length(totals)))

# Change layout of table, and footer specifically
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "right", part = "footer")
ft <- padding(ft, padding = 5, part = "footer")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.

# Note: 7 inch is the page width in Word
# We now divide this into 1.5 inch for the first column (the values),
# and divide the other columns equally among the remaining 5.5 inch.
# If you only have one or few columns, you might want to reduce the total width below:
table_width <- 7

# Set width
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 1.5)
ft_out <- width(ft_out, j = -1, width = (table_width-1.5)/(length(colnames(data_table))-1))

ft_out
```

Er werd ook gevraagd aan de respondenten hoeveel procent van de Nederlandse bevolking zij dachten dat de CoronaMelder gebruikt. De meeste respondenten (`r round((nrow(filter(data, (Beliefs_AppAdoption == '26-50%'))) /nrow(data))*100, digits = 1)`%) dachten dat tussen de 26 en 50% van de bevolking de CoronaMelder gebruikt, gevolgd door de categorie van 11 tot 25% (`r round((nrow(filter(data, (Beliefs_AppAdoption == '11-25%'))) /nrow(data))*100, digits = 1)`%).


```{r Beliefsappadoption, echo=FALSE, fig.width=5.5, fig.height=3, fig.cap="Percentage Nederlandse bevolking dat volgens de respondent de CoronaMelder gebruikt", tab.cap="Percentage Nederlandse bevolking dat volgens de respondent de CoronaMelder gebruikt"}
ggplot(data=data, aes(x = Beliefs_AppAdoption)) + theme_bw() + xlab(paste(names(table(data$Beliefs_AppAdoption)))) + ylab(" ") + xlab("") + geom_bar(fill = "#bdd7e7", color = "#6baed6") + theme(plot.margin = margin(0, 0.1, 0, 0)) + theme(axis.title=element_text(size=10))

graph_variablenames = "Beliefs_AppAdoption"
graph_questionlabels = "Hoeveel procent van de Nederlandse bevolking denkt u dat de CoronaMelder app gebruikt?"

# Create the table. Step 1: new data frame containing counts
data_table = data.frame(matrix(0, ncol = 0, nrow = length(levels(data[[graph_variablenames[1]]]))))

# We need one extra (empty) column label for the row with the possible values
table_questionlabels = list()
table_questionlabels["table_answercategories"] <- ""

# We also need the 'unreversed' question labels ;)
graph_questionlabels_unrev <- rev(graph_questionlabels)

# Inefficient loop, but it does a lot for us: add the counts as columns to the dataframe,
# and add the correct labels for column headings
for(idx in 1:length(graph_variablenames)) {
  if (idx == 1) {
    data_table["table_answercategories"] <- as.data.frame(table(data[graph_variablenames[idx]]))[1]
  }
  
  # Add to new dataframe
  data_table[graph_variablenames[idx]] <- as.data.frame(table(data[graph_variablenames[idx]]))[2]
  
  # Add correct mapping to column headings
  table_questionlabels[graph_variablenames[idx]] <- graph_questionlabels_unrev[idx]
}

# Build the basic table
ft <- flextable(
  head(data_table, n = nrow(data_table))
)

# Header labels
ft <- set_header_labels(ft, values = table_questionlabels)

# Set up the footer of totals
totals = c("Totaal")

# Percentages and totals
for(colname in colnames(data_table)) {
  if(colname != "table_answercategories") {
    # Add percentage to cell
    ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (", sprintf("%.1f", eval(parse(text=colname))/sum(eval(parse(text=colname)))*100), "%)"))
    
    # Add total to footer
    tablecolumn = paste("data_table$", colname)
    totals <- c(totals, paste(sum(eval(parse(text=tablecolumn))), " (100%)"))
  }
}

# Actually add the footer with totals
ft <- add_footer_row(ft, values = totals, colwidths = rep(1, length(totals)))

# Change layout of table, and footer specifically
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "right", part = "footer")
ft <- padding(ft, padding = 5, part = "footer")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.

# Note: 7 inch is the page width in Word
# We now divide this into 1.5 inch for the first column (the values),
# and divide the other columns equally among the remaining 5.5 inch.
# If you only have one or few columns, you might want to reduce the total width below:
table_width <- 7

# Set width
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 1.5)
ft_out <- width(ft_out, j = -1, width = (table_width-1.5)/(length(colnames(data_table))-1))

ft_out
```


#### Sociale invloeden naar gebruikersstatus
Chi kwadraat toetsen zijn uitgevoerd om te bepalen of het totaal aandeel respondenten dat het eens  (een beetje, eens, helemaal mee eens) is met de stellingen verschilt tussen de huidige gebruikers en degenen die de CoronaMelder nooit gebruikt hebben. Daarnaast is gekeken of de subgroep die de CoronaMelder nooit gebruikt heeft en aangaf neutraal te zijn met betrekking tot toekomstig gebruik verschilt van de huidig gebruikers. 
```{r chiSI1utautusernonuser, echo=FALSE}
# First calculate a proportion for the variable. 
data$SI1_UTAUT_agree[(data$SI1_UTAUT == 'Helemaal mee eens'| data$SI1_UTAUT == 'Mee eens'| data$SI1_UTAUT == 'Een beetje mee eens')] <- "Totaal eens"
data$SI1_UTAUT_agree[(data$SI1_UTAUT == 'Neutraal'| data$SI1_UTAUT == 'Een beetje oneens'| data$SI1_UTAUT == 'Oneens'| data$SI1_UTAUT == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens" 
# Select the data: Only compare the current users and never users
data_selected = data[data$nomem_encr %in% data_currentvsneveruser$nomem_encr, ]
data_selected$user_status = droplevels(data_selected$user_status)

# Convert into a table that can be used for the chi square test
chisq.table = table(data_selected$SI1_UTAUT_agree, data_selected$user_status)
chisqtest = chisq.test(chisq.table) 
```
De chi kwadraat toets (X²(`r chisqtest$parameter`) = `r round(chisqtest$statistic, digits = 2)`, p `r ifelse(chisqtest$p.value < 0.001, "<0.001", paste("=", round(chisqtest$p.value, digits = 3)))`) liet zien dat er `r if(chisqtest$p.value > 0.05){"g"}`een significant verschil was in het percentage gebruikers (`r round((nrow(filter(data_selected, (user_status == 'Gebruiker'& SI1_UTAUT_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status == 'Gebruiker'))))*100, digits = 1)`%) dat aangaf het eens te zijn met de stelling dat veel mensen in de omgeving de CoronaMelder gebruiken vergeleken met degenen die de app nooit hebben gebruikt (`r round((nrow(filter(data_selected, (user_status == 'Niet gebruiker' & SI1_UTAUT_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status == 'Niet gebruiker'))))*100, digits = 1)`%).  

```{r chiSI1utautusernonuserneutral, echo=FALSE}
# First calculate a proportion for the variable. 
data$SI1_UTAUT_agree[(data$SI1_UTAUT == 'Helemaal mee eens'| data$SI1_UTAUT == 'Mee eens'| data$SI1_UTAUT == 'Een beetje mee eens')] <- "Totaal eens"
data$SI1_UTAUT_agree[(data$SI1_UTAUT == 'Neutraal'| data$SI1_UTAUT == 'Een beetje oneens'| data$SI1_UTAUT == 'Oneens'| data$SI1_UTAUT == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens" 
# Select the data: Only compare the current users and never users
data_selected = data[data$nomem_encr %in% data_currentvsneveruserneutral$nomem_encr, ]
data_selected$user_status_intention = droplevels(data_selected$user_status_intention)

# Convert into a table that can be used for the chi square test
chisq.table = table(data_selected$SI1_UTAUT_agree, data_selected$user_status_intention)
chisqtest = chisq.test(chisq.table) 
```
De chi kwadraat toets (X²(`r chisqtest$parameter`) = `r round(chisqtest$statistic, digits = 2)`, p `r ifelse(chisqtest$p.value < 0.001, "<0.001", paste("=", round(chisqtest$p.value, digits = 3)))`) liet zien dat er `r if(chisqtest$p.value > 0.05){"g"}`een significant verschil was in het percentage gebruikers (`r round((nrow(filter(data_selected, (user_status_intention == 'Gebruiker'& SI1_UTAUT_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status_intention == 'Gebruiker'))))*100, digits = 1)`%) dat aangaf het eens te zijn met de stelling dat veel mensen in de omgeving de CoronaMelder gebruiken vergeleken met degenen die de app nooit hebben gebruikt en daarnaast aangaven neutraal te zijn in hun intentie om de CoronaMelder te gaan gebruiken (`r round((nrow(filter(data_selected, (user_status_intention == 'Nooit gebruikt en neutraal' & SI1_UTAUT_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status_intention == 'Nooit gebruikt en neutraal'))))*100, digits = 1)`%). 

```{r chiSI2utautusernonuser, echo=FALSE}
# First calculate a proportion for the variable. 
data$SI2_UTAUT_agree[(data$SI2_UTAUT == 'Helemaal mee eens'| data$SI2_UTAUT == 'Mee eens'| data$SI2_UTAUT == 'Een beetje mee eens')] <- "Totaal eens"
data$SI2_UTAUT_agree[(data$SI2_UTAUT == 'Neutraal'| data$SI2_UTAUT == 'Een beetje oneens'| data$SI2_UTAUT == 'Oneens'| data$SI2_UTAUT == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens" 
# Select the data: Only compare the current users and never users
data_selected = data[data$nomem_encr %in% data_currentvsneveruser$nomem_encr, ]
data_selected$user_status = droplevels(data_selected$user_status)

# Convert into a table that can be used for the chi square test
chisq.table = table(data_selected$SI2_UTAUT_agree, data_selected$user_status)
chisqtest = chisq.test(chisq.table) 
```
De chi kwadraat toets (X²(`r chisqtest$parameter`) = `r round(chisqtest$statistic, digits = 2)`, p `r ifelse(chisqtest$p.value < 0.001, "<0.001", paste("=", round(chisqtest$p.value, digits = 3)))`) liet zien dat er `r if(chisqtest$p.value > 0.05){"g"}`een significant verschil was in het percentage gebruikers (`r round((nrow(filter(data_selected, (user_status == 'Gebruiker'& SI2_UTAUT_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status == 'Gebruiker'))))*100, digits = 1)`%) dat aangaf het eens te zijn met de stelling dat veel mensen in de omgeving vinden dat hij/zij de CoronaMelder moet gebruiken vergeleken met degenen die de app nooit hebben gebruikt (`r round((nrow(filter(data_selected, (user_status == 'Niet gebruiker' & SI2_UTAUT_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status == 'Niet gebruiker'))))*100, digits = 1)`%).  

```{r chiSI2utautusernonuserneutral, echo=FALSE}
# First calculate a proportion for the variable. 
data$SI2_UTAUT_agree[(data$SI2_UTAUT == 'Helemaal mee eens'| data$SI2_UTAUT == 'Mee eens'| data$SI2_UTAUT == 'Een beetje mee eens')] <- "Totaal eens"
data$SI2_UTAUT_agree[(data$SI2_UTAUT == 'Neutraal'| data$SI2_UTAUT == 'Een beetje oneens'| data$SI2_UTAUT == 'Oneens'| data$SI2_UTAUT == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens" 
# Select the data: Only compare the current users and never users
data_selected = data[data$nomem_encr %in% data_currentvsneveruserneutral$nomem_encr, ]
data_selected$user_status_intention = droplevels(data_selected$user_status_intention)

# Convert into a table that can be used for the chi square test
chisq.table = table(data_selected$SI2_UTAUT_agree, data_selected$user_status_intention)
chisqtest = chisq.test(chisq.table) 
```

De chi kwadraat toets (X²(`r chisqtest$parameter`) = `r round(chisqtest$statistic, digits = 2)`, p `r ifelse(chisqtest$p.value < 0.001, "<0.001", paste("=", round(chisqtest$p.value, digits = 3)))`) liet zien dat er `r if(chisqtest$p.value > 0.05){"g"}`een significant verschil was in het percentage gebruikers (`r round((nrow(filter(data_selected, (user_status_intention == 'Gebruiker'& SI2_UTAUT_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status_intention == 'Gebruiker'))))*100, digits = 1)`%) dat aangaf het eens te zijn met de stelling dat veel mensen in de omgeving vinden dat hij/zij de CoronaMelder moet gebruiken vergeleken met degenen die de app nooit hebben gebruikt en daarnaast aangaven neutraal te zijn in hun intentie om de CoronaMelder te gaan gebruiken (`r round((nrow(filter(data_selected, (user_status_intention == 'Nooit gebruikt en neutraal' & SI2_UTAUT_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status_intention == 'Nooit gebruikt en neutraal'))))*100, digits = 1)`%). 

```{r chiBeliefscivicdutyusernonuser, echo=FALSE}
# First calculate a proportion for the variable. 
data$Beliefs_civicduty_agree[(data$Beliefs_civicduty == 'Helemaal mee eens'| data$Beliefs_civicduty == 'Mee eens'| data$Beliefs_civicduty == 'Een beetje mee eens')] <- "Totaal eens"
data$Beliefs_civicduty_agree[(data$Beliefs_civicduty == 'Neutraal'| data$Beliefs_civicduty == 'Een beetje oneens'| data$Beliefs_civicduty == 'Oneens'| data$Beliefs_civicduty == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens" 
# Select the data: Only compare the current users and never users
data_selected = data[data$nomem_encr %in% data_currentvsneveruser$nomem_encr, ]
data_selected$user_status = droplevels(data_selected$user_status)

# Convert into a table that can be used for the chi square test
chisq.table = table(data_selected$Beliefs_civicduty_agree, data_selected$user_status)
chisqtest = chisq.test(chisq.table) 
```
De chi kwadraat toets (X²(`r chisqtest$parameter`) = `r round(chisqtest$statistic, digits = 2)`, p `r ifelse(chisqtest$p.value < 0.001, "<0.001", paste("=", round(chisqtest$p.value, digits = 3)))`) liet zien dat er `r if(chisqtest$p.value > 0.05){"g"}`een significant verschil was in het percentage gebruikers (`r round((nrow(filter(data_selected, (user_status == 'Gebruiker'& Beliefs_civicduty_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status == 'Gebruiker'))))*100, digits = 1)`%) dat aangaf het eens te zijn met de stelling dat het gebruiken van de CoronaMelder je een goed burger maakt vergeleken met degenen die de app nooit hebben gebruikt (`r round((nrow(filter(data_selected, (user_status == 'Niet gebruiker' & Beliefs_civicduty_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status == 'Niet gebruiker'))))*100, digits = 1)`%).  

```{r chiBeliefscivicdutyusernonuserneutral, echo=FALSE}
# First calculate a proportion for the variable. 
data$Beliefs_civicduty_agree[(data$Beliefs_civicduty == 'Helemaal mee eens'| data$Beliefs_civicduty == 'Mee eens'| data$Beliefs_civicduty == 'Een beetje mee eens')] <- "Totaal eens"
data$Beliefs_civicduty_agree[(data$Beliefs_civicduty == 'Neutraal'| data$Beliefs_civicduty == 'Een beetje oneens'| data$Beliefs_civicduty == 'Oneens'| data$Beliefs_civicduty == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens" 
# Select the data: Only compare the current users and never users
data_selected = data[data$nomem_encr %in% data_currentvsneveruserneutral$nomem_encr, ]
data_selected$user_status_intention = droplevels(data_selected$user_status_intention)

# Convert into a table that can be used for the chi square test
chisq.table = table(data_selected$Beliefs_civicduty_agree, data_selected$user_status_intention)
chisqtest = chisq.test(chisq.table) 
```
De chi kwadraat toets (X²(`r chisqtest$parameter`) = `r round(chisqtest$statistic, digits = 2)`, p `r ifelse(chisqtest$p.value < 0.001, "<0.001", paste("=", round(chisqtest$p.value, digits = 3)))`) liet zien dat er `r if(chisqtest$p.value > 0.05){"g"}`een significant verschil was in het percentage gebruikers (`r round((nrow(filter(data_selected, (user_status_intention == 'Gebruiker'& Beliefs_civicduty_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status_intention == 'Gebruiker'))))*100, digits = 1)`%) dat aangaf het eens te zijn met de stelling dat het gebruiken van de CoronaMelder je een goed burger maakt vergeleken met degenen die de app nooit hebben gebruikt en daarnaast aangaven neutraal te zijn in hun intentie om de CoronaMelder te gaan gebruiken (`r round((nrow(filter(data_selected, (user_status_intention == 'Nooit gebruikt en neutraal' & Beliefs_civicduty_agree == 'Totaal eens'))) /nrow(filter(data_selected, (user_status_intention == 'Nooit gebruikt en neutraal'))))*100, digits = 1)`%). 


```{r, echo=FALSE, tab.cap ="Sociale normen naar gebruikersstatus. Aantal en totaal percentage eens (beetje mee eens, eens, helemaal mee eens)."}

# === EDIT THESE TO CUSTOMIZE TABLE ===

# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("SI1_UTAUT", 
                        "SI2_UTAUT", 
                        "Beliefs_civicduty")                     
graph_questionlabels = c("Veel mensen in mijn omgeving gebruiken de CoronaMelder app", 
                         "Mensen in mijn directe omgeving vinden dat ik de CoronaMelder app moet gebruiken", 
                         "Het gebruiken van de CoronaMelder maakt je een goed burger") 

# Which values do we want to include in the table cells?
include_vars = c("Helemaal mee eens", "Mee eens", "Een beetje mee eens")

# === NO MORE EDITS SHOULD BE NEEDED BELOW THIS POINT ===

# Split by user groups
data_grouptable = data.frame(matrix(ncol = length(colnames(user_totals))+1, nrow = length(graph_variablenames)))

colnames(data_grouptable) <- c("variable", usergroup_names)

# Set the values for each variable. Note: this still contains too much logic right now, the values that are counted 
# as correct (in this case "Helemaal mee eens", "Mee eens", and "Een beetje mee eens") are manually added
# and will not apply to all variables (sometimes it is "Waar", or a different likert-scale)
for(idx in 1:length(graph_variablenames)) {
  data_grouptable[idx,"variable"] = graph_questionlabels[idx]
  
  data_grouptable[idx,2] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status == "Gebruiker"))
  
  data_grouptable[idx,3] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status == "Niet gebruiker"))

  data_grouptable[idx,4] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status_intention == "Nooit gebruikt en niet van plan"))

  data_grouptable[idx,5] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status_intention == "Nooit gebruikt en neutraal"))

  data_grouptable[idx,6] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status_intention == "Nooit gebruikt en wel van plan"))
}

# Build the basic table
ft <- flextable(
  head(data_grouptable, n = nrow(data_grouptable))
)

# Header labels
tmp_labels = as.data.frame(t(c("", usergroup_labels)))
colnames(tmp_labels) <- c("variable", usergroup_names)
ft <- set_header_labels(ft, values = tmp_labels)

# Set up the footer of totals
totals = c("Totaal", user_totals)
totals[-1] <- paste(totals[-1], " (100.0%)")

# Percentages and totals
for(colname in colnames(data_grouptable)) {
  if(colname != "variable") {
    # Add percentage to cell
    if (user_totals[1,colname]==0) {
      ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (0.0%)"))
    }
    else {
      ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (", sprintf("%.1f", eval(parse(text=colname))/user_totals[1,colname]*100), "%)"))
    }
    
  }
}

# Actually add the footer with totals
ft <- add_footer_row(ft, values = totals, colwidths = rep(1, length(totals)))

# Change layout of table, and footer specifically
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "right", part = "footer")
ft <- padding(ft, padding = 5, part = "footer")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.

# Note: 7 inch is the page width in Word
# We now divide this into 1.5 inch for the first column (the values),
# and divide the other columns equally among the remaining 5.5 inch.
# If you only have one or few columns, you might want to reduce the total width below:
table_width <- 7

# Set width
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 1.5)
ft_out <- width(ft_out, j = -1, width = (table_width-1.5)/(length(colnames(data_grouptable))-1))

ft_out

```


```{r echo=FALSE, results="asis"}
graph_variablenames = c("SI1_UTAUT", 
                        "SI2_UTAUT",
                        "Beliefs_civicduty")
graph_questionlabels = c("Veel mensen in mijn omgeving gebruiken de CoronaMelder", 
                         "Mensen in mijn directe omgeving vinden dat ik de CoronaMelder moet gebruiken",
                         "Het gebruiken van de CoronaMelder maakt je een goede burger")
# For each of these variables we would like to test if the current users and non users differ in the proportion that agrees with the statement. 
# First calculate a proportion for the variable. 
data$SI1_UTAUT_agree[(data$SI1_UTAUT == 'Helemaal mee eens'| data$SI1_UTAUT == 'Mee eens'| data$SI1_UTAUT == 'Een beetje mee eens')] <- "Totaal eens"
data$SI1_UTAUT_agree[(data$SI1_UTAUT == 'Neutraal'| data$SI1_UTAUT == 'Een beetje oneens'| data$SI1_UTAUT == 'Oneens'| data$SI1_UTAUT == 'Helemaal mee oneens')] <- "Neutraal, niet mee eens" 
#View(data[,c("SI1_UTAUT","SI1_UTAUT_agree")])
testtable = table(data$SI1_UTAUT_agree, data$user_status)
#chisq.test(testtable) 

#tab1 <- tableby(SI1_UTAUT_agree ~ user_status + geslacht + lftdcat + sted + belbezig, data=data_selected)
#summary(tab1)
```

### Privacy en dataveiligheid 
Nog een factor die een rol kan spelen in de adoptie is de verwachting met betrekking tot de privacy en dataveiligheid. Een opvallend groot aandeel beoordeelt de foutieve stellingen dat de CoronaMelder de locatie bijhoudt (`r round((nrow(filter(data, (Beliefs_locationmonitoring == 'Zeker waar'| Beliefs_locationmonitoring == 'Misschien waar'))) /nrow(data))*100, digits = 1)`%) en dat de CoronaMelder persoonsgegevens opslaat (`r round((nrow(filter(data, (Beliefs_identitymonitoring == 'Zeker waar'| Beliefs_identitymonitoring == 'Misschien waar'))) /nrow(data))*100, digits = 1)`%) als waar. Daartegenover staat wel dat men het idee heeft dat er vertrouwelijk wordt omgegaan met de informatie (`r round((nrow(filter(data, (Beliefs_datasafety == 'Zeker waar'| Beliefs_datasafety == 'Misschien waar'))) /nrow(data))*100, digits = 1)`%). 


```{r privacy, echo=FALSE, fig.width=7, fig.height=2, fig.cap="Privacy overtuigingen"}
# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("Beliefs_datasafety",
                        "Beliefs_locationmonitoring", 
                        "Beliefs_identitymonitoring")
graph_questionlabels = c("Alle informatie die ik geef in de CoronaMelder wordt vertrouwelijk behandeld",
                         "De CoronaMelder houdt mijn locatie bij", 
                         "De CoronaMelder slaat mijn naam of persoonsgegevens op"); 

# These questions have 5 answer categories: Zeker niet waar - Zeker waar en Weet ik niet. The following color palette should be used:
color_palette = my_palette5blue
# Order of the question categories: first = most green, last = most red # Check if the answer categories match with the codebook (e.g, sometimes also 'weet ik niet is one of the answeroptions')
graph_answercategories = c("Weet ik niet", "Zeker waar", "Misschien waar", "Misschien niet waar", "Zeker niet waar"); 

### Nothing needs to be changed in the script below. 
# Create a dataframe for the plot
#First only keep the variables you wish to keep. Note: nomem_enc is the participant id
data_graph_wideformat = select(data, nomem_encr, all_of(graph_variablenames))

#Convert it to long format
data_graph_longformat = melt(data_graph_wideformat, id.vars = c('nomem_encr'), measure.vars = graph_variablenames)

# Set the correct ordering of the questions (by default the first variable is placed on the bottom)
# It is not needed to reverse the order of the questionlabels. 
data_graph_longformat$variable <- factor(data_graph_longformat$variable,levels = rev(graph_variablenames))

# Also invert the order of the question labels (as default is that the first element of the vector is placed on the bottom)
graph_questionlabels = rev(graph_questionlabels)

# Set the correct ordering of the answer categories (by default on alphabetic order)
data_graph_longformat$value <- factor(data_graph_longformat$value,levels = graph_answercategories)

# Create the plot
theplot <- ggplot(data=data_graph_longformat, aes(fill=value, x=variable)) + theme_bw() + geom_bar(aes(y = (..count..)/sum(..count..)*length(graph_variablenames))) + scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1)) + coord_flip() + labs(x = "", y = "", fill = "") + scale_fill_manual(values=color_palette, drop=FALSE, labels=stringr::str_wrap(graph_answercategories, width = 10)) + scale_x_discrete(labels=stringr::str_wrap(graph_questionlabels, width = 30)) + theme(plot.margin = margin(0, 0, 0, 0), legend.text=element_text(size=8))

aligned <- align_plots(baseplot, theplot, align="v")
ggdraw(aligned[[2]])

# Create the table. Step 1: new data frame containing counts
data_table = data.frame(matrix(0, ncol = 0, nrow = length(levels(data[[graph_variablenames[1]]]))))

# We need one extra (empty) column label for the row with the possible values
table_questionlabels = list()
table_questionlabels["table_answercategories"] <- ""

# We also need the 'unreversed' question labels ;)
graph_questionlabels_unrev <- rev(graph_questionlabels)

# Inefficient loop, but it does a lot for us: add the counts as columns to the dataframe,
# and add the correct labels for column headings
for(idx in 1:length(graph_variablenames)) {
  
  if (idx == 1) {
    data_table["table_answercategories"] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[1]
  }
  
  # Add to new dataframe
  data_table[graph_variablenames[idx]] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[2]
  
  # Add correct mapping to column headings
  table_questionlabels[graph_variablenames[idx]] <- graph_questionlabels_unrev[idx]
}




# Build the basic table
ft <- flextable(
  head(data_table, n = nrow(data_table))
)

# Header labels
ft <- set_header_labels(ft, values = table_questionlabels)

# Set up the footer of totals
totals = c("Totaal")

# Percentages and totals
for(colname in colnames(data_table)) {
  if(colname != "table_answercategories") {
    # Add percentage to cell
    ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (", sprintf("%.1f", eval(parse(text=colname))/sum(eval(parse(text=colname)))*100), "%)"))
    
    # Add total to footer
    tablecolumn = paste("data_table$", colname)
    totals <- c(totals, paste(sum(eval(parse(text=tablecolumn))), " (100%)"))
  }
}

# Actually add the footer with totals
ft <- add_footer_row(ft, values = totals, colwidths = rep(1, length(totals)))

# Change layout of table, and footer specifically
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "right", part = "footer")
ft <- padding(ft, padding = 5, part = "footer")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.

# Note: 7 inch is the page width in Word
# We now divide this into 1.5 inch for the first column (the values),
# and divide the other columns equally among the remaining 5.5 inch.
# If you only have one or few columns, you might want to reduce the total width below:
table_width <- 7

# Set width
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 1.5)
ft_out <- width(ft_out, j = -1, width = (table_width-1.5)/(length(colnames(data_table))-1))

ft_out

```
#### Privacy en dataveiligheid naar gebruikersstatus
```{r chiBeliefsdatasafetyusernonuser, echo=FALSE}
# First calculate a proportion for the variable. 
data$Beliefs_datasafety_agree[(data$Beliefs_datasafety == 'Zeker waar'| data$Beliefs_datasafety == 'Misschien waar')] <- "Totaal waar"
data$Beliefs_datasafety_agree[(data$Beliefs_datasafety == 'Weet ik niet'| data$Beliefs_datasafety == 'Zeker niet waar'| data$Beliefs_datasafety == 'Misschien niet waar')] <- "Weet niet, niet waar" 
# Select the data: Only compare the current users and never users
data_selected = data[data$nomem_encr %in% data_currentvsneveruser$nomem_encr, ]
data_selected$user_status = droplevels(data_selected$user_status)

# Convert into a table that can be used for the chi square test
chisq.table = table(data_selected$Beliefs_datasafety_agree, data_selected$user_status)
chisqtest = chisq.test(chisq.table) 
```

De chi kwadraat toets (X²(`r chisqtest$parameter`) = `r round(chisqtest$statistic, digits = 2)`, p `r ifelse(chisqtest$p.value < 0.001, "<0.001", paste("=", round(chisqtest$p.value, digits = 3)))`) liet zien dat er `r if(chisqtest$p.value > 0.05){"g"}`een significant verschil was in het percentage gebruikers (`r round((nrow(filter(data_selected, (user_status == 'Gebruiker'& Beliefs_datasafety_agree == 'Totaal waar'))) /nrow(filter(data_selected, (user_status == 'Gebruiker'))))*100, digits = 1)`%) dat denkt dat het waar is dat de informatie in de CoronaMelder app strikt vertrouwelijk wordt gehouden, vergeleken met degenen die de app nooit hebben gebruikt (`r round((nrow(filter(data_selected, (user_status == 'Niet gebruiker' & Beliefs_datasafety_agree == 'Totaal waar'))) /nrow(filter(data_selected, (user_status == 'Niet gebruiker'))))*100, digits = 1)`%). 

```{r chiBeliefsdatasafetyusernonuserneutral, echo=FALSE}
# First calculate a proportion for the variable. 
data$Beliefs_datasafety_agree[(data$Beliefs_datasafety == 'Zeker waar'| data$Beliefs_datasafety == 'Misschien waar')] <- "Totaal waar"
data$Beliefs_datasafety_agree[(data$Beliefs_datasafety == 'Weet ik niet'| data$Beliefs_datasafety == 'Zeker niet waar'| data$Beliefs_datasafety == 'Misschien niet waar')] <- "Weet niet, niet waar" 
# Select the data: Only compare the current users and never users
data_selected = data[data$nomem_encr %in% data_currentvsneveruserneutral$nomem_encr, ]
data_selected$user_status_intention = droplevels(data_selected$user_status_intention)

# Convert into a table that can be used for the chi square test
chisq.table = table(data_selected$Beliefs_datasafety_agree, data_selected$user_status_intention)
chisqtest = chisq.test(chisq.table) 
```

Daarnaast liet de chi kwadraat toets (X²(`r chisqtest$parameter`) = `r round(chisqtest$statistic, digits = 2)`, p `r ifelse(chisqtest$p.value < 0.001, "<0.001", paste("=", round(chisqtest$p.value, digits = 3)))`) zien dat er `r if(chisqtest$p.value > 0.05){"g"}`een significant verschil was in het percentage gebruikers (`r round((nrow(filter(data_selected, (user_status_intention == 'Gebruiker'& Beliefs_datasafety_agree == 'Totaal waar'))) /nrow(filter(data_selected, (user_status_intention == 'Gebruiker'))))*100, digits = 1)`%) dat denkt dat het waar is dat de informatie in de CoronaMelder app strikt vertrouwelijk wordt gehouden, vergeleken met degenen die de app nooit hebben gebruikt en daarnaast aangaven neutraal te zijn in hun intentie om de CoronaMelder te gaan gebruiken (`r round((nrow(filter(data_selected, (user_status_intention == 'Nooit gebruikt en neutraal' & Beliefs_datasafety_agree == 'Totaal waar'))) /nrow(filter(data_selected, (user_status_intention == 'Nooit gebruikt en neutraal'))))*100, digits = 1)`%). 

```{r chiBeliefslocationmonitoringusernonuser, echo=FALSE}
# First calculate a proportion for the variable. 
data$Beliefs_locationmonitoring_agree[(data$Beliefs_locationmonitoring == 'Zeker waar'| data$Beliefs_locationmonitoring == 'Misschien waar')] <- "Totaal waar"
data$Beliefs_locationmonitoring_agree[(data$Beliefs_locationmonitoring == 'Weet ik niet'| data$Beliefs_locationmonitoring == 'Zeker niet waar'| data$Beliefs_locationmonitoring == 'Misschien niet waar')] <- "Weet niet, niet waar" 
# Select the data: Only compare the current users and never users
data_selected = data[data$nomem_encr %in% data_currentvsneveruser$nomem_encr, ]
data_selected$user_status = droplevels(data_selected$user_status)

# Convert into a table that can be used for the chi square test
chisq.table = table(data_selected$Beliefs_locationmonitoring_agree, data_selected$user_status)
chisqtest = chisq.test(chisq.table) 
```

De chi kwadraat toets (X²(`r chisqtest$parameter`) = `r round(chisqtest$statistic, digits = 2)`, p `r ifelse(chisqtest$p.value < 0.001, "<0.001", paste("=", round(chisqtest$p.value, digits = 3)))`) liet zien dat er `r if(chisqtest$p.value > 0.05){"g"}`een significant verschil was in het percentage gebruikers (`r round((nrow(filter(data_selected, (user_status == 'Gebruiker'& Beliefs_locationmonitoring_agree == 'Totaal waar'))) /nrow(filter(data_selected, (user_status == 'Gebruiker'))))*100, digits = 1)`%) dat denkt dat de CoronaMelder de locatie van de gebruiker bijhoudt, vergeleken met degenen die de app nooit hebben gebruikt (`r round((nrow(filter(data_selected, (user_status == 'Niet gebruiker' & Beliefs_locationmonitoring_agree == 'Totaal waar'))) /nrow(filter(data_selected, (user_status == 'Niet gebruiker'))))*100, digits = 1)`%). 

```{r chiBeliefslocationmonitoringusernonuserneutral, echo=FALSE}
# First calculate a proportion for the variable. 
data$Beliefs_locationmonitoring_agree[(data$Beliefs_locationmonitoring == 'Zeker waar'| data$Beliefs_locationmonitoring == 'Misschien waar')] <- "Totaal waar"
data$Beliefs_locationmonitoring_agree[(data$Beliefs_locationmonitoring == 'Weet ik niet'| data$Beliefs_locationmonitoring == 'Zeker niet waar'| data$Beliefs_locationmonitoring == 'Misschien niet waar')] <- "Weet niet, niet waar" 
# Select the data: Only compare the current users and never users
data_selected = data[data$nomem_encr %in% data_currentvsneveruserneutral$nomem_encr, ]
data_selected$user_status_intention = droplevels(data_selected$user_status_intention)

# Convert into a table that can be used for the chi square test
chisq.table = table(data_selected$Beliefs_locationmonitoring_agree, data_selected$user_status_intention)
chisqtest = chisq.test(chisq.table) 
```

Daarnaast liet de chi kwadraat toets (X²(`r chisqtest$parameter`) = `r round(chisqtest$statistic, digits = 2)`, p `r ifelse(chisqtest$p.value < 0.001, "<0.001", paste("=", round(chisqtest$p.value, digits = 3)))`) zien dat er `r if(chisqtest$p.value > 0.05){"g"}`een significant verschil was in het percentage gebruikers (`r round((nrow(filter(data_selected, (user_status_intention == 'Gebruiker'& Beliefs_locationmonitoring_agree == 'Totaal waar'))) /nrow(filter(data_selected, (user_status_intention == 'Gebruiker'))))*100, digits = 1)`%) dat denkt dat de CoronaMelder de locatie van de gebruiker bijhoudt, vergeleken met degenen die de app nooit hebben gebruikt, vergeleken met degenen die de app nooit hebben gebruikt en daarnaast aangaven neutraal te zijn in hun intentie om de CoronaMelder te gaan gebruiken (`r round((nrow(filter(data_selected, (user_status_intention == 'Nooit gebruikt en neutraal' & Beliefs_locationmonitoring_agree == 'Totaal waar'))) /nrow(filter(data_selected, (user_status_intention == 'Nooit gebruikt en neutraal'))))*100, digits = 1)`%). 


```{r chiBeliefsidentitymonitoringusernonuser, echo=FALSE}
# First calculate a proportion for the variable. 
data$Beliefs_identitymonitoring_agree[(data$Beliefs_identitymonitoring == 'Zeker waar'| data$Beliefs_identitymonitoring == 'Misschien waar')] <- "Totaal waar"
data$Beliefs_identitymonitoring_agree[(data$Beliefs_identitymonitoring == 'Weet ik niet'| data$Beliefs_identitymonitoring == 'Zeker niet waar'| data$Beliefs_identitymonitoring == 'Misschien niet waar')] <- "Weet niet, niet waar" 
# Select the data: Only compare the current users and never users
data_selected = data[data$nomem_encr %in% data_currentvsneveruser$nomem_encr, ]
data_selected$user_status = droplevels(data_selected$user_status)

# Convert into a table that can be used for the chi square test
chisq.table = table(data_selected$Beliefs_identitymonitoring_agree, data_selected$user_status)
chisqtest = chisq.test(chisq.table) 
```

De chi kwadraat toets (X²(`r chisqtest$parameter`) = `r round(chisqtest$statistic, digits = 2)`, p `r ifelse(chisqtest$p.value < 0.001, "<0.001", paste("=", round(chisqtest$p.value, digits = 3)))`) liet zien dat er `r if(chisqtest$p.value > 0.05){"g"}`een significant verschil was in het percentage gebruikers (`r round((nrow(filter(data_selected, (user_status == 'Gebruiker'& Beliefs_identitymonitoring_agree == 'Totaal waar'))) /nrow(filter(data_selected, (user_status == 'Gebruiker'))))*100, digits = 1)`%) dat denkt dat de CoronaMelder de naam of persoonsgegevens van de gebruiker bijhoudt, vergeleken met degenen die de app nooit hebben gebruikt (`r round((nrow(filter(data_selected, (user_status == 'Niet gebruiker' & Beliefs_identitymonitoring_agree == 'Totaal waar'))) /nrow(filter(data_selected, (user_status == 'Niet gebruiker'))))*100, digits = 1)`%). 

```{r chiBeliefsidentitymonitoringusernonuserneutral, echo=FALSE}
# First calculate a proportion for the variable. 
data$Beliefs_identitymonitoring_agree[(data$Beliefs_identitymonitoring == 'Zeker waar'| data$Beliefs_identitymonitoring == 'Misschien waar')] <- "Totaal waar"
data$Beliefs_identitymonitoring_agree[(data$Beliefs_identitymonitoring == 'Weet ik niet'| data$Beliefs_identitymonitoring == 'Zeker niet waar'| data$Beliefs_identitymonitoring == 'Misschien niet waar')] <- "Weet niet, niet waar" 
# Select the data: Only compare the current users and never users
data_selected = data[data$nomem_encr %in% data_currentvsneveruserneutral$nomem_encr, ]
data_selected$user_status_intention = droplevels(data_selected$user_status_intention)

# Convert into a table that can be used for the chi square test
chisq.table = table(data_selected$Beliefs_identitymonitoring_agree, data_selected$user_status_intention)
chisqtest = chisq.test(chisq.table) 
```

Daarnaast liet de chi kwadraat toets (X²(`r chisqtest$parameter`) = `r round(chisqtest$statistic, digits = 2)`, p `r ifelse(chisqtest$p.value < 0.001, "<0.001", paste("=", round(chisqtest$p.value, digits = 3)))`) zien dat er `r if(chisqtest$p.value > 0.05){"g"}`een significant verschil was in het percentage gebruikers (`r round((nrow(filter(data_selected, (user_status_intention == 'Gebruiker'& Beliefs_identitymonitoring_agree == 'Totaal waar'))) /nrow(filter(data_selected, (user_status_intention == 'Gebruiker'))))*100, digits = 1)`%) dat denkt dat de CoronaMelder de naam of persoonsgegevens van de gebruiker bijhoudt, vergeleken met degenen die de app nooit hebben gebruikt en daarnaast aangaven neutraal te zijn in hun intentie om de CoronaMelder te gaan gebruiken (`r round((nrow(filter(data_selected, (user_status_intention == 'Nooit gebruikt en neutraal' & Beliefs_identitymonitoring_agree == 'Totaal waar'))) /nrow(filter(data_selected, (user_status_intention == 'Nooit gebruikt en neutraal'))))*100, digits = 1)`%). 


```{r, echo=FALSE, tab.cap ="Privacy en dataveiligheid naar gebruikersstatus. Aantal en totaal percentage waar (misschien waar, zeker waar)."}

# === EDIT THESE TO CUSTOMIZE TABLE ===

# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("Beliefs_datasafety",
                        "Beliefs_locationmonitoring", 
                        "Beliefs_identitymonitoring")
graph_questionlabels = c("Alle informatie die ik geef in de CoronaMelder wordt vertrouwelijk behandeld", 
                         "De CoronaMelder houdt mijn locatie bij", 
                         "De CoronaMelder slaat mijn naam of persoonsgegevens op") 

# Which values do we want to include in the table cells?
include_vars = c("Zeker waar", "Misschien waar")

# === NO MORE EDITS SHOULD BE NEEDED BELOW THIS POINT ===

# Split by user groups
data_grouptable = data.frame(matrix(ncol = length(colnames(user_totals))+1, nrow = length(graph_variablenames)))

colnames(data_grouptable) <- c("variable", usergroup_names)

# Set the values for each variable. Note: this still contains too much logic right now, the values that are counted 
# as correct (in this case "Helemaal mee eens", "Mee eens", and "Een beetje mee eens") are manually added
# and will not apply to all variables (sometimes it is "Waar", or a different likert-scale)
for(idx in 1:length(graph_variablenames)) {
  data_grouptable[idx,"variable"] = graph_questionlabels[idx]
  
  data_grouptable[idx,2] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status == "Gebruiker"))
  
  data_grouptable[idx,3] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status == "Niet gebruiker"))

  data_grouptable[idx,4] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status_intention == "Nooit gebruikt en niet van plan"))

  data_grouptable[idx,5] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status_intention == "Nooit gebruikt en neutraal"))

  data_grouptable[idx,6] = nrow(filter(data, (eval(parse(text=graph_variablenames[idx]))) %in% include_vars & user_status_intention == "Nooit gebruikt en wel van plan"))
}

# Build the basic table
ft <- flextable(
  head(data_grouptable, n = nrow(data_grouptable))
)

# Header labels
tmp_labels = as.data.frame(t(c("", usergroup_labels)))
colnames(tmp_labels) <- c("variable", usergroup_names)
ft <- set_header_labels(ft, values = tmp_labels)

# Set up the footer of totals
totals = c("Totaal", user_totals)
totals[-1] <- paste(totals[-1], " (100.0%)")

# Percentages and totals
for(colname in colnames(data_grouptable)) {
  if(colname != "variable") {
    # Add percentage to cell
    if (user_totals[1,colname]==0) {
      ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (0.0%)"))
    }
    else {
      ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (", sprintf("%.1f", eval(parse(text=colname))/user_totals[1,colname]*100), "%)"))
    }
    
  }
}

# Actually add the footer with totals
ft <- add_footer_row(ft, values = totals, colwidths = rep(1, length(totals)))

# Change layout of table, and footer specifically
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "right", part = "footer")
ft <- padding(ft, padding = 5, part = "footer")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.

# Note: 7 inch is the page width in Word
# We now divide this into 1.5 inch for the first column (the values),
# and divide the other columns equally among the remaining 5.5 inch.
# If you only have one or few columns, you might want to reduce the total width below:
table_width <- 7

# Set width
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 1.5)
ft_out <- width(ft_out, j = -1, width = (table_width-1.5)/(length(colnames(data_grouptable))-1))

ft_out

```




## Effecten
### Meldingen en reacties op adviezen gegeven in de melding

#### Ontvangen meldingen en opvolging van de adviezen
In totaal hebben `r nrow(filter(data, (Behavior_UTAUT == 'Ik gebruik de CoronaMelder app op dit moment' | Behavior_UTAUT == 'Ik heb de CoronaMelder app in het verleden wel gebruikt maar op dit moment niet meer') & (notifications_1 == 'Ja, 1 keer' | notifications_1 == 'Ja, al meerdere keren')))` deelnemers die de app nu gebruikten, of gebruikt hadden, minstens één melding gehad vanuit de app; dat is `r round(nrow(filter(data, (Behavior_UTAUT == 'Ik gebruik de CoronaMelder app op dit moment' | Behavior_UTAUT == 'Ik heb de CoronaMelder app in het verleden wel gebruikt maar op dit moment niet meer') & (notifications_1 == 'Ja, 1 keer' | notifications_1 == 'Ja, al meerdere keren')))/nrow(filter(data, (Behavior_UTAUT == 'Ik gebruik de CoronaMelder app op dit moment' | Behavior_UTAUT == 'Ik heb de CoronaMelder app in het verleden wel gebruikt maar op dit moment niet meer')))*100, digits = 1)`%. Vanwege dit lage aantal zijn de vervolgvragen voor deelnemers die een melding hebben ontvangen (daadwerkelijke opvolging van de adviezen, etc.) niet verder bekeken. 

#### Intentie tot opvolgen adviezen gegeven in de melding
Aan de respondenten is gevraagd in hoeverre zij de intentie hebben om, na ontvangen van een melding, zich te houden aan de adviezen die in een melding van de CoronaMelder worden gegeven. Om dit te onderzoeken werd proefpersonen twee sitaties voorgelegd (situatie waarin men wel of geen symptomen had) en werd een screenshot van de melding getoond. Een belangrijke noot bij deze resultaten is dat ten tijde van deze enquete het testbeleid zo was dat men na het ontvangen van een melding alleen kon laten testen indien symptomen aawezig waren (in de appendix kan de vragenlijst inclusief screenshot van melding gevonden worden). 

In figuur \@ref(fig:adherencenotificationsnosymp) is te zien dat respondenten over het algemeen de juiste intenties hebben wat betreft het opvolgen van geadviseerd gedrag wanneer men geen symptomen heeft. Zo zou ruim twee derde thuisblijven zolang geadviseerd (`r round((nrow(filter(data, (AdherenceNotificationMeasuresNosymptoms_Quarantaine == 'Helemaal mee eens'| AdherenceNotificationMeasuresNosymptoms_Quarantaine == 'Mee eens'| AdherenceNotificationMeasuresNosymptoms_Quarantaine == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`%), en geen bezoek ontvangen (`r round((nrow(filter(data, (AdherenceNotificationMeasuresNoSymptoms_Visits == 'Helemaal mee eens'| AdherenceNotificationMeasuresNoSymptoms_Visits == 'Mee eens'| AdherenceNotificationMeasuresNoSymptoms_Visits == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`%). Iets meer dan één vierde geeft aan een coronatest aan te zullen vragen (`r round((nrow(filter(data, (AdherenceNotificationMeasuresNosymptoms_Test == 'Helemaal mee eens'| AdherenceNotificationMeasuresNosymptoms_Test == 'Mee eens'| AdherenceNotificationMeasuresNosymptoms_Test == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`%) of de huisarts te bellen (`r round((nrow(filter(data, (AdherenceNotificationMeasuresNosymptoms_CallGP == 'Helemaal mee eens'| AdherenceNotificationMeasuresNosymptoms_CallGP == 'Mee eens'| AdherenceNotificationMeasuresNosymptoms_CallGP == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`%).

``` {r adherencenotificationsnosymp, echo=FALSE, fig.width=7, fig.height=2.5, fig.cap="Intentie tot opvolgen adviezen zonder symptomen", tab.cap="Intentie tot opvolgen adviezen zonder symptomen"}
# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("AdherenceNotificationMeasuresNosymptoms_Test", 
                        "AdherenceNotificationMeasuresNosymptoms_Quarantaine", 
                        "AdherenceNotificationMeasuresNoSymptoms_Visits", 
                        "AdherenceNotificationMeasuresNosymptoms_CallGP")
graph_questionlabels = c("Bellen om coronatest aan te vragen", 
                         "Thuisblijven zo lang de melding adviseert", 
                         "Geen bezoek ontvangen", 
                         "De huisarts bellen"); 


# These questions have 8 answer categories: Helemaal mee eens - Helemaal mee oneens and no use. The following color palette should be used:
color_palette = my_palette_nonuse
# Order of the question categories: first = most green, last = most red
graph_answercategories = c("Ik zou de CoronaMelder app niet gebruiken", "Helemaal mee eens", "Mee eens", "Een beetje mee eens", "Neutraal", "Een beetje oneens", "Oneens", "Helemaal mee oneens"); 

# Create a dataframe for the plot
#First only keep the variables you wish to keep. Note: nomem_enc is the participant id
data_graph_wideformat = select(data, nomem_encr, all_of(graph_variablenames))

#Convert it to long format
data_graph_longformat = melt(data_graph_wideformat, id.vars = c('nomem_encr'), measure.vars = graph_variablenames)

# Set the correct ordering of the questions (by default the first variable is placed on the bottom)
data_graph_longformat$variable <- factor(data_graph_longformat$variable,levels = rev(graph_variablenames))

# Also invert the order of the question labels (as default is that the first element of the vector is placed on the bottom)
graph_questionlabels = rev(graph_questionlabels)

# Set the correct ordering of the answer categories (by default on alphabetic order)
data_graph_longformat$value <- factor(data_graph_longformat$value,levels = graph_answercategories)

# Create the plot
theplot <- ggplot(data=data_graph_longformat, aes(fill=value, x=variable)) + theme_bw() + geom_bar(aes(y = (..count..)/sum(..count..)*length(graph_variablenames))) + scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1)) + coord_flip() + labs(x = "", y = "", fill = "") + scale_fill_manual(values=color_palette, drop=FALSE, labels=stringr::str_wrap(graph_answercategories, width = 10)) + scale_x_discrete(labels=stringr::str_wrap(graph_questionlabels, width = 30)) + theme(plot.margin = margin(0, 0, 0, 0), legend.text=element_text(size=8))

aligned <- align_plots(baseplot, theplot, align="v")
ggdraw(aligned[[2]])

# Create the table. Step 1: new data frame containing counts
data_table = data.frame(matrix(0, ncol = 0, nrow = length(levels(data[[graph_variablenames[1]]]))))

# We need one extra (empty) column label for the row with the possible values
table_questionlabels = list()
table_questionlabels["table_answercategories"] <- ""

# We also need the 'unreversed' question labels ;)
graph_questionlabels_unrev <- rev(graph_questionlabels)

# Inefficient loop, but it does a lot for us: add the counts as columns to the dataframe,
# and add the correct labels for column headings
for(idx in 1:length(graph_variablenames)) {
  
  if (idx == 1) {
    data_table["table_answercategories"] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[1]
  }
  
  # Add to new dataframe
  data_table[graph_variablenames[idx]] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[2]
  
  # Add correct mapping to column headings
  table_questionlabels[graph_variablenames[idx]] <- graph_questionlabels_unrev[idx]
}




# Build the basic table
ft <- flextable(
  head(data_table, n = nrow(data_table))
)

# Header labels
ft <- set_header_labels(ft, values = table_questionlabels)

# Set up the footer of totals
totals = c("Totaal")

# Percentages and totals
for(colname in colnames(data_table)) {
  if(colname != "table_answercategories") {
    # Add percentage to cell
    ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (", sprintf("%.1f", eval(parse(text=colname))/sum(eval(parse(text=colname)))*100), "%)"))
    
    # Add total to footer
    tablecolumn = paste("data_table$", colname)
    totals <- c(totals, paste(sum(eval(parse(text=tablecolumn))), " (100%)"))
  }
}

# Actually add the footer with totals
ft <- add_footer_row(ft, values = totals, colwidths = rep(1, length(totals)))

# Change layout of table, and footer specifically
ft <- width(ft, j = 1, width = 2)
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "right", part = "footer")
ft <- padding(ft, padding = 5, part = "footer")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.

# Note: 7 inch is the page width in Word
# We now divide this into 1.5 inch for the first column (the values),
# and divide the other columns equally among the remaining 5.5 inch.
# If you only have one or few columns, you might want to reduce the total width below:
table_width <- 7

# Set width
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 1.5)
ft_out <- width(ft_out, j = -1, width = (table_width-1.5)/(length(colnames(data_table))-1))

ft_out
```

Figuur \@ref(fig:adherencenotificationssympt) laat zien dat respondenten over het algemeen ook de juiste intenties hebben wanneer men wel symptomen heeft. Van de respondenten met symptomen geeft `r round((nrow(filter(data, (AdherenceNotificationMeasuresSymptoms_Test == 'Helemaal mee eens'| AdherenceNotificationMeasuresSymptoms_Test == 'Mee eens'| AdherenceNotificationMeasuresSymptoms_Test == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`% aan te bellen voor een coronatest, geeft `r round((nrow(filter(data, (AdherenceNotificationMeasuresSymptoms_Quarantaine == 'Helemaal mee eens'| AdherenceNotificationMeasuresSymptoms_Quarantaine == 'Mee eens'| AdherenceNotificationMeasuresSymptoms_Quarantaine == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`% aan thuis te blijven zolang geadviseerd, en geeft `r round((nrow(filter(data, (AdherenceNotificationMeasuresSymptoms_Visits == 'Helemaal mee eens'| AdherenceNotificationMeasuresSymptoms_Visits == 'Mee eens'| AdherenceNotificationMeasuresSymptoms_Visits == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`% aan geen bezoek te ontvangen na ontvangen van een melding. Toch geeft ook nog bijna de helft aan de huisarts te zullen bellen (`r round((nrow(filter(data, (AdherenceNotificationMeasuresSymptoms_CallGP == 'Helemaal mee eens'| AdherenceNotificationMeasuresSymptoms_CallGP == 'Mee eens'| AdherenceNotificationMeasuresSymptoms_CallGP == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`%).

```{r adherencenotificationssympt, echo=FALSE, fig.width=7, fig.height=2.5, fig.cap="Intentie tot opvolgen adviezen met symptomen", tab.cap="Intentie tot opvolgen adviezen met symptomen"}
# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("AdherenceNotificationMeasuresSymptoms_Test", 
                        "AdherenceNotificationMeasuresSymptoms_Quarantaine", 
                        "AdherenceNotificationMeasuresSymptoms_Visits", 
                        "AdherenceNotificationMeasuresSymptoms_CallGP")
graph_questionlabels = c("Bellen om coronatest aan te vragen", 
                         "Thuisblijven zo lang de melding adviseert", 
                         "Geen bezoek ontvangen", 
                         "De huisarts bellen"); 

# These questions have 8 answer categories: Helemaal mee eens - Helemaal mee oneens and no use. The following color palette should be used:
color_palette = my_palette_nonuse
# Order of the question categories: first = most green, last = most red
graph_answercategories = c("Ik zou de CoronaMelder app niet gebruiken", "Helemaal mee eens", "Mee eens", "Een beetje mee eens", "Neutraal", "Een beetje oneens", "Oneens", "Helemaal mee oneens"); 

# Create a dataframe for the plot
#First only keep the variables you wish to keep. Note: nomem_enc is the participant id
data_graph_wideformat = select(data, nomem_encr, all_of(graph_variablenames))

#Convert it to long format
data_graph_longformat = melt(data_graph_wideformat, id.vars = c('nomem_encr'), measure.vars = graph_variablenames)

# Set the correct ordering of the questions (by default the first variable is placed on the bottom)
data_graph_longformat$variable <- factor(data_graph_longformat$variable,levels = rev(graph_variablenames))

# Also invert the order of the question labels (as default is that the first element of the vector is placed on the bottom)
graph_questionlabels = rev(graph_questionlabels)

# Set the correct ordering of the answer categories (by default on alphabetic order)
data_graph_longformat$value <- factor(data_graph_longformat$value,levels = graph_answercategories)

# Create the plot
theplot <- ggplot(data=data_graph_longformat, aes(fill=value, x=variable)) + theme_bw() + geom_bar(aes(y = (..count..)/sum(..count..)*length(graph_variablenames))) + scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1)) + coord_flip() + labs(x = "", y = "", fill = "") + scale_fill_manual(values=color_palette, drop=FALSE, labels=stringr::str_wrap(graph_answercategories, width = 10)) + scale_x_discrete(labels=stringr::str_wrap(graph_questionlabels, width = 30)) + theme(plot.margin = margin(0, 0, 0, 0), legend.text=element_text(size=8))

aligned <- align_plots(baseplot, theplot, align="v")
ggdraw(aligned[[2]])

# Create the table. Step 1: new data frame containing counts
data_table = data.frame(matrix(0, ncol = 0, nrow = length(levels(data[[graph_variablenames[1]]]))))

# We need one extra (empty) column label for the row with the possible values
table_questionlabels = list()
table_questionlabels["table_answercategories"] <- ""

# We also need the 'unreversed' question labels ;)
graph_questionlabels_unrev <- rev(graph_questionlabels)

# Inefficient loop, but it does a lot for us: add the counts as columns to the dataframe,
# and add the correct labels for column headings
for(idx in 1:length(graph_variablenames)) {
  
  if (idx == 1) {
    data_table["table_answercategories"] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[1]
  }
  
  # Add to new dataframe
  data_table[graph_variablenames[idx]] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[2]
  
  # Add correct mapping to column headings
  table_questionlabels[graph_variablenames[idx]] <- graph_questionlabels_unrev[idx]
}




# Build the basic table
ft <- flextable(
  head(data_table, n = nrow(data_table))
)

# Header labels
ft <- set_header_labels(ft, values = table_questionlabels)

# Set up the footer of totals
totals = c("Totaal")

# Percentages and totals
for(colname in colnames(data_table)) {
  if(colname != "table_answercategories") {
    # Add percentage to cell
    ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (", sprintf("%.1f", eval(parse(text=colname))/sum(eval(parse(text=colname)))*100), "%)"))
    
    # Add total to footer
    tablecolumn = paste("data_table$", colname)
    totals <- c(totals, paste(sum(eval(parse(text=tablecolumn))), " (100%)"))
  }
}

# Actually add the footer with totals
ft <- add_footer_row(ft, values = totals, colwidths = rep(1, length(totals)))

# Change layout of table, and footer specifically
ft <- width(ft, j = 1, width = 2)
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "right", part = "footer")
ft <- padding(ft, padding = 5, part = "footer")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.

# Note: 7 inch is the page width in Word
# We now divide this into 1.5 inch for the first column (the values),
# and divide the other columns equally among the remaining 5.5 inch.
# If you only have one or few columns, you might want to reduce the total width below:
table_width <- 7

# Set width
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 1.5)
ft_out <- width(ft_out, j = -1, width = (table_width-1.5)/(length(colnames(data_table))-1))

ft_out
```

#### Intentie tot opvolgen adviezen gegeven in de melding - alleen huidig gebruikers
Dezelfde bepalingen zijn ook gedaan in alleen de subsample (n = `r nrow(filter(data, Behavior_UTAUT == 'Ik gebruik de CoronaMelder app op dit moment'))`) die momenteel de CoronaMelder gebruikt. 

``` {r adherencenotificationsnosympcurrentusers, message=FALSE, echo=FALSE, fig.width=7, fig.height=2.2, fig.cap="Intentie tot opvolgen adviezen zonder symptomen - alleen huidig gebruikers", tab.cap="Intentie tot opvolgen adviezen zonder symptomen - alleen huidig gebruikers"}
# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("AdherenceNotificationMeasuresNosymptoms_Test", 
                        "AdherenceNotificationMeasuresNosymptoms_Quarantaine", 
                        "AdherenceNotificationMeasuresNoSymptoms_Visits", 
                        "AdherenceNotificationMeasuresNosymptoms_CallGP")
graph_questionlabels = c("Bellen om coronatest aan te vragen", 
                         "Thuisblijven zo lang de melding adviseert", 
                         "Geen bezoek ontvangen", 
                         "De huisarts bellen"); 

# These questions have 8 answer categories: Helemaal mee eens - Helemaal mee oneens and no use. 
# However, for without symptoms, nobody answered "Ik zou de CoronaMelder app niet gebruiken". Therefore, the following color palette should be used:
color_palette = my_palette7
# Order of the question categories: first = most green, last = most red
graph_answercategories = c("Helemaal mee eens", "Mee eens", "Een beetje mee eens", "Neutraal", "Een beetje oneens", "Oneens", "Helemaal mee oneens"); 

# Create a dataframe for the plot
# Select only the current users
data_selected = data[ which(data$Behavior_UTAUT=='Ik gebruik de CoronaMelder app op dit moment'
), ]
#First only keep the variables you wish to keep. Note: nomem_enc is the participant id
data_graph_wideformat = select(data_selected, nomem_encr, all_of(graph_variablenames))

#Convert it to long format
data_graph_longformat = melt(data_graph_wideformat, id.vars = c('nomem_encr'), measure.vars = graph_variablenames)

# Set the correct ordering of the questions (by default the first variable is placed on the bottom)
data_graph_longformat$variable <- factor(data_graph_longformat$variable,levels = rev(graph_variablenames))

# Also invert the order of the question labels (as default is that the first element of the vector is placed on the bottom)
graph_questionlabels = rev(graph_questionlabels)

# Set the correct ordering of the answer categories (by default on alphabetic order)
data_graph_longformat$value <- factor(data_graph_longformat$value,levels = graph_answercategories)

# Create the plot
theplot <- ggplot(data=data_graph_longformat, aes(fill=value, x=variable)) + theme_bw() + geom_bar(aes(y = (..count..)/sum(..count..)*length(graph_variablenames))) + scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1)) + coord_flip() + labs(x = "", y = "", fill = "") + scale_fill_manual(values=color_palette, drop=FALSE, labels=stringr::str_wrap(graph_answercategories, width = 10)) + scale_x_discrete(labels=stringr::str_wrap(graph_questionlabels, width = 30)) + theme(plot.margin = margin(0, 0, 0, 0), legend.text=element_text(size=8))

aligned <- align_plots(baseplot, theplot, align="v")
ggdraw(aligned[[2]])

# Create the table. Step 1: new data frame containing counts
data_table = data.frame(matrix(0, ncol = 0, nrow = length(levels(data[[graph_variablenames[1]]]))))

# We need one extra (empty) column label for the row with the possible values
table_questionlabels = list()
table_questionlabels["table_answercategories"] <- ""

# We also need the 'unreversed' question labels ;)
graph_questionlabels_unrev <- rev(graph_questionlabels)

# Inefficient loop, but it does a lot for us: add the counts as columns to the dataframe,
# and add the correct labels for column headings
for(idx in 1:length(graph_variablenames)) {
  
  if (idx == 1) {
    data_table["table_answercategories"] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[1]
  }
  
  # Add to new dataframe
  data_table[graph_variablenames[idx]] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[2]
  
  # Add correct mapping to column headings
  table_questionlabels[graph_variablenames[idx]] <- graph_questionlabels_unrev[idx]
}




# Build the basic table
ft <- flextable(
  head(data_table, n = nrow(data_table))
)

# Header labels
ft <- set_header_labels(ft, values = table_questionlabels)

# Set up the footer of totals
totals = c("Totaal")

# Percentages and totals
for(colname in colnames(data_table)) {
  if(colname != "table_answercategories") {
    # Add percentage to cell
    ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (", sprintf("%.1f", eval(parse(text=colname))/sum(eval(parse(text=colname)))*100), "%)"))
    
    # Add total to footer
    tablecolumn = paste("data_table$", colname)
    totals <- c(totals, paste(sum(eval(parse(text=tablecolumn))), " (100%)"))
  }
}

# Actually add the footer with totals
ft <- add_footer_row(ft, values = totals, colwidths = rep(1, length(totals)))

# Change layout of table, and footer specifically
ft <- width(ft, j = 1, width = 2)
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "right", part = "footer")
ft <- padding(ft, padding = 5, part = "footer")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.

# Note: 7 inch is the page width in Word
# We now divide this into 1.5 inch for the first column (the values),
# and divide the other columns equally among the remaining 5.5 inch.
# If you only have one or few columns, you might want to reduce the total width below:
table_width <- 7

# Set width
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 1.5)
ft_out <- width(ft_out, j = -1, width = (table_width-1.5)/(length(colnames(data_table))-1))

ft_out
```


```{r adherencenotificationssymptcurrentusers, echo=FALSE, fig.width=7, fig.height=2.5, fig.cap="Intentie tot opvolgen adviezen met symptomen - alleen huidig gebruikers", tab.cap="Intentie tot opvolgen adviezen met symptomen - alleen huidig gebruikers"}
# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("AdherenceNotificationMeasuresSymptoms_Test", 
                        "AdherenceNotificationMeasuresSymptoms_Quarantaine", 
                        "AdherenceNotificationMeasuresSymptoms_Visits", 
                        "AdherenceNotificationMeasuresSymptoms_CallGP")
graph_questionlabels = c("Bellen om coronatest aan te vragen", 
                         "Thuisblijven zo lang de melding adviseert", 
                         "Geen bezoek ontvangen", 
                         "De huisarts bellen"); 

# These questions have 8 answer categories: Helemaal mee eens - Helemaal mee oneens and no use. The following color palette should be used:
color_palette = my_palette_nonuse
# Order of the question categories: first = most green, last = most red
graph_answercategories = c("Ik zou de CoronaMelder app niet gebruiken", "Helemaal mee eens", "Mee eens", "Een beetje mee eens", "Neutraal", "Een beetje oneens", "Oneens", "Helemaal mee oneens"); 

# Create a dataframe for the plot
# Select only the current users
data_selected = data[ which(data$Behavior_UTAUT=='Ik gebruik de CoronaMelder app op dit moment'
), ]
#First only keep the variables you wish to keep. Note: nomem_enc is the participant id
data_graph_wideformat = select(data_selected, nomem_encr, all_of(graph_variablenames))

#Convert it to long format
data_graph_longformat = melt(data_graph_wideformat, id.vars = c('nomem_encr'), measure.vars = graph_variablenames)

# Set the correct ordering of the questions (by default the first variable is placed on the bottom)
data_graph_longformat$variable <- factor(data_graph_longformat$variable,levels = rev(graph_variablenames))

# Also invert the order of the question labels (as default is that the first element of the vector is placed on the bottom)
graph_questionlabels = rev(graph_questionlabels)

# Set the correct ordering of the answer categories (by default on alphabetic order)
data_graph_longformat$value <- factor(data_graph_longformat$value,levels = graph_answercategories)

# Create the plot
theplot <- ggplot(data=data_graph_longformat, aes(fill=value, x=variable)) + theme_bw() + geom_bar(aes(y = (..count..)/sum(..count..)*length(graph_variablenames))) + scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1)) + coord_flip() + labs(x = "", y = "", fill = "") + scale_fill_manual(values=color_palette, drop=FALSE, labels=stringr::str_wrap(graph_answercategories, width = 10)) + scale_x_discrete(labels=stringr::str_wrap(graph_questionlabels, width = 30)) + theme(plot.margin = margin(0, 0, 0, 0), legend.text=element_text(size=8))

aligned <- align_plots(baseplot, theplot, align="v")
ggdraw(aligned[[2]])

# Create the table. Step 1: new data frame containing counts
data_table = data.frame(matrix(0, ncol = 0, nrow = length(levels(data[[graph_variablenames[1]]]))))

# We need one extra (empty) column label for the row with the possible values
table_questionlabels = list()
table_questionlabels["table_answercategories"] <- ""

# We also need the 'unreversed' question labels ;)
graph_questionlabels_unrev <- rev(graph_questionlabels)

# Inefficient loop, but it does a lot for us: add the counts as columns to the dataframe,
# and add the correct labels for column headings
for(idx in 1:length(graph_variablenames)) {

  if (idx == 1) {
    data_table["table_answercategories"] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[1]
  }
    
  # Add to new dataframe
  data_table[graph_variablenames[idx]] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[2]
  
  # Add correct mapping to column headings
  table_questionlabels[graph_variablenames[idx]] <- graph_questionlabels_unrev[idx]
}




# Build the basic table
ft <- flextable(
  head(data_table, n = nrow(data_table))
)

# Header labels
ft <- set_header_labels(ft, values = table_questionlabels)

# Set up the footer of totals
totals = c("Totaal")

# Percentages and totals
for(colname in colnames(data_table)) {
  if(colname != "table_answercategories") {
    # Add percentage to cell
    ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (", sprintf("%.1f", eval(parse(text=colname))/sum(eval(parse(text=colname)))*100), "%)"))
    
    # Add total to footer
    tablecolumn = paste("data_table$", colname)
    totals <- c(totals, paste(sum(eval(parse(text=tablecolumn))), " (100%)"))
  }
}

# Actually add the footer with totals
ft <- add_footer_row(ft, values = totals, colwidths = rep(1, length(totals)))

# Change layout of table, and footer specifically
ft <- width(ft, j = 1, width = 2)
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "right", part = "footer")
ft <- padding(ft, padding = 5, part = "footer")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.

# Note: 7 inch is the page width in Word
# We now divide this into 1.5 inch for the first column (the values),
# and divide the other columns equally among the remaining 5.5 inch.
# If you only have one or few columns, you might want to reduce the total width below:
table_width <- 7

# Set width
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 1.5)
ft_out <- width(ft_out, j = -1, width = (table_width-1.5)/(length(colnames(data_table))-1))

ft_out
```


#### Verklarende factoren opvolging adviezen gegeven in melding
##### Zelfeffectiviteit opvolging adviezen
Om de zelfeffectiviteit in kaart te brengen werd gevraagd in welke mate men dacht in staat te zijn om de adviezen uit de melding op te volgen. Men acht zichzelf goed in staat om te bellen voor een test (`r round((nrow(filter(data, (HBM_selfefficacy_Test == 'Helemaal mee eens'| HBM_selfefficacy_Test == 'Mee eens'| HBM_selfefficacy_Test == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`%), zo lang thuis te blijven als wordt geadviseerd (`r round((nrow(filter(data, (HBM_selfefficacy_Quarantaine == 'Helemaal mee eens'| HBM_selfefficacy_Quarantaine == 'Mee eens'| HBM_selfefficacy_Quarantaine == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`%), geen bezoek te ontvangen (`r round((nrow(filter(data, (HBM_selfefficacy_Visits == 'Helemaal mee eens'| HBM_selfefficacy_Visits == 'Mee eens'| HBM_selfefficacy_Visits == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`%) en de huisarts te bellen (`r round((nrow(filter(data, (HBM_selfefficacy_GP == 'Helemaal mee eens'| HBM_selfefficacy_GP == 'Mee eens'| HBM_selfefficacy_GP == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`%).


```{r adherencenotificationsselfefficacy, echo=FALSE, fig.width=7, fig.height=2, fig.cap="Eigen effectiviteit om adviezen op te volgen", tab.cap="Eigen effectiviteit om adviezen op te volgen"}

# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("HBM_selfefficacy_Test", 
                        "HBM_selfefficacy_Quarantaine", 
                        "HBM_selfefficacy_Visits",
                        "HBM_selfefficacy_GP")
graph_questionlabels = c("... te bellen voor een test", 
                         "... zo lang thuis te blijven als wordt geadviseerd", 
                         "... geen bezoek te ontvangen",
                         "... de huisarts te bellen"); 

# These questions have 7 answer categories: Helemaal mee eens - Helemaal mee oneens. The following color palette should be used:
color_palette = my_palette7
# Order of the question categories: first = most green, last = most red # Check if the answer categories match with the codebook (e.g, sometimes also 'weet ik niet is one of the answeroptions')
graph_answercategories = c("Helemaal mee eens", "Mee eens", "Een beetje mee eens", "Neutraal", "Een beetje oneens", "Oneens", "Helemaal mee oneens"); 

# Create a dataframe for the plot
#First only keep the variables you wish to keep. Note: nomem_enc is the participant id
data_graph_wideformat = select(data, nomem_encr, all_of(graph_variablenames))

#Convert it to long format
data_graph_longformat = melt(data_graph_wideformat, id.vars = c('nomem_encr'), measure.vars = graph_variablenames)

# Set the correct ordering of the questions (by default the first variable is placed on the bottom)
data_graph_longformat$variable <- factor(data_graph_longformat$variable,levels = rev(graph_variablenames))

# Also invert the order of the question labels (as default is that the first element of the vector is placed on the bottom)
graph_questionlabels = rev(graph_questionlabels)

# Set the correct ordering of the answer categories (by default on alphabetic order)
data_graph_longformat$value <- factor(data_graph_longformat$value,levels = graph_answercategories)

# Create the plot
theplot <- ggplot(data=data_graph_longformat, aes(fill=value, x=variable)) + theme_bw() + geom_bar(aes(y = (..count..)/sum(..count..)*length(graph_variablenames))) + scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1)) + coord_flip() + labs(x = "", y = "", fill = "") + scale_fill_manual(values=color_palette, drop=FALSE, labels=stringr::str_wrap(graph_answercategories, width = 10)) + scale_x_discrete(labels=stringr::str_wrap(graph_questionlabels, width = 30)) + theme(plot.margin = margin(0, 0, 0, 0), legend.text=element_text(size=8)) + ggtitle("Ik ben in staat om...") + theme(plot.title = element_text(size=11))

aligned <- align_plots(baseplot, theplot, align="v")
ggdraw(aligned[[2]])

# To check: also create the plot with variable labels
#ggplot(data=data_graph_longformat, aes(fill=value, x=variable)) + theme_bw() + geom_bar(aes(y = (..count..)/sum(..count..)*length(graph_variablenames))) + scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1)) + coord_flip() + labs(x = "", y = "", fill = "") + scale_fill_manual(values=color_palette, drop=FALSE, labels=stringr::str_wrap(graph_answercategories, width = 10)) + theme(plot.margin = margin(0, 0, 0, 0), legend.text=element_text(size=8))

# Create the table. Step 1: new data frame containing counts
data_table = data.frame(matrix(0, ncol = 0, nrow = length(levels(data[[graph_variablenames[1]]]))))

# We need one extra (empty) column label for the row with the possible values
table_questionlabels = list()
table_questionlabels["table_answercategories"] <- ""

# We also need the 'unreversed' question labels ;)
graph_questionlabels_unrev <- rev(graph_questionlabels)

# Inefficient loop, but it does a lot for us: add the counts as columns to the dataframe,
# and add the correct labels for column headings
for(idx in 1:length(graph_variablenames)) {
  
  if (idx == 1) {
    data_table["table_answercategories"] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[1]
  }
  
  # Add to new dataframe
  data_table[graph_variablenames[idx]] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[2]
  
  # Add correct mapping to column headings
  table_questionlabels[graph_variablenames[idx]] <- graph_questionlabels_unrev[idx]
}




# Build the basic table
ft <- flextable(
  head(data_table, n = nrow(data_table))
)

# Header labels
ft <- set_header_labels(ft, values = table_questionlabels)

# Set up the footer of totals
totals = c("Totaal")

# Percentages and totals
for(colname in colnames(data_table)) {
  if(colname != "table_answercategories") {
    # Add percentage to cell
    ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (", sprintf("%.1f", eval(parse(text=colname))/sum(eval(parse(text=colname)))*100), "%)"))
    
    # Add total to footer
    tablecolumn = paste("data_table$", colname)
    totals <- c(totals, paste(sum(eval(parse(text=tablecolumn))), " (100%)"))
  }
}

# Actually add the footer with totals
ft <- add_footer_row(ft, values = totals, colwidths = rep(1, length(totals)))

# Change layout of table, and footer specifically
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "right", part = "footer")
ft <- padding(ft, padding = 5, part = "footer")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 1.5)
ft_out <- width(ft_out, j = -1, width = (table_width-1.5)/(length(colnames(data_table))-1))

ft_out

```


##### Gepercipieerde persoonlijke voor- en nadelen van opvolgen adviezen
Uit het Health Belief Model is bekend dat de mate waarin men verwacht dat een gedrag persoonlijke voor- of nadelen heeft een rol kan spelen in de adoptie van het gedrag. Voor een aantal gedragingen omtrent de opvolging van adviezen zijn deze voor- en nadelen uitgevraagd. Het blijkt dat ongeveer de helft van de respondenten deze persoonlijke voordelen inziet (bellen voor een test: `r round((nrow(filter(data, (HBM_perceivedbenefits_Test == 'Helemaal mee eens'| HBM_perceivedbenefits_Test == 'Mee eens'| HBM_perceivedbenefits_Test == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`%; thuisblijven zolang geadviseerd is: `r round((nrow(filter(data, (HBM_perceivedbenefits_Quarantaine == 'Helemaal mee eens'| HBM_perceivedbenefits_Quarantaine == 'Mee eens'| HBM_perceivedbenefits_Quarantaine == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`%; geen bezoek ontvangen: `r round((nrow(filter(data, (HBM_perceivedbenefits_Visits == 'Helemaal mee eens'| HBM_perceivedbenefits_Visits == 'Mee eens'| HBM_perceivedbenefits_Visits == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`%; de huisarts bellen: `r round((nrow(filter(data, (HBM_perceivedbenefits_GP == 'Helemaal mee eens'| HBM_perceivedbenefits_GP == 'Mee eens'| HBM_perceivedbenefits_GP == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`%), zie figuur \@ref(fig:HBMbenefits). Een aanzienlijke groep staat neutraal tegenover de voordelen om adviezen op te volgen ((bellen voor een test: `r round((nrow(filter(data, (HBM_perceivedbenefits_Test == 'Neutraal'))) /nrow(data))*100, digits = 1)`%; thuisblijven zolang geadviseerd is: `r round((nrow(filter(data, (HBM_perceivedbenefits_Quarantaine == 'Neutraal'))) /nrow(data))*100, digits = 1)`%; geen bezoek ontvangen: `r round((nrow(filter(data, (HBM_perceivedbenefits_Visits == 'Neutraal'))) /nrow(data))*100, digits = 1)`%; de huisarts bellen: `r round((nrow(filter(data, (HBM_perceivedbenefits_GP == 'Neutraal'))) /nrow(data))*100, digits = 1)`%.

```{r HBMbenefits, echo=FALSE, fig.width=7, fig.height=2, fig.cap="Persoonlijke voordelen om adviezen op te volgen", tab.cap="Persoonlijke voordelen om adviezen op te volgen"}

# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("HBM_perceivedbenefits_Test", 
                        "HBM_perceivedbenefits_Quarantaine", 
                        "HBM_perceivedbenefits_Visits",
                        "HBM_perceivedbenefits_GP")
graph_questionlabels = c("... te bellen voor een test", 
                         "... zo lang thuis te blijven als wordt geadviseerd", 
                         "... geen bezoek te ontvangen",
                         "... de huisarts te bellen"); 

# These questions have 7 answer categories: Helemaal mee eens - Helemaal mee oneens. The following color palette should be used:
color_palette = my_palette7
# Order of the question categories: first = most green, last = most red # Check if the answer categories match with the codebook (e.g, sometimes also 'weet ik niet is one of the answeroptions')
graph_answercategories = c("Helemaal mee eens", "Mee eens", "Een beetje mee eens", "Neutraal", "Een beetje oneens", "Oneens", "Helemaal mee oneens"); 

# Create a dataframe for the plot
#First only keep the variables you wish to keep. Note: nomem_enc is the participant id
data_graph_wideformat = select(data, nomem_encr, all_of(graph_variablenames))

#Convert it to long format
data_graph_longformat = melt(data_graph_wideformat, id.vars = c('nomem_encr'), measure.vars = graph_variablenames)

# Set the correct ordering of the questions (by default the first variable is placed on the bottom)
data_graph_longformat$variable <- factor(data_graph_longformat$variable,levels = rev(graph_variablenames))

# Also invert the order of the question labels (as default is that the first element of the vector is placed on the bottom)
graph_questionlabels = rev(graph_questionlabels)

# Set the correct ordering of the answer categories (by default on alphabetic order)
data_graph_longformat$value <- factor(data_graph_longformat$value,levels = graph_answercategories)

# Create the plot
theplot <- ggplot(data=data_graph_longformat, aes(fill=value, x=variable)) + theme_bw() + geom_bar(aes(y = (..count..)/sum(..count..)*length(graph_variablenames))) + scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1)) + coord_flip() + labs(x = "", y = "", fill = "") + scale_fill_manual(values=color_palette, drop=FALSE, labels=stringr::str_wrap(graph_answercategories, width = 10)) + scale_x_discrete(labels=stringr::str_wrap(graph_questionlabels, width = 30)) + theme(plot.margin = margin(0, 0, 0, 0), legend.text=element_text(size=8)) + ggtitle("Het heeft voor mij persoonlijke voordelen om...") + theme(plot.title = element_text(size=11))

aligned <- align_plots(baseplot, theplot, align="v")
ggdraw(aligned[[2]])

# Create the table. Step 1: new data frame containing counts
data_table = data.frame(matrix(0, ncol = 0, nrow = length(levels(data[[graph_variablenames[1]]]))))

# We need one extra (empty) column label for the row with the possible values
table_questionlabels = list()
table_questionlabels["table_answercategories"] <- ""

# We also need the 'unreversed' question labels ;)
graph_questionlabels_unrev <- rev(graph_questionlabels)

# Inefficient loop, but it does a lot for us: add the counts as columns to the dataframe,
# and add the correct labels for column headings
for(idx in 1:length(graph_variablenames)) {
  
  if (idx == 1) {
    data_table["table_answercategories"] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[1]
  }
  
  # Add to new dataframe
  data_table[graph_variablenames[idx]] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[2]
  
  # Add correct mapping to column headings
  table_questionlabels[graph_variablenames[idx]] <- graph_questionlabels_unrev[idx]
}




# Build the basic table
ft <- flextable(
  head(data_table, n = nrow(data_table))
)

# Header labels
ft <- set_header_labels(ft, values = table_questionlabels)

# Set up the footer of totals
totals = c("Totaal")

# Percentages and totals
for(colname in colnames(data_table)) {
  if(colname != "table_answercategories") {
    # Add percentage to cell
    ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (", sprintf("%.1f", eval(parse(text=colname))/sum(eval(parse(text=colname)))*100), "%)"))
    
    # Add total to footer
    tablecolumn = paste("data_table$", colname)
    totals <- c(totals, paste(sum(eval(parse(text=tablecolumn))), " (100%)"))
  }
}

# Actually add the footer with totals
ft <- add_footer_row(ft, values = totals, colwidths = rep(1, length(totals)))

# Change layout of table, and footer specifically
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "right", part = "footer")
ft <- padding(ft, padding = 5, part = "footer")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 1.5)
ft_out <- width(ft_out, j = -1, width = (table_width-1.5)/(length(colnames(data_table))-1))

ft_out
```

Ook met betrekking tot persoonlijke nadelen van het opvolgen van de adviezen blijkt een groot aandeel neutraal te zijn (bellen voor een test: `r round((nrow(filter(data, (HBM_barriers_Test == 'Neutraal'))) /nrow(data))*100, digits = 1)`%; thuisblijven zolang geadviseerd is: `r round((nrow(filter(data, (HBM_barriers_Quarantaine == 'Neutraal'))) /nrow(data))*100, digits = 1)`%; geen bezoek ontvangen: `r round((nrow(filter(data, (HBM_barriers_Visits == 'Neutraal'))) /nrow(data))*100, digits = 1)`%; de huisarts bellen: `r round((nrow(filter(data, (HBM_barriers_GP == 'Neutraal'))) /nrow(data))*100, digits = 1)`%). Er zit variatie in de mate waarin men het eens is met de stellingen of bepaalde acties persoonlijke nadelen hebben. Het percentage mensen dat het eens is met nadelige gevolgen is het grootst voor thuisblijven (`r round((nrow(filter(data, (HBM_barriers_Quarantaine == 'Helemaal mee eens'| HBM_barriers_Quarantaine == 'Mee eens'| HBM_barriers_Quarantaine == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`%) en het niet kunnen ontvangen van bezoek (`r round((nrow(filter(data, (HBM_barriers_Visits == 'Helemaal mee eens'| HBM_barriers_Visits == 'Mee eens'| HBM_barriers_Visits == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`%). Het bellen voor een test (`r round((nrow(filter(data, (HBM_barriers_Test == 'Helemaal mee eens'| HBM_barriers_Test == 'Mee eens'| HBM_barriers_Test == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`%) of de huisarts bellen (`r round((nrow(filter(data, (HBM_barriers_GP == 'Helemaal mee eens'| HBM_barriers_GP == 'Mee eens'| HBM_barriers_GP == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`%) wordt als minder nadelig gezien (zie figuur \@ref(fig:HBMbarriers)).


```{r HBMbarriers, echo=FALSE, fig.width=7, fig.height=2, fig.cap="Persoonlijke nadelen om adviezen op te volgen", tab.cap="Persoonlijke nadelen om adviezen op te volgen"}

# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("HBM_barriers_Test", 
                        "HBM_barriers_Quarantaine", 
                        "HBM_barriers_Visits",
                        "HBM_barriers_GP")
graph_questionlabels = c("... te bellen voor een test", 
                         "... zo lang thuis te blijven als wordt geadviseerd", 
                         "... geen bezoek te ontvangen",
                         "... de huisarts te bellen"); 

# These questions have 7 answer categories: Helemaal mee eens - Helemaal mee oneens. The following color palette should be used:
color_palette = my_palette7
# Order of the question categories: first = most green, last = most red # Check if the answer categories match with the codebook (e.g, sometimes also 'weet ik niet is one of the answeroptions')
graph_answercategories = c("Helemaal mee eens", "Mee eens", "Een beetje mee eens", "Neutraal", "Een beetje oneens", "Oneens", "Helemaal mee oneens"); 

# Create a dataframe for the plot
#First only keep the variables you wish to keep. Note: nomem_enc is the participant id
data_graph_wideformat = select(data, nomem_encr, all_of(graph_variablenames))

#Convert it to long format
data_graph_longformat = melt(data_graph_wideformat, id.vars = c('nomem_encr'), measure.vars = graph_variablenames)

# Set the correct ordering of the questions (by default the first variable is placed on the bottom)
data_graph_longformat$variable <- factor(data_graph_longformat$variable,levels = rev(graph_variablenames))

# Also invert the order of the question labels (as default is that the first element of the vector is placed on the bottom)
graph_questionlabels = rev(graph_questionlabels)

# Set the correct ordering of the answer categories (by default on alphabetic order)
data_graph_longformat$value <- factor(data_graph_longformat$value,levels = graph_answercategories)

# Create the plot
theplot <- ggplot(data=data_graph_longformat, aes(fill=value, x=variable)) + theme_bw() + geom_bar(aes(y = (..count..)/sum(..count..)*length(graph_variablenames))) + scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1)) + coord_flip() + labs(x = "", y = "", fill = "") + scale_fill_manual(values=color_palette, drop=FALSE, labels=stringr::str_wrap(graph_answercategories, width = 10)) + scale_x_discrete(labels=stringr::str_wrap(graph_questionlabels, width = 30)) + theme(plot.margin = margin(0, 0, 0, 0), legend.text=element_text(size=8)) + ggtitle("Het heeft voor mij persoonlijke nadelen om...") + theme(plot.title = element_text(size=11))

aligned <- align_plots(baseplot, theplot, align="v")
ggdraw(aligned[[2]])

# Create the table. Step 1: new data frame containing counts
data_table = data.frame(matrix(0, ncol = 0, nrow = length(levels(data[[graph_variablenames[1]]]))))

# We need one extra (empty) column label for the row with the possible values
table_questionlabels = list()
table_questionlabels["table_answercategories"] <- ""

# We also need the 'unreversed' question labels ;)
graph_questionlabels_unrev <- rev(graph_questionlabels)

# Inefficient loop, but it does a lot for us: add the counts as columns to the dataframe,
# and add the correct labels for column headings
for(idx in 1:length(graph_variablenames)) {
  
  if (idx == 1) {
    data_table["table_answercategories"] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[1]
  }
  
  # Add to new dataframe
  data_table[graph_variablenames[idx]] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[2]
  
  # Add correct mapping to column headings
  table_questionlabels[graph_variablenames[idx]] <- graph_questionlabels_unrev[idx]
}




# Build the basic table
ft <- flextable(
  head(data_table, n = nrow(data_table))
)

# Header labels
ft <- set_header_labels(ft, values = table_questionlabels)

# Set up the footer of totals
totals = c("Totaal")

# Percentages and totals
for(colname in colnames(data_table)) {
  if(colname != "table_answercategories") {
    # Add percentage to cell
    ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (", sprintf("%.1f", eval(parse(text=colname))/sum(eval(parse(text=colname)))*100), "%)"))
    
    # Add total to footer
    tablecolumn = paste("data_table$", colname)
    totals <- c(totals, paste(sum(eval(parse(text=tablecolumn))), " (100%)"))
  }
}

# Actually add the footer with totals
ft <- add_footer_row(ft, values = totals, colwidths = rep(1, length(totals)))

# Change layout of table, and footer specifically
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "right", part = "footer")
ft <- padding(ft, padding = 5, part = "footer")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 1.5)
ft_out <- width(ft_out, j = -1, width = (table_width-1.5)/(length(colnames(data_table))-1))

ft_out
```

### Intentie tot doorgeven GGD-sleutel na positieve test
Als iemand positief is getest op het coronavirus kan men dit daarna via de app laten weten door de GGD-sleutel door te geven aan de GGD medewerker. Dan waarschuwt de app weer mensen bij wie de positief gesteste persoon in de buurt is geweest. Van de respondenten heeft `r round((nrow(filter(data, (Intention_reportinfection == 'Helemaal mee eens'| Intention_reportinfection == 'Mee eens'| Intention_reportinfection == 'Een beetje mee eens'))) /nrow(data))*100, digits = 1)`%  de intentie om de GGD-sleutel door te geven. 

```{r, echo=FALSE, fig.width=7, fig.height=2.5, fig.cap="Intentie tot doorgeven GGD-sleutel", tab.cap="Intentie tot doorgeven GGD-sleutel"}

# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("Intention_reportinfection")
graph_questionlabels = c("Als ik besmet ben, ben ik van plan om dit door te geven via de CoronaMelder app"); 

# These questions have 8 answer categories: Helemaal mee eens - Helemaal mee oneens and no use. The following color palette should be used:
color_palette = my_palette_nonuse
# Order of the question categories: first = most green, last = most red
graph_answercategories = c("Ik zou de CoronaMelder app niet gebruiken", "Helemaal mee eens", "Mee eens", "Een beetje mee eens", "Neutraal", "Een beetje oneens", "Oneens", "Helemaal mee oneens"); 

# Create a dataframe for the plot
#First only keep the variables you wish to keep. Note: nomem_enc is the participant id
data_graph_wideformat = select(data, nomem_encr, all_of(graph_variablenames))

#Convert it to long format
data_graph_longformat = melt(data_graph_wideformat, id.vars = c('nomem_encr'), measure.vars = graph_variablenames)

# Set the correct ordering of the questions (by default the first variable is placed on the bottom)
data_graph_longformat$variable <- factor(data_graph_longformat$variable,levels = rev(graph_variablenames))

# Also invert the order of the question labels (as default is that the first element of the vector is placed on the bottom)
graph_questionlabels = rev(graph_questionlabels)

# Set the correct ordering of the answer categories (by default on alphabetic order)
data_graph_longformat$value <- factor(data_graph_longformat$value,levels = graph_answercategories)

# Create the plot
theplot <- ggplot(data=data_graph_longformat, aes(fill=value, x=variable)) + theme_bw() + geom_bar(aes(y = (..count..)/sum(..count..)*length(graph_variablenames))) + scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1)) + coord_flip() + labs(x = "", y = "", fill = "") + scale_fill_manual(values=my_palette_nonuse, drop=FALSE, labels=stringr::str_wrap(graph_answercategories, width = 10)) + scale_x_discrete(labels=stringr::str_wrap(graph_questionlabels, width = 30)) + theme(plot.margin = margin(0, 0, 0, 0), legend.text=element_text(size=8))

aligned <- align_plots(baseplot, theplot, align="v")
ggdraw(aligned[[2]])

# Create the table. Step 1: new data frame containing counts
data_table = data.frame(matrix(0, ncol = 0, nrow = length(levels(data[[graph_variablenames[1]]]))))

# We need one extra (empty) column label for the row with the possible values
table_questionlabels = list()
table_questionlabels["table_answercategories"] <- ""

# We also need the 'unreversed' question labels ;)
graph_questionlabels_unrev <- rev(graph_questionlabels)

# Inefficient loop, but it does a lot for us: add the counts as columns to the dataframe,
# and add the correct labels for column headings
for(idx in 1:length(graph_variablenames)) {
  
  if (idx == 1) {
    data_table["table_answercategories"] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[1]
  }
  
  # Add to new dataframe
  data_table[graph_variablenames[idx]] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[2]
  
  # Add correct mapping to column headings
  table_questionlabels[graph_variablenames[idx]] <- graph_questionlabels_unrev[idx]
}




# Build the basic table
ft <- flextable(
  head(data_table, n = nrow(data_table))
)

# Header labels
ft <- set_header_labels(ft, values = table_questionlabels)

# Set up the footer of totals
totals = c("Totaal")

# Percentages and totals
for(colname in colnames(data_table)) {
  if(colname != "table_answercategories") {
    # Add percentage to cell
    ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (", sprintf("%.1f", eval(parse(text=colname))/sum(eval(parse(text=colname)))*100), "%)"))
    
    # Add total to footer
    tablecolumn = paste("data_table$", colname)
    totals <- c(totals, paste(sum(eval(parse(text=tablecolumn))), " (100%)"))
  }
}

# Actually add the footer with totals
ft <- add_footer_row(ft, values = totals, colwidths = rep(1, length(totals)))

# Change layout of table, and footer specifically
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "right", part = "footer")
ft <- padding(ft, padding = 5, part = "footer")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 1.5)
ft_out <- width(ft_out, j = -1, width = (table_width-1.5)/(length(colnames(data_table))-1))

ft_out
```

#### Intentie tot doorgeven GGD-sleutel na positieve test - alleen huidig gebruikers
Dezelfde bepalingen zijn ook gedaan in alleen de subsample (n = `r nrow(filter(data, Behavior_UTAUT == 'Ik gebruik de CoronaMelder app op dit moment'))`) die momenteel de CoronaMelder gebruikt. Van deze subsample van respondenten die momenteel de CoronaMelder gebruiken had `r round((nrow(filter(data, (Behavior_UTAUT == 'Ik gebruik de CoronaMelder app op dit moment')&(Intention_reportinfection == 'Helemaal mee eens'| Intention_reportinfection == 'Mee eens'| Intention_reportinfection == 'Een beetje mee eens'))) /nrow(filter(data, Behavior_UTAUT == 'Ik gebruik de CoronaMelder app op dit moment')))*100, digits = 1)`% de  intentie om de GGD sleutel door te geven na een positieve test.  

``` {r sharekeyscurrentusers, echo=FALSE, fig.width=7, fig.height=2, fig.cap="Intentie tot doorgeven GGD-sleutel na positieve test - alleen huidig gebruikers", tab.cap="Intentie tot doorgeven GGD-sleutel na positieve test - alleen huidig gebruikers"}
# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("Intention_reportinfection")
graph_questionlabels = c("Als ik besmet ben, ben ik van plan om dit door te geven via de CoronaMelder app"); 

# These questions have 8 answer categories: Helemaal mee eens - Helemaal mee oneens and no use. 
# However, for without symptoms, nobody answered "Ik zou de CoronaMelder app niet gebruiken". Therefore, the following color palette should be used:
color_palette = my_palette7
# Order of the question categories: first = most green, last = most red
graph_answercategories = c("Helemaal mee eens", "Mee eens", "Een beetje mee eens", "Neutraal", "Een beetje oneens", "Oneens", "Helemaal mee oneens"); 

# Create a dataframe for the plot
# Select only the current users
data_selected = data[ which(data$Behavior_UTAUT=='Ik gebruik de CoronaMelder app op dit moment'
), ]
#First only keep the variables you wish to keep. Note: nomem_enc is the participant id
data_graph_wideformat = select(data_selected, nomem_encr, all_of(graph_variablenames))

#Convert it to long format
data_graph_longformat = melt(data_graph_wideformat, id.vars = c('nomem_encr'), measure.vars = graph_variablenames)

# Set the correct ordering of the questions (by default the first variable is placed on the bottom)
data_graph_longformat$variable <- factor(data_graph_longformat$variable,levels = rev(graph_variablenames))

# Also invert the order of the question labels (as default is that the first element of the vector is placed on the bottom)
graph_questionlabels = rev(graph_questionlabels)

# Set the correct ordering of the answer categories (by default on alphabetic order)
data_graph_longformat$value <- factor(data_graph_longformat$value,levels = graph_answercategories)

# Create the plot
theplot <- ggplot(data=data_graph_longformat, aes(fill=value, x=variable)) + theme_bw() + geom_bar(aes(y = (..count..)/sum(..count..)*length(graph_variablenames))) + scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1)) + coord_flip() + labs(x = "", y = "", fill = "") + scale_fill_manual(values=color_palette, drop=FALSE, labels=stringr::str_wrap(graph_answercategories, width = 10)) + scale_x_discrete(labels=stringr::str_wrap(graph_questionlabels, width = 30)) + theme(plot.margin = margin(0, 0, 0, 0), legend.text=element_text(size=8))

aligned <- align_plots(baseplot, theplot, align="v")
ggdraw(aligned[[2]])

# Create the table. Step 1: new data frame containing counts
data_table = data.frame(matrix(0, ncol = 0, nrow = length(levels(data[[graph_variablenames[1]]]))))

# We need one extra (empty) column label for the row with the possible values
table_questionlabels = list()
table_questionlabels["table_answercategories"] <- ""

# We also need the 'unreversed' question labels ;)
graph_questionlabels_unrev <- rev(graph_questionlabels)

# Inefficient loop, but it does a lot for us: add the counts as columns to the dataframe,
# and add the correct labels for column headings
for(idx in 1:length(graph_variablenames)) {
  
  if (idx == 1) {
    data_table["table_answercategories"] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[1]
  }
  
  # Add to new dataframe
  data_table[graph_variablenames[idx]] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[2]
  
  # Add correct mapping to column headings
  table_questionlabels[graph_variablenames[idx]] <- graph_questionlabels_unrev[idx]
}




# Build the basic table
ft <- flextable(
  head(data_table, n = nrow(data_table))
)

# Header labels
ft <- set_header_labels(ft, values = table_questionlabels)

# Set up the footer of totals
totals = c("Totaal")

# Percentages and totals
for(colname in colnames(data_table)) {
  if(colname != "table_answercategories") {
    # Add percentage to cell
    ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (", sprintf("%.1f", eval(parse(text=colname))/sum(eval(parse(text=colname)))*100), "%)"))
    
    # Add total to footer
    tablecolumn = paste("data_table$", colname)
    totals <- c(totals, paste(sum(eval(parse(text=tablecolumn))), " (100%)"))
  }
}

# Actually add the footer with totals
ft <- add_footer_row(ft, values = totals, colwidths = rep(1, length(totals)))

# Change layout of table, and footer specifically
ft <- width(ft, j = 1, width = 2)
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "right", part = "footer")
ft <- padding(ft, padding = 5, part = "footer")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.

# Note: 7 inch is the page width in Word
# We now divide this into 1.5 inch for the first column (the values),
# and divide the other columns equally among the remaining 5.5 inch.
# If you only have one or few columns, you might want to reduce the total width below:
table_width <- 7

# Set width
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 1.5)
ft_out <- width(ft_out, j = -1, width = (table_width-1.5)/(length(colnames(data_table))-1))

ft_out
```




### Onbeoogde effecten: schijnveiligheid
Een gevoel van schijnveiligheid zou kunnen optreden bij de adoptie van de CoronaMelder, wat ervoor zou kunnen zorgen dat andere maatregelen minder nodig worden geacht. Uit de antwoorden op de stelling of men zich minder aan andere maatregelen kan houden bij het gebruik van de CoronaMelder, blijkt dat slechts een klein aandeel denkt dat dit het geval is. Het aandeel dat op deze vraag 'zeker waar' of 'misschien waar' antwoordt, is `r round((nrow(filter(data, (Beliefs_falsesecurity1 == 'Zeker waar'| Beliefs_falsesecurity1 == 'Misschien waar'))) /nrow(data))*100, digits = 1)`%. Een iets groter percentage denkt dat de CoronaMelder ervoor zorgt dat je niet besmet kunt raken (`r round((nrow(filter(data, (Beliefs_falsesecurity2 == 'Zeker waar'| Beliefs_falsesecurity2 == 'Misschien waar'))) /nrow(data))*100, digits = 1)`%).

```{r falsesecurity, echo=FALSE, fig.width=7, fig.height=2, fig.cap="Schijnveiligheid", tab.cap="Schijnveiligheid"}
# Order in which you would like to have the items appear (first = top, last = bottom) in the horizontal bar chart
graph_variablenames = c("Beliefs_falsesecurity1",
                        "Beliefs_falsesecurity2")
graph_questionlabels = c("Als ik de CoronaMelder gebruik, hoef ik me minder aan de andere maatregelen te houden",
                         "De CoronaMelder zorgt ervoor dat ik niet besmet raak met het coronavirus"); 

# These questions have 5 answer categories: Zeker niet waar - Zeker waar en Weet ik niet. The following color palette should be used:
color_palette = my_palette5blue
# Order of the question categories: first = most green, last = most red # Check if the answer categories match with the codebook (e.g, sometimes also 'weet ik niet is one of the answeroptions')
graph_answercategories = c("Weet ik niet", "Zeker waar", "Misschien waar", "Misschien niet waar", "Zeker niet waar"); 

### Nothing needs to be changed in the script below. 
# Create a dataframe for the plot
#First only keep the variables you wish to keep. Note: nomem_enc is the participant id
data_graph_wideformat = select(data, nomem_encr, all_of(graph_variablenames))

#Convert it to long format
data_graph_longformat = melt(data_graph_wideformat, id.vars = c('nomem_encr'), measure.vars = graph_variablenames)

# Set the correct ordering of the questions (by default the first variable is placed on the bottom)
# It is not needed to reverse the order of the questionlabels. 
data_graph_longformat$variable <- factor(data_graph_longformat$variable,levels = rev(graph_variablenames))

# Also invert the order of the question labels (as default is that the first element of the vector is placed on the bottom)
graph_questionlabels = rev(graph_questionlabels)

# Set the correct ordering of the answer categories (by default on alphabetic order)
data_graph_longformat$value <- factor(data_graph_longformat$value,levels = graph_answercategories)

# Create the plot
theplot <- ggplot(data=data_graph_longformat, aes(fill=value, x=variable)) + theme_bw() + geom_bar(aes(y = (..count..)/sum(..count..)*length(graph_variablenames))) + scale_y_continuous(breaks=seq(0, 1, 0.1), labels=percent_format(accuracy = 1)) + coord_flip() + labs(x = "", y = "", fill = "") + scale_fill_manual(values=color_palette, drop=FALSE, labels=stringr::str_wrap(graph_answercategories, width = 10)) + scale_x_discrete(labels=stringr::str_wrap(graph_questionlabels, width = 30)) + theme(plot.margin = margin(0, 0, 0, 0), legend.text=element_text(size=8))

aligned <- align_plots(baseplot, theplot, align="v")
ggdraw(aligned[[2]])

# Create the table. Step 1: new data frame containing counts
data_table = data.frame(matrix(0, ncol = 0, nrow = length(levels(data[[graph_variablenames[1]]]))))

# We need one extra (empty) column label for the row with the possible values
table_questionlabels = list()
table_questionlabels["table_answercategories"] <- ""

# We also need the 'unreversed' question labels ;)
graph_questionlabels_unrev <- rev(graph_questionlabels)

# Inefficient loop, but it does a lot for us: add the counts as columns to the dataframe,
# and add the correct labels for column headings
for(idx in 1:length(graph_variablenames)) {
  
  if (idx == 1) {
    data_table["table_answercategories"] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[1]
  }
  
  # Add to new dataframe
  data_table[graph_variablenames[idx]] <- as.data.frame(table(data_graph_wideformat[graph_variablenames[idx]]))[2]
  
  # Add correct mapping to column headings
  table_questionlabels[graph_variablenames[idx]] <- graph_questionlabels_unrev[idx]
}




# Build the basic table
ft <- flextable(
  head(data_table, n = nrow(data_table))
)

# Header labels
ft <- set_header_labels(ft, values = table_questionlabels)

# Set up the footer of totals
totals = c("Totaal")

# Percentages and totals
for(colname in colnames(data_table)) {
  if(colname != "table_answercategories") {
    # Add percentage to cell
    ft <- compose(ft, j = colname, value = as_paragraph(eval(parse(text=colname)), " (", sprintf("%.1f", eval(parse(text=colname))/sum(eval(parse(text=colname)))*100), "%)"))
    
    # Add total to footer
    tablecolumn = paste("data_table$", colname)
    totals <- c(totals, paste(sum(eval(parse(text=tablecolumn))), " (100%)"))
  }
}

# Actually add the footer with totals
ft <- add_footer_row(ft, values = totals, colwidths = rep(1, length(totals)))

# Change layout of table, and footer specifically
ft <- fontsize(ft, size = 10, part = "all")
ft <- font(ft, fontname = "Cambria", part = "all")
ft <- align(ft, j = -1, align = "right", part = "footer")
ft <- padding(ft, padding = 5, part = "footer")

# Basic autofit does not work well with Word, found this code below
# but it seems to make all columns of equal size (7 inch / number of columns?)
# Might give unwanted results, so we might want to control this per column.

# Note: 7 inch is the page width in Word
# We now divide this into 1.5 inch for the first column (the values),
# and divide the other columns equally among the remaining 5.5 inch.
# If you only have one or few columns, you might want to reduce the total width below:
table_width <- 7

# Set width
ft_out <- ft %>% autofit()
ft_out <- width(ft_out, j = 1, width = 1.5)
ft_out <- width(ft_out, j = -1, width = (table_width-1.5)/(length(colnames(data_table))-1))

ft_out
```






```{=openxml}
<w:p><w:r><w:br w:type="page"/></w:r></w:p>
```

# Conclusies en aanbevelingen
## Intenties en werkelijk gebruik
Van alle respondenten waren bijna 9 op de 10 (88.7%) in meer of mindere mate bekend met de CoronaMelder. Daarnaast gaf ruim een kwart (27.2%) aan dat hij/zij de CoronaMelder op dit moment gebruikt, en een zeer klein deel (1.6%) had de CoronaMelder in het verleden gebruikt maar op dit moment niet meer. Dit lijkt een redelijk betrouwbare weerspiegeling van de Nederlandse bevolking te zijn, aangezien op het moment van de meting (19 oktober tot en met 1 november) het werkelijke aantal downloads van de CoronaMelder net iets onder het percentage gebruikers in dit panel lag: Op 1 november was de CoronaMelder namelijk tegen de 3.8 miljoen keer gedownload wat tegenover een bevolkingsgrootte van 17.3 miljoen uitkomt op ongeveer 22%. Deze werkelijke adoptiegraad is vergelijkbaar met cijfers uit juli tot en met september (op basis van nieuwsartikelen) van Duitsland (21.4%), Australië (21.6%) en Zwitserland (18.5%). Vooral in Ierland lag de adoptiegraad kort na het uitbrengen van de app al hoog (37%), terwijl in deze in Italië (9.8%) en Frankrijk (3.6%) juist laag waren. Meerdere onderzoekers hebben geprobeerd via simulaties te achterhalen hoe hoog de adoptiegraad zou moeten zijn om het reproductiegetal te verlagen. Het is moeilijk om met een sluitend getal te komen, omdat tracing apps onderdeel vormen van een algehele strategie om de pandemie aan te pakken. Tegelijkertijd hebben de onderzoekers aangetoond dat iedere gebruiker helpt, ook als de adoptiegraad relatief laag blijft, en dat het vooral belangrijk zou kunnen zijn dat mogelijke verspreiders (mensen die bijvoorbeeld veel interacties met anderen moeten hebben) en mensen in risicogroepen de app gaan gebruiken (Blom et al., 2020). Daarnaast gaf een overgrote meerderheid (96.1%) van de respondenten die de app nu gebruikten aan dat zij de app zouden blijven gebruiken in de komende twee maanden. Dit komt overeen met onze verwachtingen op basis van het feit dat het in principe geen moeite kost om de app te blijven gebruiken als deze eenmaal geïnstalleerd is, aangezien deze op de achtergrond draait. Wel laat literatuur op het gebied van ehealth zien dat zaken als een hoog energieverbruik, stress dat wordt verergerd door het gebruik van de app, of een teleurstellende ervaring (bv. onterechte meldingen) ertoe kunnen leiden dat mensen de app zullen deïnstalleren (Thorneloe et al., 2020). Gezien het nog lage aantal deelnemers dat al een melding heeft ontvangen in de huidige meting, kan er nog niets gezegd worden over eventuele effecten van (onterechte) meldingen.

Van de respondenten die de CoronaMelder nog nooit hadden gebruikt, gaf 18% aan van plan te zijn om de app te gaan gebruiken in de komende twee maanden, en 24.5% staat hier neutraal in. Dit komt overeen met cijfers die in de literatuur worden genoemd, bijvoorbeeld door Altmann et al. (2020) die over verschillende landen een gemiddelde intentie om zeker de app te gaan gebruiken van ongeveer 45% rapporteert. Deze meting is gedaan voordat de contact tracing apps in die landen waren uitgekomen, dus er was toen geen vergelijking met werkelijk gebruik. Ook in Nederland is een onderzoek gedaan voordat de app beschikbaar was (Jansen-Kosterink et al., 2020; Proszowska et al., 2020; Strycharz et al., 2020), en daaruit kwam een intentie van 41% om de app te gaan gebruiken. Als we de huidige gebruikers (27.2%) combineren met de respondenten die aangeven van plan te zijn de app binnen twee maanden te gaan gebruiken (18% van 71% niet gebruikers), komen we in de huidige studie uit op 40.1%. Er blijft dus een verschil bestaan tussen intentie en werkelijk gebruik, wat ook in de literatuur terugkomt en wellicht te wijten is aan de intention-behavior gap (Sheeran & Webb, 2016), een bekend fenomeen waarbij maar een klein deel van de mensen met een intentie om bepaald gedrag te vertonen, ook daadwerkelijk dat gedrag gaat uitvoeren. In de volgende onderdelen gaan we op zoek naar verklaringen voor dit verschil tussen intentie en werkelijk gebruik, en ook de latere waves van dit onderzoek zullen hier meer duidelijkheid in gaan scheppen.

Naast dat het belangrijk is om eventuele barrières voor deze mensen met de intentie tot gebruik weg te nemen, is ook de groep die de CoronaMelder nog niet heeft gebruikt maar een neutrale houding inneemt ten opzichte van toekomstig gebruik (24.5% van de niet gebruikers) interessant. Deze groep zou namelijk met de juiste informatievoorziening mogelijk gestimuleerd kunnen worden om de app in gebruik te nemen. We zullen daarom in de volgende onderdelen van onze aanbevelingen ook specifiek op deze groep ingaan.

## Demografie
Bij de vergelijking tussen respondenten die momenteel de CoronaMelder gebruiken en respondenten die de CoronaMelder nooit hebben gebruikt, vielen een aantal demografische factoren op die samenhangen met het gebruiken van de CoronaMelder. Zo was het percentage gebruikers het laagst in de leeftijdsgroep van 15-24 jaar, en dit was ook significant lager dan in de leeftijdsgroep van 55-64 jaar. Dit komt deels overeen met twee studies onder de Nederlandse bevolking die een positief verband vonden tussen leeftijd en adoptie intentie (Jansen-Kosterink et al., 2020; Strycharz et al., 2020), hoewel er in het huidige onderzoek geen lineair stijgende lijn zichtbaar is. Ook in Australië is de contact tracing app het vaakst gedownload door mensen in de leeftijdsgroepen 55-64 en 65-74 jaar (Biddle et al., 2020). In studies onder Duitse (Horstmann et al., 2020) en Zwitserse respondenten (von Wyl et al., 2020) bleek leeftijd juist negatief samen te hangen met adoptie intentie, maar dit zou kunnen komen doordat ouderen niet altijd over de kennis en de (technische) middelen beschikken om de app te kunnen gebruiken. Proszowska et al. (2020) vonden geen verband tussen leeftijd en intentie om de CoronaMelder te gebruiken. Uit de huidige studie blijkt dat de leeftijdsgroep van 15-24 jaar een belangrijke is om in gedachten te houden bij het onder de aandacht brengen van de CoronaMelder.

Opvallend is daarnaast dat hoger opgeleiden vaker de CoronaMelder gebruiken dan lager opgeleiden. Hiermee in lijn is de bevinding dat het percentage gebruikers het hoogst was bij de mensen met hogere inkomens (boven 3501 euro). Dit laatste komt overeen met bevindingen van von Wyl et al. (2020), die in Zwitserland ook een positieve relatie tussen inkomen van het huishouden en adoptie intentie vaststelden. Tenslotte was er, net als in het merendeel van de gevonden literatuur, geen significant verschil in gebruik van de CoronaMelder op basis van geslacht.

## Algemene opvattingen over het coronavirus
Er doen veel waar- maar ook onwaarheden de ronde met betrekking tot het coronavirus. De respondenten werd gevraagd in hoeverre ze dachten dat het waar is dat het coronavirus een biologisch wapen is, en dat het met (de aanleg van) het 5G netwerk te maken heeft. Een op de 5 dacht dat het het coronavirus (misschien of zeker) een biologisch wapen was (19.3%) en iets meer dan 1 op de 20 (5.9%) dat er een verband met 5G was. Dit zijn relatief hoge percentages, dus het is belangrijk om dit soort misconcepties te weerleggen. Vergelijkbare cijfers (15% biologisch wapen, 4% 5G) kwamen ook voort uit een onderzoek van Ipsos in samenwerking met Nieuwsuur (Ipsos, 2020). Een belangrijke bevinding is dat respondenten die de CoronaMelder op dit moment niet gebruikten dachten vaker dat deze stellingen waar waren dan huidige gebruikers. Deze overtuigingen zouden kunnen voortkomen uit onduidelijkheden die bestaan rondom het coronavirus in het algemeen, zoals bijvoorbeeld de oorsprong ervan. De cijfers uit dit onderzoek benadrukken het belang van het corrigeren van mogelijke misvattingen. Wat zou kunnen helpen om deze te weerleggen is om de bevolking niet alleen op de hoogte te houden van de actuele stand van zaken (zoals aantal infecties per dag), maar om ook duidelijk te communiceren over feiten en misvattingen over het virus.

## Gezondheidsmotivatie en risicoperceptie
In de bestaande literatuur vonden we gemengde resultaten (de Wit et al., 2020), waarbij de waargenomen ernst van het virus en het risico om het virus op te lopen in een deel van de onderzoeken als voorspellers werden gezien van intentie om een contact tracing app te gaan gebruiken (Rheault & Musulan, 2020; Strycharz et al., 2020; Wnuk et al., 2020), en dit in andere onderzoeken niet het geval was (Kaspar, 2020; Walrave et al., 2020). In het huidige onderzoek zien we waargenomen ernst en risico wel als voorspellers van werkelijk gebruik: niet gebruikers in het algemeen, en specifiek de groep neutrale niet gebruikers, waren het significant minder vaak eens met stellingen die betrekking hadden op het verwachte risico om zelf besmet te raken met het coronavirus, en het risico om vervolgens anderen te besmetten. Ook met stellingen betreffende de gemeende ernst van het zelf krijgen en anderen besmetten waren de niet gebruikers het minder vaak eens. Het zou daarom mogelijk tot meer adoptie kunnen leiden als de bevolking de risico’s en ernst hoger in zou schatten. Het is belangrijk dat in de communicatie de ernst en vatbaarheid eerlijk en transparant gecommuniceerd worden. 

## Verwachte effectiviteit  
Eerder onderzoek wijst uit dat de overtuiging dat de CoronaMelder bijdraagt aan de bestrijding van het coronavirus een belangrijke motivatie is voor de adoptie (Jansen-Kosterink et al., 2020; Proszowska et al., 2020). Nederlanders lijken volgens eerdere studies sceptisch tegenover de effectiviteit van de CoronaMelder te staan, met name in de leeftijdscategorie 31-49. In deze eerdere studie was voor 13% twijfels over de effectiviteit van de app een belangrijke reden om deze niet te installeren (Jansen-Kosterink et al., 2020). In de huidige studie ligt het percentage respondenten dat het oneens is met de stelling dat de CoronaMelder bijdraagt aan de bestrijding van het coronavirus nog iets hoger, namelijk rond de 20%. Daartegenover staat dat ongeveer de helft van de respondenten van mening is dat de CoronaMelder effectief is ter bestrijding van het coronavirus en ter bescherming van kwetsbare mensen. Dit percentage ligt aanzienlijk hoger bij gebruikers, in vergelijking tot (nog) niet gebruikers die neutraal zijn in hun intentie om de CoronaMelder te gaan gebruiken. De verwachte effectiviteit zou dus een factor kunnen zijn om op in te spelen, en de niet gebruikers met neutrale intenties over te halen tot adoptie. Daarnaast staat nog een flink aandeel (ongeveer 20-25%) neutraal tegenover de stellingen over de verwachte effectiviteit. 

Tegenover het bovenstaande staat dat men over het algemeen dacht dat een (zeer) hoge adoptie nodig is om bij te dragen aan het tegengaan van de verspreiding van het coronavirus. De meesten gaven aan dat 76 tot 90% de CoronaMelder moet gebruiken om effectief te zijn. Daarnaast gaf een aanzienlijk percentage aan niet te weten bij welk percentage adoptie de CoronaMelder bijdraagt (25.3%). Hier zou op ingespeeld kunnen worden, met name omdat men eerder geneigd is om contact tracing apps te installeren voor maatschappelijke voordelen, en niet zo zeer voor individuele voordelen (Trang et al., 2020). Indien duidelijker wordt gecommuniceerd dat de effectiviteit van de CoronaMelder afhankelijk is van het aantal mensen dat deze app installeert, maar dat er ook al een bijdrage is bij een lagere adoptie, is men wellicht sterker bereid om de app te installeren.

## Vertrouwen in adequaatheid techniek en privacy
Een overgroot deel (meer dan 8 op de 10 respondenten) gelooft dat de techniek (bluetooth) die gebruikt wordt in de CoronaMelder inderdaad kan aangeven wie er in de buurt is geweest van een persoon die besmet is. Dit getal lag significant lager bij respondenten die de app nog nooit gebruikt hadden, en ook specifiek bij de groep daarbinnen die neutraal staat tegenover hun toekomstig gebruik van de app, dan bij respondenten die de app gebruikten, maar in alle groepen was dit nog steeds (bijna) 8 op de 10. Over het algemeen lijkt men dus te vertrouwen dat de techniek adequaat is.  

Zorgen over privacy kwamen in onze literatuurstudie (de Wit et al., 2020) terug als een van de grootste redenen om contact tracing apps niet te gebruiken (Biddle et al., 2020; Horstmann et al., 2020; Jansen-Kosterink et al., 2020; Joo & Shin, 2020; Kukuk, 2020; Proszowska et al., 2020; Rheault & Musulan, 2020; Simko et al., 2020; Zhang et al., 2020). Ook bij de respondenten van dit onderzoek lijkt dit een rol te spelen: Terwijl bijna 9 op de 10 huidige gebruikers van de CoronaMelder van mening is dat informatie in de CoronaMelder app strikt vertrouwelijk wordt gehouden, is maar ongeveer de helft het hiermee eens onder de niet gebruikers (en 6 op de 10 niet gebruikers die neutraal staan tegenover het gebruik van de app). Tegelijkertijd bestaan er ook wat misverstanden over de techniek van de CoronaMelder: meer dan de helft van de huidige gebruikers denkt dat de CoronaMelder de locatie van de gebruiker bijhoudt, terwijl zelfs 7 op de 10 van de niet gebruikers dit denkt (65% van de niet gebruikers die neutraal staan tegenover het gebruik van de app). We zien een soortgelijk patroon wanneer het gaat om het bijhouden van de naam of persoonsgegevens van de gebruiker, waarbij 3 op de 10 huidige gebruikers (onterecht) denkt dat dit het geval is, en ook meer dan de helft van de niet gebruikers. Een eerder onderzoek onder de Nederlandse bevolking gaf ook al aan dat er veel misverstanden zijn over zowel de werking van de app, als over de manier waarop gegevens worden verzameld en verwerkt (Proszowska et al., 2020). Het is belangrijk om dit soort misverstanden over de werking van de app uit de wereld te helpen, en om vertrouwen te scheppen in de veiligheid en vertrouwelijkheid van de informatie die door de app wordt opgeslagen en verwerkt. Het is aannemelijk dat deze twee aspecten ook met elkaar te maken hebben, want als men ervan overtuigd is dat de informatie die in de app staat opgeslagen niet persoonlijk en niet tot iemand te herleiden is, zullen er waarschijnlijk ook minder zorgen zijn over hoe vertrouwelijk deze informatie wordt behandeld.

## Maatschappelijke gevolgen
Ongeveer één op de drie respondenten heeft de overtuiging dat de CoronaMelder de Nederlandse economie zal helpen. Ook hier was een groot verschil zichtbaar tussen huidige gebruikers (54.5% eens) en neutrale niet-gebruikers (21.5% eens). De mogelijk positieve bijdrage aan het herstellen van de economie werd ook in de literatuur genoemd als reden om een contact tracing app te gaan gebruiken (Rheault & Musulan, 2020). Het is hierbij wel raadzaam om ervoor te waken dat er geen beloftes gemaakt worden die de CoronaMelder niet kan waarmaken, zoals dat de app alleen (zonder aanvullende maatregelen) ervoor zou kunnen zorgen dat de economie zich zal kunnen herstellen.

## Gebruiksvriendelijkheid en zelfeffectiviteit
Opvallend is dat 1 op de 5 mensen die de CoronaMelder nog niet gebruikt, denkt dat het veel tijd en energie kost om deze te gaan gebruiken en een groot deel hier neutraal in staat. Daar staat tegenover dat van de mensen die de CoronaMelder al gebruiken, slechts 3.9% aangaf dat dit inderdaad het geval was. Bijna 9 op de 10 respondenten die de CoronaMelder al gebruiken gaf aan het niet eens te zijn met deze stelling. Eerder onderzoek wijst uit dat, als men het gevoel heeft dat men weet hoe de app te gebruiken, de adoptie intenties groter zijn (Walrave et al., 2020). Bij de niet gebruikers kan dit dus een drempel zijn voor installeren. In de communicatie naar de niet-gebruikers is het daarom goed om in te spelen op de eigen effectiviteit en het gemak waarmee de CoronaMelder geïnstalleerd kan worden.

## Technologie gerelateerde belemmeringen
Van de respondenten die de CoronaMelder nog niet gebruikten, gaf bijna 3 op de 10 aan dat zij niet beschikken over een smartphone met internet. Bij de niet-gebruikers die neutraal staan tegenover toekomstig gebruik waren dit er nog meer. Dit is niet met alleen communicatie op te lossen aangezien deze mensen mogelijkerwijs niet over de middelen beschikken om de app te kunnen installeren en gebruiken. Ook in onze literatuurstudie kwam een gebrek aan geschikte apparatuur voor als reden om de app niet te kunnen installeren (Horstmann et al., 2020; von Wyl et al., 2020). Daarnaast gaf 13% aan het niet eens met de stelling dat zij genoeg technische kennis hebben om de CoronaMelder te installeren. Ook dit kwam terug in een andere studie (Blom et al., 2020), en zowel het gebrek aan de juiste middelen als aan de benodigde kennis blijkt vaker voor te komen bij mensen die tot de risicogroepen behoren, bijvoorbeeld ouderen (Blom et al., 2020). Dit zou wel verholpen kunnen worden door mensen hulp te bieden bij het installeren van de app, ze te wijzen op de beschikbare manieren om deze hulp te verkrijgen, of om een beroep te doen op naasten om elkaar te helpen en bijvoorbeeld tweedehands (maar voldoende recente) smartphones te doneren.

## Persoonlijke voor- en nadelen van gebruik en verplichting tot gebruik
De persoonlijke voordelen gerelateerd aan gebruik van de CoronaMelder lijken door respondenten niet altijd te worden ingezien. Eerder onderzoek identificeerde verscheidene (directe of indirecte) gepercipieerde persoonlijke voordelen zoals het veilig houden van zichzelf en anderen, de kans op risicovol gedrag verminderen, de economie herstellen, en de potentiële versoepeling van andere maatregelen wanneer het reproductiecijfer daalt (Biddle et al., 2020; Rheault & Musulan, 2020). Het nut van de app inzien kan door positieve ervaringen uit andere landen worden vergroot (Rheault & Musulan, 2020). Daarnaast kan dit gestimuleerd worden door transparant te zijn over de (technische) werking ervan, en bijvoorbeeld over de kans op een onterechte melding dat iemand risico zou lopen. 

Een aanzienlijk percentage staat neutraal tegenover de gepercipieerde voor- en nadelen. Dit zou te maken kunnen hebben met het feit dat maatschappelijke factoren belangrijker zijn voor mensen om de CoronaMelder te installeren, dan persoonlijke voordelen (Trang et al., 2020).

Bijna twee derde van de mensen die de CoronaMelder op dit moment gebruiken geven aan het in meer of mindere mate eens te zijn met de stelling dat men zich verplicht voelt hem te gebruiken. Van de mensen die de CoronaMelder niet gebruiken voelt slechts 12.2% zich verplicht om hem te gebruiken. Hierbij mag wel opgemerkt worden dat slechts 14.3% het hier helemaal mee eens was (en 28.4% eens en 19.9% een beetje mee eens). Een mogelijke verklaring is dat men het gebruiken van de CoronaMelder voelt als een maatschappelijke verplichting. In totaal geeft namelijk meer dan de helft (51.8%) van de gebruikers aan dat het gebruiken van de CoronaMelder je een goed burger maakt. Zelfs acht op de tien gebruikers (77.8%) is het eens met de stelling dat de CoronaMelder helpt om mensen met een kwetsbare gezondheid te beschermen. En meer dan de helft (54.5%) van de gebruikers verwacht dat het gebruiken van de CoronaMelder de Nederlandse economie helpt. Het is echter belangrijk om uit te sluiten dat gevoelens van verplichting voortkomen uit druk of dwang (vanuit de werkgever of overheid) en dus is het belangrijk om hier in vervolgmetingen specifieker naar uit te vragen. 

## Affectieve reacties
De niet-gebruikers met neutrale intenties staan angstiger tegenover de CoronaMelder dan de gebruikers. Angst zou dus een barrière kunnen zijn voor gebruik. Het is mogelijk dat deze angst gerelateerd is aan de onjuiste opvattingen over de CoronaMelder, zoals dat de CoronaMelder een biologisch wapen is. Bij de groep niet-gebruikers met neutrale intenties zal de angst omtrent de CoronaMelder kunnen worden weggenomen om adoptie intenties te bevorderen. Deze angst staat waarschijnlijk los van de angst voor het coronavirus: angst voor een corona uitbraak, en angst om het coronavirus zelf te krijgen, hing volgens een eerdere studie positief samen met app adoptie (Jansen-Kosterink et al., 2020). 

## Sociale invloeden
Respondenten maken een redelijk correcte inschatting (een kleine overschatting) van het aandeel van de Nederlandse bevolking dat de CoronaMelder gebruikt. Interessant genoeg zijn daarnaast zeer weinig mensen het eens met de stelling dat veel mensen in de directe omgeving de CoronaMelder gebruiken. Op deze stelling heeft bijna de helft ‘neutraal’ geantwoord, wat zou kunnen samenhangen met het feit dat men het niet van anderen weet. Het gebruik van de CoronaMelder is relatief onzichtbaar vergeleken met bijvoorbeeld de mondkapjes maatregel, wat ervoor zorgt dat men alleen van het gebruik van anderen te weten komt door erover te praten. Dit leidt ertoe dat mensen zich denken te bevinden in een sociale groep waarin niet veel anderen de CoronaMelder gebruiken, terwijl dit niet de realiteit hoeft te zijn. Ook de eigen inschatting van hoe belangrijk anderen het vinden dat de respondent de CoronaMelder  gebruikt, is weinig positief.

Communicatiestrategieën zouden kunnen inzetten op het verbeteren van de sociale norm. Studies naar de CoronaMelder vonden dat descriptieve normen een rol spelen bij adoptie intentie. Als men het idee heeft dat in de persoonlijke omgeving de CoronaMelder wordt geïnstalleerd, is men geneigd dit zelf ook te doen (Proszowska et al., 2020; Strycharz et al., 2020). Omgekeerd heeft onderzoek ook uitgewezen dat een barrière van adoptie is dat men niet gelooft dat anderen de app zullen installeren (Proszowska et al., 2020; Zhang et al., 2020). Het verbeteren van de zowel de descriptieve, als de injunctieve norm (dat mensen in de directe omgeving het gebruik van de CoronaMelder op prijs stellen), verdienen aandacht. 

## Vertrouwen in de overheid
Een belangrijk verschil tussen huidige gebruikers van de CoronaMelder en de respondenten die de app nog nooit gebruikt hadden, en met name ook de subgroep daarvan die neutraal was over hun intentie om de app binnenkort te gaan gebruiken, was het vertrouwen in de aanpak van de overheid om het coronavirus onder controle te houden. Terwijl 70% van de gebruikers aangaf dit vertrouwen te hebben, had slechts 43.2% van de neutrale niet-gebruikers dit. Ook uit de literatuurstudie bleek dat vertrouwen in de overheid (in algemene zin) een voorspeller is van de intentie om de CoronaMelder te gaan gebruiken (Proszowska et al., 2020; Strycharz et al., 2020). Dit zou te maken kunnen hebben met de zorgen omtrent privacy, die af kunnen nemen wanneer het vertrouwen in de overheid groter is (Biddle et al., 2020). Overigens blijkt dit vertrouwen in de overheid op dit moment relatief laag te zijn voor veel West-Europese landen (Altmann et al., 2020). Het zou dus kunnen helpen om te werken aan dit vertrouwen van de Nederlandse bevolking in de manier waarop de overheid met het coronavirus omgaat. Het is echter niet gemakkelijk om dit te doen, aangezien er zoveel nog niet bekend is over het virus en de effectiviteit van de verschillende maatregelen.

## Zijn gebruikers in het algemeen meer adherent aan de corona gedragsregels?
Uit literatuuronderzoek bleek dat gedrag ten aanzien van de overige maatregelen tegen het coronavirus ook een voorspeller van (intentie tot) adoptie van een contact tracing app is (von Wyl et al., 2020; Kaspar, 2020). We zien in de huidige studie inderdaad dat gebruikers van de CoronaMelder ook de intentie vertonen om zich vaker dan niet-gebruikers aan maatregelen te houden zoals handen wassen, afstand houden, drukke plekken vermijden en thuis blijven bij klachten. Het blijkt echter dat dit anders ligt voor het daadwerkelijk (zelfgerapporteerd gedrag). Gebruikers gaven aan hun handen vaker te wassen met water en zeep dan niet gebruikers maar voor de andere gedragsregels (afstand houden, drukke plekken vermijden) bleek er geen verschil te zijn tussen gebruikers en niet gebruikers. 

## Beoogde effecten

###  Intenties om adviezen uit de app op te volgen
Een zeer klein aantal respondenten uit de steekproef had daadwerkelijk een melding vanuit de app ontvangen. Met deze data kan dus nog niets worden gezegd over in hoeverre men zich houdt aan de geadviseerde gedragsregels. Daarentegen zijn er wel degelijk relevante inzichten met betrekking tot de intenties om adviezen uit de melding op te volgen. In de huidige steekproef geeft ongeveer twee derde aan thuis te blijven als een melding dit adviseert. In een eerdere studie uitgezet in de VS, Frankrijk, het Verenigd Koninkrijk en Italië, hadden 9 op de 10 respondenten de intenties om thuis te blijven als de melding dit adviseert (Altmann et al., 2020). In een ander onderzoek onder Duitse respondenten ligt dit percentage echter veel lager: slechts een derde zou in quarantaine gaan als de app dit adviseert (Blom et al., 2020). Er lijken dus verschillen op te treden tussen landen, maar wellicht is dit verschil ook te verklaren door het moment waarop de vraag gesteld is (d.w.z., aan het begin van de pandemie zoals bij Altmann et al. (2020), of na de eerste piek van besmettingen, zoals bij Blom et al. (2020).). Data van het RIVM wijzen inderdaad uit dat het draagvlak verandert bij verlenging van de maatregelen, maar ook bij een daling in het aantal besmettingen zoals in juni het geval was (RIVM, 2020). De volgende rapportage zal uitwijzen of de positieve intenties onder Nederlandse respondenten ook worden omgezet in gedrag wanneer men een melding ontvangt. Als wordt gekeken naar de intenties van de huidige CoronaMelder gebruikers om thuis te blijven, komt dit percentage wel overeen met de bevindingen van Altman et al. (2020). 

Daarnaast blijkt uit deze studie dat men de juiste intenties heeft wat betreft het opvolgen van geadviseerd gedrag. Zo geeft de ruime meerderheid die (hypothetisch) een waarschuwing van de CoronaMelder ontvangt en géén symptomen heeft, aan thuis te blijven en geen bezoek te ontvangen. Toch zou ook nog ongeveer 1 op de 4 respondenten de huisarts bellen, of bellen om een coronatest aan te vragen. Dit zou te maken kunnen hebben met het feit dat (een deel van) deze mensen kampen met een zwakkere gezondheid, en zich daarom zorgen maken wanneer het coronavirus bij hen geconstateerd wordt. Daarnaast kan hieruit worden afgeleid dat men mogelijk huiverig is voor de consequenties van het coronavirus, en graag extra (specialistische) hulp inschakelt. Het is raadzaam om vanuit de GGD nadrukkelijk te communiceren dat het niet de bedoeling is om de huisarts te bellen bij milde klachten, om zo de druk op de huisartsen te verminderen.

Wanneer men (hypothetisch) wel symptomen heeft, zou 4 op de 5 bellen voor een coronatest, en zou ook ruim 4 op de 5 thuis blijven zolang de melding adviseert. Er is dus nog een aanzienlijk percentage dat zich niet aan de regels zou houden bij klachten. Dit zou gerelateerd kunnen zijn aan de persoonlijke nadelen die men ervaart om te bellen voor een test en thuis te blijven. Daarnaast ziet lang niet iedereen de voordelen in van deze adviezen. Eerder onderzoek toonde aan dat de gepercipieerde voordelen de belangrijkste voorspeller is van adoptie van een contact tracing app onder Nederlanders (Proszowska et al., 2020). Het is aannemelijk dat de gepercipieerde voordelen ook een belangrijke rol spelen bij de intentie tot de opvolging van adviezen. Noodzakelijk is om op de communicatie op de persoonlijke voordelen te richten, zodat de intenties om adviezen van de CoronaMelder op te volgen stijgen. De zelfeffectiviteit blijkt geen barrière te zijn: de overgrote meerderheid acht zichzelf in staat om de adviezen op te volgen.

###  Intenties om de GGD-sleutel door te geven
De huidige studie biedt inzicht in de intentie van respondenten om de GGD-sleutel door te geven bij een positieve test. Een eerdere studie wees uit dat 38% welwillend was om het testresultaat door te geven wanneer deze positief is (Blom et al., 2020). In de huidige studie ligt dit percentage hoger (62% voor de hele sample, 98% bij alleen de gebruikers), het merendeel ziet dus de noodzaak in van het doorgeven van de GGD-sleutel. Er moet hierbij rekening gehouden worden met het feit dat niet iedereen deze intentie om zal zetten tot daadwerkelijk gedrag. In de communicatie naar positief getesten zal het belang van de GGD-sleutel doorgeven moeten worden benadrukt. 

## Onbeoogde effecten: Schijnveiligheid  

Bij diverse Coronamaatregelen, zoals de mondkapjes, is de zorg uitgesproken dat er wellicht schijnveiligheid op zou kunnen treden: door het gebruik van de CoronaMelder zou men kunnen denken dat het niet meer nodig is om andere belangrijke maatregelen, zoals het houden van 1.5 meter afstand, toe te blijven passen. In het algemeen is de theorie (risico compensatie theorie) die achter deze verwachting ligt echter al meerdere malen ontkracht (bv. Pless, 2016), en blijkt ook aan de hand van de huidige data geen rol te spelen. De overgrote meerderheid gelooft niet dat de andere maatregelen niet meer in acht hoeven worden genomen wanneer men CoronaMelder geïnstalleerd heeft. Desalniettemin bleek uit een eerdere studie onder Nederlanders juist wel dat men huiverig is dat (andere) mensen minder voorzichtig worden door de app (Proszowska et al., 2020). Dit is dus iets om in de gaten te blijven houden.   

```{=openxml}
<w:p><w:r><w:br w:type="page"/></w:r></w:p>
```
 

# Referenties
Altmann, S., Milsom, L., Zillessen, H., Blasone, R., Gerdon, F., Bach, R., Kreuter, F., Nosenzo, D., Toussaert, S., &     Abeler, J. (2020). Acceptability of app-based contact tracing for COVID-19: Cross-country survey evidence (Preprint). JMIR MHealth and UHealth, 8(8), e19857. https://doi.org/10.2196/19857

Biddle, N., Edwards, B., Gray, M., Hiscox, M., McEachern, S., & Sollis, K. (2020). Data trust and data privacy in the COVID-19 period.

Blom, A. G., Wenz, A., Cornesse, C., Rettig, T., Fikel, M., Friedel, S., Juhl, S., Lehrer, R., Möhring, K., Naumann, E., Reifenscheid, M., & Krieger, U. (2020). Barriers to the Large-Scale Adoption of the COVID-19 Contact-Tracing App in Germany.

de Wit, J., van der Waal, N., & van der Laan, L. N. (2020). Een rapid review van de literatuur omtrent de adoptie en effectiviteit van contact tracing apps.

Horstmann, K., Buecker, S., Krasko, J., & Kritzler, S. (2020). Who does or does not use the “Corona-Warn-App” and why? PsyArXiv. https://doi.org/10.31234/OSF.IO/E9FU3

Ipsos (2020). Complottheorieën over het coronavirus. Verkregen van https://www.ipsos.com/nl-nl/complottheorieen-over-het-coronavirus op 7 december 2020.

Jansen-Kosterink, S. M., Humuz, M., den Ouden, M., & Van Velsen, L. (2020). Predictors to use mobile apps for monitoring COVID-19 symptoms and contact tracing: A survey among Dutch citizens. MedRxiv.

Joo, J., & Shin, M. M. (2020). Resolving the tension between full utilization of contact tracing app services and user stress as an effort to control the COVID-19 pandemic. Service Business, 1–18.

Kaspar, K. (2020). Motivations for social distancing and app use as complementary measures to combat the COVID-19 pandemic: Quantitative survey study. Journal of Medical Internet Research, 22(8), e21613. https://doi.org/10.2196/21613

Kukuk, L. (2020). Analyzing adoption of contact tracing apps using UTAUT. University of Twente.

Pless, B. (2016). Risk compensation: Revisited and rebutted. Safety, 2(3), 16. https://doi.org/10.3390/safety2030016

Proszowska, D., Jansen, G., & De Vries, P. (2020). COVID-19 en de “intelligente lockdown" in de ogen van de burgers: Deel 3: Meningen over de corona-app. https://coronapapers.nl/uploads/media_item/media_item/146/86/Rapport-Lockdown-in-de-ogen-van-burgers-deel-3-Corona-app-1603965497.pdf

Rheault, L., & Musulan, A. (2020). Explaining Support for COVID-19 Cell Phone Contact Tracing.

RIVM (2020). Gedragswetenschappelijk onderzoek COVID-19. Verkregen van  https://www.rivm.nl/gedragsonderzoek/maatregelen-welbevinden/draagvlak op 7 december 2020.

Sheeran, P., & Webb, T. L. (2016). The intention--behavior gap. Social and Personality Psychology Compass, 10(9), 503–518.

Simko, L., Calo, R., Roesner, F., & Kohno, T. (2020). COVID-19 Contact Tracing and Privacy: Studying Opinion and Preferences. ArXiv Preprint ArXiv:2005.06056.

Strycharz, Bol, Buijzen, Helberger & de Vresse (2020). Preliminary Report: Technological Solutions in a Covid-19 Exit strategy. Societal conditions. Verkregen van https://www.uva-icds.net/wp-content/uploads/2020/10/Report_wave1.pdf op 8 december 2020.

Thorneloe, R., Epton, T., Fynn, W., Daly, M., Stanulewicz, N., Kassianos, A., Shorter, G., Moll, S.-J., Campbell, M., Sodergren, S. C., Chapman, S., Sutherland, L., Armitage, C., Arden, M., Chater, A., Byrne-Davis, L., & Hart, J. (2020). Scoping Review of Mobile Phone App Uptake and Engagement To Inform Digital Contact Tracing Tools for Covid-19. https://doi.org/10.31234/osf.io/qe9b6

Trang, S., Trenz, M., Weiger, W. H., Tarafdar, M., & Cheung, C. M. K. (2020). One app to trace them all? Examining app specifications for mass acceptance of contact-tracing apps. European Journal of Information Systems. https://doi.org/10.1080/0960085X.2020.1784046

von Wyl, V., Hoeglinger, M., Sieber, C., Kaufmann, M., Moser, A., Serra-Burriel, M., Ballouz, T., Menges, D., Frei, A., & Puhan, M. (2020). Are COVID-19 proximity tracing apps working under real-world conditions? Indicator development and assessment of drivers for app (non-) use. MedRxiv.

Walrave, M., Waeterloos, C., & Ponnet, K. (2020). Tracing the COVID-19 Virus: A Health Belief Model Approach to the Adoption of a Contact Tracing App. (Preprint). JMIR Public Health and Surveillance, 6, 1–10. https://doi.org/10.2196/20572

Wnuk, A., Oleksy, T., & Maison, D. (2020). The acceptance of Covid-19 tracking technologies: The role of perceived threat, lack of control, and ideological beliefs. PLOS ONE, 15(9), 1–16.

Zhang, B., Kreps, S., & McMurry, N. (2020). Americans’ perceptions of privacy and surveillance in the COVID-19 Pandemic. https://doi.org/10.31219/osf.io/9wz3y


```{=openxml}
<w:p><w:r><w:br w:type="page"/></w:r></w:p>
```


# Appendix
## Additionele resultaten: Demografie naar gebruikersstatus - Paarsgewijze vergelijkingen
Vergelijking subgroepen met ruwe p-waarden en FDR-gecorrigeerde p-waarden. 
```{r , echo=FALSE}
### Determine all pairwise comparisons for the demgraphic variables the chi square indicated that the variable was not indepnedent from use status. 
# Age category (lftdcat)
data_selected = data_currentvsneveruser
data_selected$lftdcat = droplevels(data_selected$lftdcat)
chisq.table = table(data_selected$lftdcat, data_selected$user_status)
Matriz = chisq.table
pairwiseNominalIndependence(Matriz,
                            fisher = FALSE,
                            gtest  = FALSE,
                            chisq  = TRUE,
                            method = "fdr")
# Educational level (oplmet_simplified)
data_selected = data_currentvsneveruser
data_selected$oplmet_simplified = droplevels(data_selected$oplmet_simplified)
chisq.table = table(data_selected$oplmet_simplified, data_selected$user_status)
Matriz = chisq.table
pairwiseNominalIndependence(Matriz,
                            fisher = FALSE,
                            gtest  = FALSE,
                            chisq  = TRUE,
                            method = "fdr")
# Marital status (burgstat_simplified)
data_selected = data_currentvsneveruser
data_selected$burgstat_simplified = droplevels(data_selected$burgstat_simplified)
chisq.table = table(data_selected$burgstat_simplified, data_selected$user_status)
Matriz = chisq.table
pairwiseNominalIndependence(Matriz,
                            fisher = FALSE,
                            gtest  = FALSE,
                            chisq  = TRUE,
                            method = "fdr")
# Net income (nettocat_simplified)
data_selected = data_currentvsneveruser
data_selected$nettocat_simplified = droplevels(data_selected$nettocat_simplified)
chisq.table = table(data_selected$nettocat_simplified, data_selected$user_status)
Matriz = chisq.table
pairwiseNominalIndependence(Matriz,
                            fisher = FALSE,
                            gtest  = FALSE,
                            chisq  = TRUE,
                            method = "fdr")
```
```{=openxml}
<w:p><w:r><w:br w:type="page"/></w:r></w:p>
```
 

# Bijlagen
Als bijlage kunt u bij dit rapport vinden:  
- Vragenlijst wave 1  
- Vergelijking demografie sample huidig onderzoek, LISS core panel en CBS  













``` {r adherence, echo=FALSE, fig.width=7, fig.cap="Test"}
# Geavanceerd dingetje hier. We moeten 2 kolommen samenvoegen in een dataframe 
# zodat ze in één grafiek terug kunnen komen. Effectief hebben we nu dubbel zo veel rijen.
df_adherence <- data %>% gather("Symptoms", "Value", contains("ymptoms_Test"))

# We raken hiermee de verschillende 'levels' van de antwoorden (volledig mee eens, ...) kwijt,
# dus die moeten we terugzetten:
df_adherence <- mutate(df_adherence, Value = factor(Value, levels=rev(levels(data$AdherenceNotificationMeasuresSymptoms_Test))))

# De grote plot. Deze doet meerdere dingen:
# - Onze gecombineerde kolommen gebruiken op de x-as
# - De frequentie van alle antwoorden omzetten in percentages, dat is die (..count..)/sum(..count..)
# - Omdat we de 2 kolommen hebben samengevoegd is onze dataframe 2x zo lang geworden (zie df_adherence in de Environment voor meer info), waardoor we het percentage moeten verdubbelen: vandaar de *2 (normaal gesproken is die count/sum count voldoende voor totaal van 100%)
# - Schalen en labels goed zetten
# - Inkleuren
#ggplot(data=df_adherence, aes(fill=Value, x=Symptoms)) + geom_bar(aes(y = (..count..)/sum(..count..)*2)) + scale_y_continuous(labels=percent) + scale_x_discrete(labels=c("Geen symptomen", "Wel symptomen")) + labs(x = "", y = "", fill = "") + scale_fill_manual(values=my_palette_nonuse, labels=c("Ik zou de app niet gebruiken", "Helemaal mee eens", "Mee eens", "Een beetje mee eens", "Neutraal", "Een beetje oneens", "Oneens", "Helemaal oneens")) + coord_flip() + theme(plot.margin = margin(0.2, 0.2, 0, 0, "cm"), legend.position = "bottom", legend.text=element_text(size=8))

```

